{"version":3,"file":"main.cjs","sources":["../src/Functions.ts","../node_modules/@empowerfresh/intelliwake/dist/main.js","../src/SortSearch.ts","../src/Database/PGSQL/PGEnum.ts","../src/Database/PGSQL/PGColumn.ts","../src/Database/PGSQL/PGIndex.ts","../src/Database/PGSQL/PGForeignKey.ts","../src/Database/PGSQL/PGTable.ts","../src/Database/PGSQL/PGParams.ts","../src/Database/PGSQL/PGSQL.ts","../src/Database/CTableBase.ts","../src/Database/PGSQL/PGView.ts","../src/Database/PGSQL/PGMatView.ts","../src/Database/PGSQL/PGFunc.ts","../src/Database/PGSQL/PGWhereSearchClause.ts"],"sourcesContent":["import readline from 'readline'\n// import { GreaterNumber, Sleep } from '@empowerfresh/intelliwake'\n// import {Readable} from 'node:stream'\n\n/**\n * Asynchronously reads user input from the command line.\n *\n * @param {string} question - The prompt displayed to the user.\n * @param {string[]} validAnswers - An optional array of valid answers.\n * @returns {Promise<string>} A promise that resolves with the user's input as a string.\n */\nexport const KeyboardLine = async (question: string, validAnswers?: string[]): Promise<string> => {\n\tconst rl = readline.createInterface({\n\t\tinput: process.stdin,\n\t\toutput: process.stdout\n\t})\n\n\treturn new Promise(resolve =>\n\t\trl.question(`${question} `, answer => {\n\t\t\tif (!validAnswers || validAnswers.includes(answer)) {\n\t\t\t\tresolve(answer)\n\n\t\t\t\trl.close()\n\t\t\t}\n\t\t})\n\t)\n}\n\n/**\n * Asynchronous function that captures a single keyboard input and resolves with a valid key.\n *\n * @param {string} [question] - The optional question to display before capturing input.\n * @param {string[] | function} [validKeys] - The optional valid keys that can be pressed. Either an array of strings or a function that takes a key and returns a boolean.\n * @returns {Promise<string>} - A promise that resolves with the valid key that was pressed.\n */\nexport const KeyboardKey = async (question?: string, validKeys?: string[] | ((key: string) => boolean)): Promise<string> => {\n\treturn new Promise(resolve => {\n\t\tif (!!question) console.log(question)\n\n\t\tprocess.stdin.setRawMode(true)\n\t\tprocess.stdin.resume()\n\t\tprocess.stdin.setEncoding('utf8')\n\n\t\tconst getData = (key: any) => {\n\t\t\tif (key === '\\u0003') process.exit()\n\n\t\t\tif (!validKeys || (Array.isArray(validKeys) ? validKeys.includes(key) : validKeys(key))) {\n\t\t\t\tprocess.stdin.setRawMode(false)\n\t\t\t\tprocess.stdin.pause()\n\t\t\t\tprocess.stdin.removeListener('data', getData)\n\t\t\t\tresolve(key)\n\t\t\t}\n\t\t}\n\n\t\tprocess.stdin.on('data', getData)\n\t})\n}\n\n// /**\n//  * @typedef {Object} TParallelProcessOptions\n//  * @template T\n//  * @property {number | null} [upperBound] - The upper bound of the parallel processing limit. Default value is null.\n//  * @property {number | null} [lowerBound] - The lower bound of the parallel processing limit. Default value is null.\n//  * @property {(chunk: T, err: any) => Promise<void>} [onError] - A callback function to handle errors that occur during processing. It takes two parameters: the chunk being processed and the error object. It returns a Promise<void>.\n//  * @property {boolean} [throwOnError] - A flag indicating whether an error should be thrown when an error occurs during processing. Default value is false.\n//  */\n// export type TParallelProcessOptions<T = any> = {\n// \tupperBound?: number | null\n// \tlowerBound?: number | null\n// \tonError?: (chunk: T, err: any) => Promise<void>\n// \tthrowOnError?: boolean\n// }\n//\n// /**\n//  * Executes a given action in parallel for each chunk of data from a readable stream.\n//  * @param {stream.Readable} stream - The readable stream from which to read data.\n//  * @param {Function} action - The action to be executed for each chunk of data. It should accept a single parameter, the chunk of data, and return a Promise that resolves when the action is complete.\n//  * @param {Object} options - Optional configuration options.\n//  * @param {number} options.upperBound - The maximum number of active processes. Defaults to 1000.\n//  * @param {number} options.lowerBound - The minimum number of active processes before resuming the stream. Defaults to half of the upper bound or 1, whichever is greater.\n//  * @param {Function} options.onError - A callback function to handle errors that occur during the action execution. It should accept two parameters: the chunk of data and the error object.\n//  * @param {boolean} options.throwOnError - If true, the ReadableParallelProcess function will reject the promise if an error occurs during the action execution. Defaults to false.\n//  * @returns {Promise<void>} - A promise that resolves when all chunks have been processed.\n//  */\n// export async function ReadableParallelProcess<T = any>(\n// \tstream: Readable,\n// \taction: (chunk: T) => Promise<void>,\n// \toptions?: TParallelProcessOptions<T>\n// ) {\n// \treturn new Promise<void>((resolve, reject) => {\n// \t\tlet activeProcesses = 0\n// \t\tconst upperBound = options?.upperBound ?? 1000\n// \t\tconst lowerBound = GreaterNumber(options?.lowerBound ?? upperBound * 0.5, 1)\n//\n// \t\tstream.on('data', async (chunk: any) => {\n// \t\t\tactiveProcesses++\n//\n// \t\t\tif (activeProcesses >= upperBound) {\n// \t\t\t\tstream.pause()\n// \t\t\t}\n//\n// \t\t\ttry {\n// \t\t\t\tawait action(chunk)\n// \t\t\t} catch (err) {\n// \t\t\t\tif (options?.onError) {\n// \t\t\t\t\toptions.onError(chunk, err)\n// \t\t\t\t}\n// \t\t\t\tif (options?.throwOnError) {\n// \t\t\t\t\treject({...err, chunk})\n// \t\t\t\t\tstream.destroy()\n// \t\t\t\t} else {\n// \t\t\t\t\tconsole.info('Stream Error', chunk, err)\n// \t\t\t\t}\n// \t\t\t}\n//\n// \t\t\tactiveProcesses--\n//\n// \t\t\tif (!stream.readableFlowing && activeProcesses <= lowerBound) {\n// \t\t\t\tstream.resume()\n// \t\t\t}\n// \t\t})\n//\n// \t\tstream.on('end', async () => {\n// \t\t\twhile (activeProcesses > 0) {\n// \t\t\t\tawait Sleep()\n// \t\t\t}\n// \t\t\tresolve()\n// \t\t})\n// \t})\n// }\n//\n// /**\n//  * Processes an array of elements in parallel using a provided action.\n//  *\n//  * @param {Array} array - The array of elements to process.\n//  * @param {Function} action - The action to perform on each element. This action should take a single parameter, representing an element from the array, and return a Promise that resolves once the action is completed.\n//  * @param {Object} options - Optional configuration options.\n//  * @param {number} options.upperBound - The maximum number of active processes. Defaults to 1000.\n//  * @param {number} options.lowerBound - The minimum number of active processes before resuming the stream. Defaults to half of the upper bound or 1, whichever is greater.\n//  * @param {Function} options.onError - A callback function to handle errors that occur during the action execution. It should accept two parameters: the chunk of data and the error object.\n//  * @param {boolean} options.throwOnError - If true, the ReadableParallelProcess function will reject the promise if an error occurs during the action execution. Defaults to false.\n//  * @returns {Promise<void>} - A Promise that resolves once all the elements in the array have been processed.\n//  */\n// export async function ArrayParallelProcess<T = any>(\n// \tarray: T[],\n// \taction: (chunk: T) => Promise<void>,\n// \toptions?: TParallelProcessOptions<T>\n// ): Promise<void> {\n// \treturn ReadableParallelProcess(Readable.from(array), action, options)\n// }\n","var Fn = Object.defineProperty, Pn = Object.defineProperties;\nvar Bn = Object.getOwnPropertyDescriptors;\nvar rn = Object.getOwnPropertySymbols;\nvar xn = Object.prototype.hasOwnProperty, Rn = Object.prototype.propertyIsEnumerable;\nvar ne = Math.pow, We = (n, e, a) => e in n ? Fn(n, e, { enumerable: !0, configurable: !0, writable: !0, value: a }) : n[e] = a, D = (n, e) => {\n  for (var a in e || (e = {}))\n    xn.call(e, a) && We(n, a, e[a]);\n  if (rn)\n    for (var a of rn(e))\n      Rn.call(e, a) && We(n, a, e[a]);\n  return n;\n}, V = (n, e) => Pn(n, Bn(e));\nvar _e = (n, e, a) => (We(n, typeof e != \"symbol\" ? e + \"\" : e, a), a);\nvar ae = (n, e, a) => new Promise((r, t) => {\n  var i = (o) => {\n    try {\n      l(a.next(o));\n    } catch (s) {\n      t(s);\n    }\n  }, u = (o) => {\n    try {\n      l(a.throw(o));\n    } catch (s) {\n      t(s);\n    }\n  }, l = (o) => o.done ? r(o.value) : Promise.resolve(o.value).then(i, u);\n  l((a = a.apply(n, e)).next());\n});\nfunction Xa(n, e, a = 2) {\n  if (!(+e > 0))\n    return [];\n  const r = +n < 1 ? 1 : +n > +e ? +e : +n, t = +n < +a || +n > +e - +a ? +a : Math.ceil(+a / 2);\n  let i = +r - +t, u = +r + +t, l = [], o = [], s;\n  for (let m = 1; m <= +e; m++)\n    (m === 1 || m === +e || m >= i && m <= u) && l.push(m);\n  for (let m of l)\n    s && (m - s === 2 ? o.push(s + 1) : m - s !== 1 && o.push(null)), o.push(m), s = m;\n  return o;\n}\nconst Yn = {\n  primaryAscending: !0,\n  primaryEmptyToBottom: null,\n  secondarySort: null,\n  secondaryAscending: !0,\n  secondaryEmptyToBottom: null\n}, ja = (n, e) => e === null || n === e, er = (n) => {\n  switch (n) {\n    case !0:\n      return \"true\";\n    case !1:\n      return \"false\";\n    default:\n      return \"null\";\n  }\n}, nr = (n) => {\n  switch (n) {\n    case \"true\":\n      return !0;\n    case \"false\":\n      return !1;\n    default:\n      return null;\n  }\n}, ar = {\n  page: 1,\n  countPerPage: 50,\n  search: \"\",\n  sortColumns: V(D({}, Yn), { primarySort: \"\" }),\n  active: !0,\n  filterValues: {}\n}, rr = (n, e, a = !0, r = null) => e.primarySort === n ? V(D({}, e), {\n  primaryAscending: !e.primaryAscending,\n  primaryEmptyToBottom: r\n}) : {\n  primarySort: n,\n  primaryAscending: a,\n  primaryEmptyToBottom: r,\n  secondarySort: e.primarySort,\n  secondaryAscending: e.primaryAscending,\n  secondaryEmptyToBottom: e.primaryEmptyToBottom\n}, tn = (n, e) => n.sort(\n  (a, r) => {\n    var t, i, u, l, o;\n    return e.primarySort ? (o = un(\n      (t = a[e.primarySort]) != null ? t : null,\n      (i = r[e.primarySort]) != null ? i : null,\n      e.primaryAscending,\n      e.primaryEmptyToBottom\n    )) != null ? o : e.secondarySort ? un(\n      (u = a[e.secondarySort]) != null ? u : null,\n      (l = r[e.secondarySort]) != null ? l : null,\n      e.secondaryAscending,\n      e.secondaryEmptyToBottom\n    ) : 0 : 0;\n  }\n), re = (n) => n == null || n === \"\", F = (n) => n == null, Hn = (n, e, a, r = \"Top\") => {\n  //!!emptyTo\n  return (n != null ? n : null) === (e != null ? e : null) ? null : e ? n ? a.indexOf(n) - a.indexOf(e) : r === \"Top\" ? 1 : -1 : r === \"Top\" ? -1 : 1;\n}, tr = (n, e, a, r = \"Top\") => {\n  var t;\n  return (t = Hn(n, e, a, r)) != null ? t : 0;\n}, Wn = (n, e, a = null) => {\n  //!!emptyTo\n  if (n === e)\n    return null;\n  if (a)\n    if (a.endsWith(\"0\")) {\n      if (!n && e)\n        return typeof e == \"boolean\" ? a === \"Top0\" ? 1 : -1 : a === \"Top0\" ? -1 : 1;\n      if (!e && n)\n        return typeof n == \"boolean\" ? a === \"Top0\" ? -1 : 1 : a === \"Top0\" ? 1 : -1;\n    } else {\n      if (re(n) && !re(e))\n        return typeof e == \"boolean\" ? a === \"Top\" ? 1 : -1 : a === \"Top\" ? -1 : 1;\n      if (re(e) && !re(n))\n        return typeof n == \"boolean\" ? a === \"Top\" ? -1 : 1 : a === \"Top\" ? 1 : -1;\n    }\n  if (typeof n == \"boolean\" && typeof e == \"boolean\")\n    return (n ? 1 : 0) - (e ? 1 : 0);\n  const r = f(n, void 0, !0), t = f(e, void 0, !0);\n  return !isNaN(r) && !isNaN(t) ? r - t : (n != null ? n : \"\").toString().localeCompare((e != null ? e : \"\").toString(), void 0, { sensitivity: \"base\" });\n}, le = (n, e, a = null) => {\n  var r;\n  return (r = Wn(n, e, a)) != null ? r : 0;\n};\nfunction ir(n) {\n  if (Array.isArray(n.at(0))) {\n    for (const e of n) {\n      const a = le(e[0], e[1], e[2]);\n      if (a)\n        return a;\n    }\n    return 0;\n  } else\n    return le(n[0], n[1], n[2]);\n}\nconst zn = (n, e, a = \".\", r = null) => {\n  const t = (n != null ? n : \"\").toString().split(a), i = (e != null ? e : \"\").toString().split(a), u = an(t.length, i.length);\n  for (let l = 0; l < u; l++) {\n    const o = le(t[l], i[l], r);\n    if (o !== 0)\n      return o;\n  }\n  return null;\n}, ur = (n, e, a = \".\", r = null) => {\n  var t;\n  return (t = zn(n, e, a, r)) != null ? t : 0;\n}, or = (n, e = 10) => {\n  let a = 0;\n  return n.sort((r, t) => le(r.sort_order, t.sort_order)).map(\n    (r) => V(D({}, r), {\n      sort_order: a += e\n    }),\n    []\n  );\n}, Gn = (n, e, a, r = \"Top\") => n == e ? null : a.indexOf(n) < 0 ? a.indexOf(e) < 0 ? le(n, e) : r === \"Top\" ? -1 : 1 : a.indexOf(e) < 0 ? r === \"Top\" ? 1 : -1 : re(n) ? re(e) ? 0 : r === \"Top\" ? -1 : 1 : re(e) ? r === \"Top\" ? 1 : -1 : n === e ? 0 : a.indexOf(n) - a.indexOf(e), lr = (n, e, a, r = \"Top\") => {\n  var t;\n  return (t = Gn(n, e, a, r)) != null ? t : 0;\n}, un = (n, e, a, r) => le(\n  a ? n : e,\n  a ? e : n,\n  r ? a ? \"Bottom0\" : \"Top0\" : void 0\n), Ye = (n, e = !0, a = 8) => (n != null ? n : \"\").trim().split(/(\\s+)/).map((r) => e ? r.trim().toLowerCase() : r.trim()).filter((r) => !!r).filter((r, t) => !a || t < a), sr = (n, e = \" \", a = !0) => {\n  if (!n)\n    return \"\";\n  let r;\n  return Array.isArray(n) ? r = n.map((t) => (t != null ? t : \"\").trim()).filter((t) => !!t).join(e).trim() : r = n.trim(), a ? r.toLowerCase() : r;\n}, Kn = (n, e) => e.length === 0 ? !0 : n ? e.every((a) => n.includes(a)) : !1, cr = (n, e) => {\n  if (!e)\n    return !0;\n  if (!n)\n    return !1;\n  const a = Ye(e);\n  return Kn(n, a);\n}, se = (n, e, a) => {\n  var i;\n  if (e.length === 0)\n    return !0;\n  if (!n || typeof n == \"object\" && ((i = n.type) != null && i.toString().includes(\"react.\")))\n    return !1;\n  const r = (u) => Object.keys(n).some((l) => {\n    const o = n[l], s = typeof o;\n    if (!Array.isArray(o) && [\"number\", \"bigint\", \"string\"].includes(s))\n      return o.toString().toLowerCase().includes(u.toLowerCase());\n    if (Array.isArray(o)) {\n      for (const m of o)\n        if (se(m, [u], a))\n          return !0;\n    }\n    return s === \"object\" ? se(o, [u], a) : !1;\n  });\n  let t = e;\n  if ((a == null ? void 0 : a.matchUntilTerm) !== void 0)\n    if ((a == null ? void 0 : a.matchFromTerm) !== void 0) {\n      if (a.matchFromTerm < a.matchUntilTerm)\n        throw new Error(`Could not match terms from ${a.matchFromTerm} to ${a.matchUntilTerm}`);\n      if (a.matchFromTerm + 1 > e.length)\n        return !1;\n      t = t.slice(a.matchFromTerm, a.matchUntilTerm + 1);\n    } else\n      t = t.slice(0, a.matchUntilTerm + 1);\n  else if ((a == null ? void 0 : a.matchFromTerm) !== void 0) {\n    if (a.matchFromTerm + 1 > e.length)\n      return !1;\n    t = t.slice(a.matchFromTerm);\n  }\n  return a != null && a.matchSomeTerm ? t.some(r) : t.every(r);\n}, mr = (n, e, a) => {\n  if (!e)\n    return !0;\n  if (!n)\n    return !1;\n  const r = Ye(e);\n  return se(n, r, a);\n}, on = (n, e, a) => {\n  const r = Ye(e);\n  let t = f(a == null ? void 0 : a.limit);\n  if (r.length === 0 && !t)\n    return n;\n  let i = a != null && a.page ? f(a.page - 1) * (t != null ? t : 0) : 0;\n  return t ? (n != null ? n : []).reduce((u, l, o) => o < i || u.length >= t ? u : !r.length || se(l, r, a) ? [...u, l] : u, []) : (n != null ? n : []).filter((u) => se(u, r, a));\n}, fr = (n, e, a) => {\n  const r = Ye(e);\n  return r.length === 0 ? !0 : se(n, r, a);\n}, gr = (n, e, a, r) => r != null && r.limit ? on(tn(n, a), e, r) : tn(on(n, e, r), a), j = (n) => {\n  if (!n)\n    return [];\n  const e = H(n);\n  let a = [];\n  const r = [\" \", \"_\", \",\", \"-\", \"/\", \"\\\\\", \"'\", '\"', \"=\", \"+\", \"~\", \".\", \",\", \"(\", \")\", \"<\", \">\", \"{\", \"}\"];\n  e:\n    for (const t of e) {\n      for (const i of r)\n        if (t.includes(i)) {\n          a = j([...a, ...t.split(i).filter((u) => !!u)]);\n          continue e;\n        }\n      a = [\n        ...a,\n        ...t.replace(/([a-zA-Z])([0-9])/g, \"$1 $2\").replace(/([0-9])([a-zA-Z])/g, \"$1 $2\").replace(/([a-z0-9])([A-Z])/g, \"$1 $2\").replace(/([A-Z]+)([A-Z][a-z0-9])/g, \"$1 $2\").replace(/([a-zA-Z0-9])([:;@#])/g, \"$1 $2\").replace(/([:;@#])([a-zA-Z0-9])/g, \"$1 $2\").split(\" \")\n      ].filter((i) => !!i);\n    }\n  return a.filter((t) => !!t);\n}, Vn = (n) => {\n  if (!n)\n    return [];\n  const e = H(n);\n  let a = [];\n  const r = [\" \", \"_\", \",\", \"-\", \"/\", \"\\\\\", \"'\", '\"', \"=\", \"+\", \"~\", \".\", \",\", \"(\", \")\", \"<\", \">\", \"{\", \"}\"];\n  e:\n    for (const t of e) {\n      for (const i of r)\n        if (t.includes(i)) {\n          a = Vn([...a, ...t.split(i).filter((u) => !!u)]);\n          continue e;\n        }\n      a = [...a, t].filter((i) => !!i);\n    }\n  return a.filter((t) => !!t);\n}, Zn = (n) => n ? n.substring(0, 1).toUpperCase() + n.substring(1).toLowerCase() : \"\", Qe = (n) => n ? n === n.toUpperCase() ? n : n.toLowerCase() === \"id\" ? \"ID\" : Zn(n) : \"\", hr = (n) => j(n).map((e) => e.toLowerCase()).join(\"_\"), dr = (n) => j(n).map((e) => e.toLowerCase()).join(\"-\"), Ar = (n) => j(n).map((e, a) => a ? e === e.toUpperCase() ? e : Qe(e) : e.toLowerCase()).join(\"\"), qn = (n) => j(n).map((e) => e === e.toUpperCase() ? e : Qe(e)).join(\" \"), Sr = (n) => j(n).map((e) => e === e.toUpperCase() ? e : Qe(e)).join(\"\"), yr = (n) => {\n  if (!n)\n    return \"\";\n  if (typeof n == \"string\") {\n    const e = n.split(\",\");\n    if (e.length === 2)\n      return j([e[1], e[0]]).map((a) => a.substring(0, 1).toUpperCase()).join(\"\");\n  }\n  return j(n).map((e) => e.substring(0, 1).toUpperCase()).join(\"\");\n}, vr = (n) => n ? /<[^>]*>/.test(n) : !1, Dr = function(n, e) {\n  if (!n)\n    return \"\";\n  if (n.includes(\"<img \"))\n    return n;\n  let a = n.replace(/(?:\\r\\n|\\r|\\n)/g, \"<br />\");\n  const r = e ? `<a href=\"$1\" target=\"_blank\" class=\"${e}\">$1</a>` : \"<a href='$1' target='_blank'>$1</a>\";\n  return a.replace(/(https?:\\/\\/([-\\w\\.]+)+(:\\d+)?(\\/([\\w\\/_\\.]*(\\?\\S+)?)?)?)/gi, r);\n}, vn = function(n) {\n  return n ? n.toString().replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, \"\") : \"\";\n}, Tr = function(n) {\n  return n ? vn(n).replace(/(?:\\r\\n|\\r|\\n)/g, \"<br />\") : \"\";\n}, Mr = (n) => vn(n).replace(/<[^>]*>/g, \"\"), Jn = (n, e, a) => {\n  let r = (n != null ? n : \"\").toString();\n  for (; r.length < e; )\n    r = a + r;\n  return r;\n}, Qn = (n, e, a) => {\n  let r = (n != null ? n : \"\").toString();\n  for (; r.length < e; )\n    r = r + a;\n  return r;\n}, Cr = (n, e = 2) => \"$\" + f(n).toLocaleString(void 0, {\n  maximumFractionDigits: e,\n  minimumFractionDigits: e\n}), br = (n, e = 9) => \"$\" + f(n).toLocaleString(void 0, {\n  maximumFractionDigits: e\n}), wr = (n, e = 0) => (f(n) * 100).toLocaleString(void 0, {\n  maximumFractionDigits: e,\n  minimumFractionDigits: e\n}) + \"%\", kr = (n, e = 9) => (f(n) * 100).toLocaleString(void 0, {\n  maximumFractionDigits: e\n}) + \"%\", Or = (n, e = 2) => F(n) || f(n) === 0 ? \"\" : \"$\" + f(n).toLocaleString(void 0, {\n  maximumFractionDigits: e,\n  minimumFractionDigits: e\n}), Nr = (n, e = 2) => F(n) || f(n) === 0 ? \"-\" : \"$\" + f(n).toLocaleString(void 0, {\n  maximumFractionDigits: e,\n  minimumFractionDigits: e\n}), Er = (n, e = 2) => F(n) || f(n) === 0 ? \"\" : (f(n) * 100).toLocaleString(void 0, {\n  maximumFractionDigits: e,\n  minimumFractionDigits: e\n}) + \"%\", Ir = (n, e = 2) => F(n) || f(n) === 0 ? \"-\" : (f(n) * 100).toLocaleString(void 0, {\n  maximumFractionDigits: e,\n  minimumFractionDigits: e\n}) + \"%\", v = function(n, e = 0, a = null) {\n  return f(n).toLocaleString(void 0, {\n    maximumFractionDigits: e,\n    minimumFractionDigits: a != null ? a : e\n  });\n}, pr = function(n, e = 9) {\n  return f(n, e).toLocaleString(void 0, {\n    maximumFractionDigits: e\n  });\n}, $r = function(n, e = 0) {\n  return F(n) || f(n) === 0 ? \"\" : f(n).toLocaleString(void 0, {\n    maximumFractionDigits: e,\n    minimumFractionDigits: e\n  });\n}, Ur = function(n, e = 9) {\n  return F(n) || f(n, e) === 0 ? \"\" : f(n, e).toLocaleString(void 0, {\n    maximumFractionDigits: e\n  });\n}, _r = function(n, e = 0) {\n  return F(n) || f(n) === 0 ? \"-\" : f(n).toLocaleString(void 0, {\n    maximumFractionDigits: e,\n    minimumFractionDigits: e\n  });\n}, Lr = function(n, e = 9) {\n  return F(n) || f(n, e) === 0 ? \"-\" : f(n, e).toLocaleString(void 0, {\n    maximumFractionDigits: e\n  });\n}, Z = (n) => {\n  let e = v(n);\n  if (!e)\n    return null;\n  switch (e.substring(e.length - 2)) {\n    case \"11\":\n    case \"12\":\n    case \"13\":\n      e += \"th\";\n      break;\n    default:\n      switch (e.substring(e.length - 1)) {\n        case \"1\":\n          e += \"st\";\n          break;\n        case \"2\":\n          e += \"nd\";\n          break;\n        case \"3\":\n          e += \"rd\";\n          break;\n        default:\n          e += \"th\";\n          break;\n      }\n  }\n  return e;\n}, Fr = (n) => n ? typeof n == \"string\" ? [n] : n : [], Pr = (n) => {\n  let e = (n != null ? n : \"\").replace(/[^\\d-]/g, \"\");\n  return e = e.replace(/^(\\d{3})-?(\\d{1,2})/, \"$1-$2\"), e = e.replace(/^(\\d{3})-?(\\d{2})-?(\\d{1,4})/, \"$1-$2-$3\"), e = e.split(\"\").filter((a, r) => a !== \"-\" || r === 3 || r === 6).join(\"\"), e.substring(0, 11);\n}, He = (n, e = !0) => {\n  var i, u, l;\n  if (!n)\n    return null;\n  let a = T([\"(\", \")\", \"-\", \" \", \"+\"], \"\", n), r = \"\";\n  for (; (a.startsWith(\"0\") || a.startsWith(\"1\")) && a.length !== 10; )\n    r += a[0], a = a.substring(1);\n  let t = {\n    countryCode: r,\n    areaCode: a.substring(0, 3),\n    exchangeNumber: a.substring(3, 6),\n    subscriberNumber: a.substring(6, 10),\n    extension: \"\"\n  };\n  if (!e && (((i = t.areaCode) == null ? void 0 : i.length) != 3 || ((u = t.exchangeNumber) == null ? void 0 : u.length) != 3 || ((l = t.subscriberNumber) == null ? void 0 : l.length) != 4))\n    return null;\n  if (t.areaCode && t.exchangeNumber && t.subscriberNumber) {\n    let o = n != null ? n : \"\", s = o.indexOf(t.areaCode);\n    s >= 0 && (s = o.indexOf(\n      t.exchangeNumber,\n      s + t.areaCode.length\n    ), s >= 0 && (s = o.indexOf(\n      t.subscriberNumber,\n      s + t.exchangeNumber.length\n    ), s >= 0 && (t.extension = o.substring(s + t.subscriberNumber.length).trim())));\n  }\n  return t;\n}, Br = (n, e = !0) => {\n  const a = He(n, e);\n  if (!a)\n    return null;\n  let r = \"\";\n  return a.areaCode && (r += `(${a.areaCode})`), a.exchangeNumber && (r += ` ${a.exchangeNumber}`), a.subscriberNumber && (r += `-${a.subscriberNumber}`), a.extension && (r += ` ${a.extension}`), r;\n}, xr = (n, e = !0) => {\n  const a = He(n, e);\n  return !a || !a.areaCode || !a.exchangeNumber || !a.subscriberNumber ? null : `+1${a.areaCode}${a.exchangeNumber}${a.subscriberNumber}`;\n}, Rr = (n, e = !1) => {\n  const r = (e ? (\"\" + n).replace(/\\D/g, \"\") : \"\" + n).match(/^(1|)?(\\d{3})(\\d{3})(\\d{4})$/);\n  return r ? [r[1] ? \"+1 \" : \"\", \"(\", r[2], \") \", r[3], \"-\", r[4]].join(\"\") : n;\n}, Yr = (n, e = !0) => {\n  const a = He(n, e);\n  return !a || !a.areaCode || !a.exchangeNumber || !a.subscriberNumber ? null : `${a.areaCode}.${a.exchangeNumber}.${a.subscriberNumber}`;\n}, Hr = (n, e = !0) => {\n  const a = He(n, e);\n  return !a || !a.areaCode || !a.exchangeNumber || !a.subscriberNumber ? null : `${a.areaCode}-${a.exchangeNumber}-${a.subscriberNumber}`;\n}, Dn = (n) => {\n  let e = (\"\" + (n != null ? n : \"\")).toString().replace(/\\D/g, \"\");\n  return e.length === 9 && (e = e.replace(/(\\d{5})/, \"$1-\")), e;\n}, Wr = (n) => {\n  if (!n)\n    return null;\n  let e = (\"\" + (n != null ? n : \"\")).toString().replace(/\\D/g, \"\");\n  return e.length === 9 && (e = e.replace(/(\\d{2})/, \"$1-\")), e;\n}, zr = (n) => n ? n.startsWith(\"http\") ? n : \"http://\" + n : \"\", Xn = (n, e, a, r) => {\n  let t = \"\";\n  return e ? (t += e, n ? (t += \", \" + n, a && (t += \" \" + a)) : a && (t += \", \" + a)) : n ? (t += n, a && (t += \" \" + a)) : a && (t += a), r && (t && (t += \", \"), t += r), t;\n}, Gr = (n, e) => {\n  if (!n)\n    return \"\";\n  const a = e ? `_${e}` : \"\";\n  return Xn(\n    n[a + \"first_name\"],\n    n[a + \"last_name\"],\n    n[a + \"middle_name\"],\n    n[a + \"suffix_name\"]\n  );\n}, jn = (n) => {\n  if (!n)\n    return n;\n  let e = \"\";\n  const a = n.toLowerCase().split(\" \");\n  for (let r = 0; r < a.length; r++)\n    e += a[r].substring(0, 1).toUpperCase() + a[r].substring(1, a[r].length) + \" \";\n  return e.trim();\n}, ea = (n, e = \"ABCDEFGHJKLMNPQRTUVWXYZ2346789\") => {\n  let a = \"\";\n  const r = e.length;\n  for (let t = 0; t < n; t++)\n    a += e.charAt(Math.floor(Math.random() * r));\n  return a;\n}, Kr = (n) => ea(n, \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ12346789\");\nfunction na(n) {\n  return \"aeiou\".indexOf(n.toLowerCase()) !== -1;\n}\nfunction k(n, e, a = !1, r = 0, t = null) {\n  if (!n)\n    return \"\";\n  let i = n, u = (n != null ? n : \"\").toLowerCase();\n  const l = v(e != null ? e : 0, r, t);\n  let o = \"\";\n  return f(l) !== 1 && (u.endsWith(\"y\") && !na(u.charAt(u.length - 2)) ? (i = i.substring(0, i.length - 1), o = \"ies\") : o = n && (u.endsWith(\"s\") || u.endsWith(\"z\") || u.endsWith(\"ch\") || u.endsWith(\"sh\") || u.endsWith(\"x\")) ? \"es\" : \"s\"), `${a ? l : \"\"} ${i}${o}`.trim();\n}\nfunction aa(n, e, a = !1, r = 0, t = null) {\n  return e ? k(n, e, a, r, t) : null;\n}\nfunction Vr(n, e, a = !1, r = 0, t = null) {\n  var i;\n  return (i = aa(n, e, a, r, t)) != null ? i : \"\";\n}\nconst Zr = (n, e = 0, a = \"round\") => {\n  let r = E(n);\n  if (r === null)\n    return null;\n  const t = (u, l) => {\n    let o = v(Ze(u, e, a), e);\n    if (e) {\n      for (; o.endsWith(\"0\"); )\n        o = o.substring(0, o.length - 1);\n      for (; o.endsWith(\".\"); )\n        o = o.substring(0, o.length - 1);\n    }\n    return o + l;\n  };\n  if (r < 999)\n    return t(r, \"\");\n  if (r /= 1e3, r < 999)\n    return t(r, \"k\");\n  if (r /= 1e3, r < 999)\n    return t(r, \"M\");\n  if (r /= 1e3, r < 999)\n    return t(r, \"B\");\n  if (r /= 1e3, r < 999)\n    return t(r, \"T\");\n  let i = \"\";\n  do\n    i += \"Q\", r /= 1e3;\n  while (r > 999);\n  return t(r, i);\n}, qr = (n, e = 15) => !n || n.length <= e ? n : `${n.substring(0, e)}...`, Jr = (n, e) => {\n  var r;\n  if (!n)\n    return !1;\n  const a = T(\"*\", \"([\\\\s\\\\S]*?)\", T(\"\\\\\", \"\\\\/\", e));\n  return a ? !!((r = n.match(new RegExp(a))) != null && r.length) : !1;\n}, Qr = (...n) => {\n  let e = n.map((a, r) => r === 0 ? (a != null ? a : \"\").trim().replace(/[\\/]*$/g, \"\") : (a != null ? a : \"\").trim().replace(/(^[\\/]*|[\\/]*$)/g, \"\")).filter((a) => a.length).join(\"/\");\n  return n[0] === \"/\" && !e.startsWith(\"/\") ? \"/\" + e : e;\n}, Xr = (n) => n ? !!n.toString().match(/\\d/) : !1, jr = (n) => n ? !!n.toString().match(/[a-zA-Z]/) : !1;\nvar ra = /* @__PURE__ */ ((n) => (n.Same = \"Same\", n.Inserted = \"Inserted\", n.Deleted = \"Deleted\", n))(ra || {});\nfunction et(n, e) {\n  let a = [], r = (n != null ? n : \"\").split(/[\\r\\n]+/g), t = (e != null ? e : \"\").split(/[\\r\\n]+/g);\n  for (; r.length || t.length; ) {\n    if (!t.length) {\n      a = [\n        ...a,\n        ...r.map((u) => ({ result: \"Deleted\", value: u }))\n      ], r = [];\n      continue;\n    }\n    if (!r.length) {\n      a = [\n        ...a,\n        ...t.map((u) => ({ result: \"Inserted\", value: u }))\n      ], t = [];\n      continue;\n    }\n    if (r[0] === t[0]) {\n      a = [\n        ...a,\n        {\n          result: \"Same\",\n          value: r[0]\n        }\n      ], r = r.slice(1), t = t.slice(1);\n      continue;\n    }\n    let i = !1;\n    for (let u = 0; u < t.length; u++) {\n      const l = r.findIndex((o) => t[u] === o);\n      if (l > 0) {\n        a = [\n          ...a,\n          ...r.filter((o, s) => s < l).map((o) => ({\n            result: \"Deleted\",\n            value: o\n          }))\n        ], r = r.slice(l), i = !0;\n        break;\n      }\n    }\n    if (!i) {\n      {\n        const u = t.findIndex((l) => r[0] === l);\n        u >= 0 && (a = [\n          ...a,\n          ...t.filter((l, o) => o < u).map((l) => ({\n            result: \"Inserted\",\n            value: l\n          }))\n        ], t = t.slice(u), i = !0);\n      }\n      if (!i)\n        throw console.log(\"-------------- Could not compare\"), console.log(a), console.log(r), console.log(t), console.log(\"--------------\"), new Error(\"Could not finish comparing\");\n    }\n  }\n  return a;\n}\nfunction ta(n, e, a = \"\") {\n  return e.map((r) => {\n    var i, u, l;\n    let t = (r.transform ? r.transform(n[r.property], n) : (i = n[r.property]) != null ? i : \"\").toString();\n    return r.rightJustify ? t = Jn(t.substring(t.length - r.length), r.length, (u = r.padCharacter) != null ? u : \" \") : t = Qn(t.substring(0, r.length), r.length, (l = r.padCharacter) != null ? l : \" \"), t;\n  }).join(a);\n}\nfunction nt(n, e, a = \"\", r = \"\\r\") {\n  return n.map((t) => ta(t, e, a)).join(r);\n}\nconst Be = \"YYYY-MM-DD\", ia = \"HH:mm:ss\", at = \"HH:mm\", ua = Be + \" \" + ia, Xe = \"MMM D, YYYY\", Tn = `dd, ${Xe}`, te = \"h:mm a\", oa = `${Xe}, ${te}`, la = `${Tn}, ${te}`, je = \"MMMM D, YYYY\", Mn = `dddd, ${je}`, sa = `${je}, ${te}`, ca = `${Mn}, ${te}`, ma = (n) => {\n  var e;\n  return n ? (e = Y(\"now\", n)) != null ? e : (/* @__PURE__ */ new Date()).toISOString() : (/* @__PURE__ */ new Date()).toISOString();\n}, fa = () => Intl.DateTimeFormat().resolvedOptions().timeZone, Ie = (n, e) => {\n  var g;\n  if (!n)\n    return ((g = A(e != null ? e : \"now\", { ignoreIANA: !0 })) != null ? g : /* @__PURE__ */ new Date()).getTimezoneOffset();\n  const a = e ? R(e, void 0, !0) : null;\n  let r = a ? new Date(a) : /* @__PURE__ */ new Date();\n  function t(h) {\n    const S = h.replace(\":\", \" \").split(\" \");\n    return {\n      day: parseInt(S[0]),\n      hour: parseInt(S[1]),\n      minute: parseInt(S[2])\n    };\n  }\n  let i = r.toLocaleString([\"nl-NL\"], {\n    timeZone: n,\n    day: \"numeric\",\n    hour: \"numeric\",\n    minute: \"numeric\",\n    hour12: !1\n  });\n  const u = t(i), l = u.day * 1440 + u.hour * 60 + u.minute;\n  i = r.toLocaleString([\"nl-NL\"], { day: \"numeric\", hour: \"numeric\", minute: \"numeric\", hour12: !1 });\n  const o = t(i);\n  let s = o.day * 1440 + o.hour * 60 + o.minute;\n  return u.day > o.day && (s += u.day * 1440), (s - l + r.getTimezoneOffset()) % 1440;\n}, Cn = (n) => n.includes(\":\"), en = (n) => n.includes(\"-\") || /\\d{8}/.test(n), bn = (n) => n === \"now\" || n === \"today\" || n.includes(\"T\") || n.substring(15).includes(\"Z\") || n.includes(\"+\") || n.substring(15).includes(\"-\"), ga = (n) => !!(n != null && n.includes(\"/\")) && /^[a-zA-Z_\\/]*$/.test(n), rt = (n) => !!n && /([a-zA-Z_\\/]+)/.test(n), ln = (n) => !n || typeof n != \"string\" || !en(n) ? !1 : !!R(n), ha = (n) => {\n  let e = n.split(\" \");\n  if (e.length === 1)\n    return n;\n  let a = e[1].split(\":\");\n  return a.length === 1 ? n : (a.length === 2 && (a.push(\"00\"), e[1] = a.join(\":\")), e.join(\" \"));\n}, da = (n) => {\n  var r, t, i, u;\n  const e = ha(n);\n  let a = [\n    \"([0-9]{4})(-([0-9]{2})(-([0-9]{2})(T([0-9]{2}):([0-9]{2})(:([0-9]{2})(\\\\.([0-9]+))?)?(Z|(([-+])([0-9]{2}):([0-9]{2})))?)?)?)?\",\n    \"([0-9]{4})(-([0-9]{2})(-([0-9]{2})( ([0-9]{2}):([0-9]{2})(:([0-9]{2})(\\\\.([0-9]+))?)?(Z|(([-+])([0-9]{2}):([0-9]{2})))?)?)?)?\",\n    \"([0-9]{4})(-([0-9]{2})(-([0-9]{2})(T([0-9]{2}):([0-9]{2})(Z|(([-+])([0-9]{2}):([0-9]{2})))?)?)?)?\"\n  ].reduce((l, o) => {\n    const s = (e.length === 16 ? e + \":00\" : e).match(new RegExp(o));\n    return (s == null ? void 0 : s.at(4)) === void 0 ? l : l ? s && s[10] && !l[10] ? s : l : s;\n  }, null);\n  if (a) {\n    let l = new Date(f(a[1]), 0, 1);\n    a[1] && l.setUTCFullYear(f(a[1])), a[3] && l.setUTCMonth(f(a[3]) - 1), a[5] && l.setUTCDate(f(a[5])), l.setUTCHours(f((r = a[7]) != null ? r : 0)), l.setUTCMinutes(f((t = a[8]) != null ? t : 0)), l.setUTCSeconds(f((i = a[10]) != null ? i : 0)), l.setUTCMilliseconds(f(((u = a[12]) != null ? u : 0).toString().padEnd(3, \"0\").substring(0, 3)));\n    let o = 0;\n    if (a[14])\n      o = f(a[16]) + parseInt(a[17], 10), o *= a[15] === \"-\" ? 1 : -1;\n    else if (e.length > 12) {\n      const g = e.substring(e.length - 3);\n      (g.startsWith(\"-\") || g.endsWith(\"+\")) && (o -= f(g));\n    }\n    const s = l.valueOf() + o * 36e5;\n    let m = new Date(s);\n    return m ? m.valueOf() : null;\n  }\n  return null;\n}, R = (n, e, a) => {\n  var r;\n  if (!n && n !== 0 && n !== \"0\")\n    return null;\n  if (typeof n == \"number\")\n    return n;\n  if (typeof n == \"object\")\n    return n.valueOf();\n  if (n.toString().toLowerCase() === \"now\" || n.toString().toLowerCase() === \"today\")\n    return (/* @__PURE__ */ new Date()).valueOf();\n  try {\n    let t = da(n);\n    if ((t === null || isNaN(t)) && (t = Date.parse(n.toString()), !isNaN(t)))\n      return t;\n    if (isNaN(t))\n      return null;\n    if (!a && !bn(n)) {\n      let i = e;\n      if (!i) {\n        const u = n.split(\" \"), l = u[u.length - 1];\n        ga(l) && (i = l);\n      }\n      t += ((r = Ie(i, n)) != null ? r : 0) * 6e4;\n    }\n    return t;\n  } catch (t) {\n    return null;\n  }\n}, p = (n, e) => {\n  let a = R(n, e == null ? void 0 : e.timezoneSource, e == null ? void 0 : e.ignoreIANA);\n  return !a && a !== 0 || !e ? a : $(a, e);\n}, Y = (n, e) => {\n  const a = p(n, e);\n  return a ? new Date(a).toISOString() : null;\n}, A = (n, e) => {\n  const a = p(n, e);\n  return !a && a !== 0 ? null : new Date(a);\n}, tt = (n, e) => {\n  const a = Y(n, e);\n  if (!a)\n    return null;\n  let r = a, t = r.indexOf(\".\"), i = r.indexOf(\"Z\");\n  return t > 0 && i > t && (r = r.substring(0, t) + r.substring(i)), r = T(\"-\", \"\", r), r = T(\":\", \"\", r), r;\n}, ce = (n, e, a, r) => {\n  var I, N, O;\n  const t = typeof e == \"string\" && !bn(e), i = typeof e == \"string\" && !en(e) && Cn(e) ? `${b(\"now\")} ${e}` : e;\n  let u = A(R(i, t ? r : void 0));\n  if (a)\n    try {\n      if (!u || isNaN(u.valueOf()))\n        return null;\n      const d = i && i !== \"now\" && i !== \"today\" ? u : void 0, c = (I = Ie(r, d)) != null ? I : 0, C = (N = Ie(a, d)) != null ? N : 0, U = t ? r ? ((O = Ie(void 0, d)) != null ? O : 0) - c - (C - c) : C - c - (C - c) : c - C;\n      u = A(u, { minutes: U });\n    } catch (d) {\n      return console.log(\"Invalid Timezone\", d), null;\n    }\n  if (!u || isNaN(u.valueOf()))\n    return null;\n  const l = (d, c) => {\n    var C, U, W, ee, G, ge, he, de, Ae, Se, ye, ve, De, Te, Me, Ce, be, we, ke, Oe;\n    if (a === \"UTC\")\n      switch (d) {\n        case \"YYYY\":\n          return c.getUTCFullYear().toString().padStart(4, \"0\");\n        case \"YY\":\n          return c.getUTCFullYear().toString().substring(2).padStart(2, \"0\");\n        case \"Q\":\n          return Math.ceil((c.getUTCMonth() + 1) / 3).toString();\n        case \"Qo\":\n          return (C = Z(Math.ceil((c.getUTCMonth() + 1) / 3))) != null ? C : \"\";\n        case \"MMMM\":\n          return (U = Le[c.getUTCMonth()]) != null ? U : \"\";\n        case \"MMM\":\n          return ((W = Le[c.getUTCMonth()]) != null ? W : \"\").substring(0, 3);\n        case \"MM\":\n          return (c.getUTCMonth() + 1).toString().padStart(2, \"0\");\n        case \"Mo\":\n          return (ee = Z(c.getUTCMonth() + 1)) != null ? ee : \"\";\n        case \"M\":\n          return (c.getUTCMonth() + 1).toString();\n        case \"w\":\n          return f((G = Q(c)) == null ? void 0 : G.week).toString();\n        case \"DD\":\n          return c.getUTCDate().toString().padStart(2, \"0\");\n        case \"Do\":\n          return (ge = Z(c.getUTCDate())) != null ? ge : \"\";\n        case \"D\":\n          return c.getUTCDate().toString();\n        case \"d\":\n          return c.getUTCDay().toString();\n        case \"do\":\n          return (he = Z(c.getUTCDay())) != null ? he : \"\";\n        case \"dd\":\n          return ((de = ue[c.getUTCDay()]) != null ? de : \"\").substring(0, 2);\n        case \"ddd\":\n          return ((Ae = ue[c.getUTCDay()]) != null ? Ae : \"\").substring(0, 3);\n        case \"dddd\":\n          return (Se = ue[c.getUTCDay()]) != null ? Se : \"\";\n        case \"HH\":\n          return c.getUTCHours().toString().padStart(2, \"0\");\n        case \"H\":\n          return c.getUTCHours().toString();\n        case \"hh\":\n          return (c.getUTCHours() > 12 ? c.getUTCHours() - 12 : c.getUTCHours()).toString().padStart(2, \"0\");\n        case \"h\": {\n          const K = c.getUTCHours() > 12 ? c.getUTCHours() - 12 : c.getUTCHours();\n          return (K === 0 ? 12 : K).toString();\n        }\n        case \"mm\":\n          return c.getUTCMinutes().toString().padStart(2, \"0\");\n        case \"m\":\n          return c.getUTCMinutes().toString();\n        case \"ssss\":\n          return c.getUTCMilliseconds().toString().padStart(4, \"0\");\n        case \"sss\":\n          return c.getUTCMilliseconds().toString().padStart(3, \"0\");\n        case \"ss\":\n          return c.getUTCSeconds().toString().padStart(2, \"0\");\n        case \"s\":\n          return c.getUTCSeconds().toString();\n        case \"A\":\n          return c.getUTCHours() >= 12 ? \"PM\" : \"AM\";\n        case \"a\":\n          return c.getUTCHours() >= 12 ? \"pm\" : \"am\";\n        default:\n          return d;\n      }\n    else\n      switch (d) {\n        case \"YYYY\":\n          return c.getFullYear().toString().padStart(4, \"0\");\n        case \"YY\":\n          return c.getFullYear().toString().substring(2).padStart(2, \"0\");\n        case \"Q\":\n          return Math.ceil((c.getMonth() + 1) / 3).toString();\n        case \"Qo\":\n          return (ye = Z(Math.ceil((c.getMonth() + 1) / 3))) != null ? ye : \"\";\n        case \"MMMM\":\n          return (ve = Le[c.getMonth()]) != null ? ve : \"\";\n        case \"MMM\":\n          return ((De = Le[c.getMonth()]) != null ? De : \"\").substring(0, 3);\n        case \"MM\":\n          return (c.getMonth() + 1).toString().padStart(2, \"0\");\n        case \"Mo\":\n          return (Te = Z(c.getMonth() + 1)) != null ? Te : \"\";\n        case \"M\":\n          return (c.getMonth() + 1).toString();\n        case \"w\":\n          return f((Me = Q(c)) == null ? void 0 : Me.week).toString();\n        case \"DD\":\n          return c.getDate().toString().padStart(2, \"0\");\n        case \"Do\":\n          return (Ce = Z(c.getDate())) != null ? Ce : \"\";\n        case \"D\":\n          return c.getDate().toString();\n        case \"d\":\n          return c.getDay().toString();\n        case \"do\":\n          return (be = Z(c.getDay())) != null ? be : \"\";\n        case \"dd\":\n          return ((we = ue[c.getDay()]) != null ? we : \"\").substring(0, 2);\n        case \"ddd\":\n          return ((ke = ue[c.getDay()]) != null ? ke : \"\").substring(0, 3);\n        case \"dddd\":\n          return (Oe = ue[c.getDay()]) != null ? Oe : \"\";\n        case \"HH\":\n          return c.getHours().toString().padStart(2, \"0\");\n        case \"H\":\n          return c.getHours().toString();\n        case \"hh\":\n          return (c.getHours() > 12 ? c.getHours() - 12 : c.getHours()).toString().padStart(2, \"0\");\n        case \"h\": {\n          const K = c.getHours() > 12 ? c.getHours() - 12 : c.getHours();\n          return (K === 0 ? 12 : K).toString();\n        }\n        case \"mm\":\n          return c.getMinutes().toString().padStart(2, \"0\");\n        case \"m\":\n          return c.getMinutes().toString();\n        case \"ssss\":\n          return c.getMilliseconds().toString().padStart(4, \"0\");\n        case \"sss\":\n          return c.getMilliseconds().toString().padStart(3, \"0\");\n        case \"ss\":\n          return c.getSeconds().toString().padStart(2, \"0\");\n        case \"s\":\n          return c.getSeconds().toString();\n        case \"A\":\n          return c.getHours() >= 12 ? \"PM\" : \"AM\";\n        case \"a\":\n          return c.getHours() >= 12 ? \"pm\" : \"am\";\n        default:\n          return d;\n      }\n  };\n  let o;\n  switch (n) {\n    case \"Local\":\n      o = \"M/D/YYYY\";\n      break;\n    case \"LocalDoW\":\n      o = \"dd, M/D/YYYY\";\n      break;\n    case \"LocalDateTime\":\n      o = \"M/D/YYYY h:mm a\";\n      break;\n    case \"LocalDoWTime\":\n      o = \"dd, M/D/YYYY h:mm a\";\n      break;\n    case \"Date\":\n      o = Be;\n      break;\n    case \"DateTime\":\n      o = ua;\n      break;\n    case \"DisplayDate\":\n      o = Xe;\n      break;\n    case \"DisplayDateDoW\":\n      o = Tn;\n      break;\n    case \"DisplayTime\":\n      o = te;\n      break;\n    case \"DisplayDateTime\":\n      o = oa;\n      break;\n    case \"DisplayDateDoWTime\":\n      o = la;\n      break;\n    case \"DisplayDateLong\":\n      o = je;\n      break;\n    case \"DisplayDateDoWLong\":\n      o = Mn;\n      break;\n    case \"DisplayDateTimeLong\":\n      o = sa;\n      break;\n    case \"DisplayDateDoWTimeLong\":\n      o = ca;\n      break;\n    case \"ISO\":\n      if (u)\n        return u.toISOString();\n      o = \"YYYY-MM-DDTHH:mm:ss.sssZ\";\n      break;\n    case \"ISOInput\":\n      o = \"YYYY-MM-DDTHH:mm\";\n      break;\n    default:\n      o = n != null ? n : \"YYYY-MM-DD h:mm:ss a\";\n      break;\n  }\n  const s = o.split(\"\");\n  let m = \"\", g = \"\", h = \"\", S = !1;\n  const M = [\"Mo\", \"Qo\", \"Do\", \"do\"];\n  for (const d of s)\n    S ? d === \"]\" ? S = !1 : m += d : d === \"[\" ? (m += l(h, u), h = \"\", g = \"\", S = !0) : (d === g || g === \"\" || h.length > 0 && M.some(\n      (c) => c.startsWith(h) && d === c.substring(h.length, h.length + 1)\n    ) ? h += d : (m += l(h, u), h = d), g = d);\n  return m += l(h, u), m;\n}, me = (n, e, a, r) => ce(n, e, a, r), Aa = (n) => {\n  var a;\n  const e = (a = A(n)) != null ? a : /* @__PURE__ */ new Date();\n  return `${e.getFullYear()}${(e.getMonth() + 1).toString().padStart(2, \"0\")}${e.getDate().toString().padStart(2, \"0\")}${e.getHours().toString().padStart(2, \"0\")}${e.getMinutes().toString().padStart(2, \"0\")}${e.getSeconds().toString().padStart(2, \"0\")}`;\n}, it = (n) => {\n  var a;\n  const e = (a = A(n)) != null ? a : /* @__PURE__ */ new Date();\n  return `${e.getFullYear()}-${(e.getMonth() + 1).toString().padStart(2, \"0\")}-${e.getDate().toString().padStart(2, \"0\")}_${e.getHours().toString().padStart(2, \"0\")}-${e.getMinutes().toString().padStart(2, \"0\")}-${e.getSeconds().toString().padStart(2, \"0\")}`;\n}, ut = (n) => {\n  var a;\n  const e = (a = A(n)) != null ? a : /* @__PURE__ */ new Date();\n  return `${e.getFullYear()}/${(e.getMonth() + 1).toString().padStart(2, \"0\")}/${e.getDate().toString().padStart(2, \"0\")} ${e.getHours().toString().padStart(2, \"0\")}:${e.getMinutes().toString().padStart(2, \"0\")}:${e.getSeconds().toString().padStart(2, \"0\")}`;\n}, ot = (n) => {\n  var a;\n  const e = (a = A(n)) != null ? a : /* @__PURE__ */ new Date();\n  return `${e.getFullYear()}/${(e.getMonth() + 1).toString().padStart(2, \"0\")}/${e.getDate().toString().padStart(2, \"0\")}`;\n}, lt = (n) => {\n  var a;\n  const e = (a = A(n)) != null ? a : /* @__PURE__ */ new Date();\n  return `${e.getHours().toString().padStart(2, \"0\")}:${e.getMinutes().toString().padStart(2, \"0\")}:${e.getSeconds().toString().padStart(2, \"0\")}`;\n}, Le = [\n  \"January\",\n  \"February\",\n  \"March\",\n  \"April\",\n  \"May\",\n  \"June\",\n  \"July\",\n  \"August\",\n  \"September\",\n  \"October\",\n  \"November\",\n  \"December\"\n], ue = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"], Fe = (n) => Math.floor(n / 365 / 24 / 60 / 60 / 1e3), oe = (n, e) => Math.floor((n - (e ? Fe(n) * 365 * 24 * 60 * 60 * 1e3 : 0)) / 30 / 24 / 60 / 60 / 1e3), sn = (n) => Math.floor(n / 7 / 24 / 60 / 60 / 1e3), P = (n, e) => Math.floor((n - (e ? oe(n) * 30 * 24 * 60 * 60 * 1e3 : 0)) / 24 / 60 / 60 / 1e3), z = (n, e) => Math.floor((n - (e ? P(n) * 24 * 60 * 60 * 1e3 : 0)) / 60 / 60 / 1e3), B = (n, e) => Math.floor((n - (e ? z(n) * 60 * 60 * 1e3 : 0)) / 60 / 1e3), pe = (n, e) => Math.floor((n - (e ? B(n) * 60 * 1e3 : 0)) / 1e3), Sa = (n) => n % 4 === 0 && n % 100 !== 0 || n % 400 === 0, J = (n, e) => {\n  var t;\n  let a = e, r = n;\n  for (; a < 0; )\n    a += 12, r -= 1;\n  for (; a > 11; )\n    a -= 12, r += 1;\n  return (t = [31, Sa(r) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][a]) != null ? t : null;\n}, st = (n) => {\n  const e = A(n);\n  return e ? J(e.getUTCFullYear(), e.getUTCMonth()) : null;\n}, $e = (n, e) => {\n  var l, o, s, m, g, h, S, M, I;\n  let a = R(n);\n  if (!a)\n    return null;\n  const r = e < 0, t = (l = A(n)) != null ? l : /* @__PURE__ */ new Date(), i = t.getUTCDate(), u = i === J(t.getUTCFullYear(), t.getUTCMonth());\n  for (let N = 0; N < Math.abs(e); N++) {\n    const O = (o = A(a)) != null ? o : /* @__PURE__ */ new Date(), d = O.getUTCFullYear(), c = O.getUTCMonth();\n    if (u)\n      r ? a -= 24 * 60 * 60 * 1e3 * ((s = J(d, c)) != null ? s : 0) : a += 24 * 60 * 60 * 1e3 * ((m = J(d, c + 1)) != null ? m : 0);\n    else {\n      r ? a -= 24 * 60 * 60 * 1e3 * ((g = J(d, c - 1)) != null ? g : 0) : a += 24 * 60 * 60 * 1e3 * ((h = J(d, c)) != null ? h : 0);\n      let C = (S = A(a)) != null ? S : /* @__PURE__ */ new Date();\n      C.getUTCDate() < 15 && C.getUTCDate() < i && (a -= 24 * 60 * 60 * 1e3 * C.getUTCDate()), C = (M = A(a)) != null ? M : /* @__PURE__ */ new Date();\n      const U = (I = J(C.getUTCFullYear(), C.getUTCMonth())) != null ? I : 0;\n      C.getUTCDate() > 15 && C.getUTCDate() < i && C.getUTCDate() < U && (a += 24 * 60 * 60 * 1e3 * ((U > i ? i : U) - C.getUTCDate()));\n    }\n  }\n  return a;\n}, $ = (n, e) => {\n  var r, t, i, u, l, o, s, m, g, h, S, M, I, N, O, d, c, C, U, W, ee, G, ge, he, de, Ae, Se, ye, ve, De, Te, Me, Ce, be, we, ke, Oe, K;\n  let a = R(n);\n  for (const _ of Object.keys(e)) {\n    if (a === null)\n      return null;\n    switch (_) {\n      case \"year\":\n      case \"years\":\n        switch (e[_]) {\n          case \"StartOf\":\n            {\n              const y = (r = A(a)) != null ? r : /* @__PURE__ */ new Date();\n              a = (t = $(a, {\n                month: y.getUTCMonth() * -1,\n                months: \"StartOf\"\n              })) != null ? t : 0;\n            }\n            break;\n          case \"EndOf\":\n            {\n              const y = (i = A(a)) != null ? i : /* @__PURE__ */ new Date();\n              a = (u = $(a, {\n                month: 11 - y.getUTCMonth(),\n                months: \"EndOf\"\n              })) != null ? u : 0;\n            }\n            break;\n          default:\n            a = $e(a, f(e[_]) * 12);\n            break;\n        }\n        break;\n      case \"month\":\n      case \"months\":\n        switch (e[_]) {\n          case \"StartOf\":\n            {\n              const y = (l = A(a)) != null ? l : /* @__PURE__ */ new Date();\n              a = (o = $(a, {\n                day: (y.getUTCDate() - 1) * -1,\n                days: \"StartOf\"\n              })) != null ? o : 0;\n            }\n            break;\n          case \"EndOf\":\n            {\n              const y = (s = A(a)) != null ? s : /* @__PURE__ */ new Date();\n              a = (g = $(a, {\n                day: ((m = J(y.getUTCFullYear(), y.getUTCMonth())) != null ? m : 0) - y.getUTCDate(),\n                days: \"EndOf\"\n              })) != null ? g : 0;\n            }\n            break;\n          default:\n            a = $e(a, f(e[_]));\n            break;\n        }\n        break;\n      case \"quarter\":\n      case \"quarters\":\n        switch (e[_]) {\n          case \"StartOf\":\n            {\n              const y = (h = A(a)) != null ? h : /* @__PURE__ */ new Date();\n              a = (S = $(a, {\n                month: y.getUTCMonth() % 3 * -1,\n                months: \"StartOf\"\n              })) != null ? S : 0;\n            }\n            break;\n          case \"EndOf\":\n            {\n              const y = (M = A(a)) != null ? M : /* @__PURE__ */ new Date();\n              a = (I = $(a, {\n                month: 2 - y.getUTCMonth() % 3,\n                months: \"EndOf\"\n              })) != null ? I : 0;\n            }\n            break;\n          default:\n            a = $e(a, f(e[_]) * 3);\n            break;\n        }\n        break;\n      default:\n        if (a === null)\n          return null;\n        switch (_) {\n          case \"week\":\n          case \"weeks\":\n            switch (e[_]) {\n              case \"StartOf\":\n                {\n                  const y = (N = A(a)) != null ? N : /* @__PURE__ */ new Date();\n                  a = (O = $(a, {\n                    day: y.getUTCDay() * -1,\n                    days: \"StartOf\"\n                  })) != null ? O : 0;\n                }\n                break;\n              case \"StartOfMon\":\n                {\n                  const y = (d = A(a)) != null ? d : /* @__PURE__ */ new Date();\n                  switch (y.getUTCDay()) {\n                    case 0:\n                      a = (c = $(a, {\n                        day: -6,\n                        days: \"StartOf\"\n                      })) != null ? c : 0;\n                      break;\n                    case 1:\n                      a = (C = $(a, {\n                        days: \"StartOf\"\n                      })) != null ? C : 0;\n                      break;\n                    default:\n                      a = (U = $(a, {\n                        day: (y.getUTCDay() - 1) * -1,\n                        days: \"StartOf\"\n                      })) != null ? U : 0;\n                      break;\n                  }\n                }\n                break;\n              case \"EndOf\":\n                {\n                  const y = (W = A(a)) != null ? W : /* @__PURE__ */ new Date();\n                  a = (ee = $(a, {\n                    day: 6 - y.getUTCDay(),\n                    days: \"EndOf\"\n                  })) != null ? ee : 0;\n                }\n                break;\n              default:\n                a += f(e[_]) * 7 * 24 * 60 * 60 * 1e3;\n                break;\n            }\n            break;\n          case \"day\":\n          case \"days\":\n            switch (e[_]) {\n              case \"StartOf\":\n                {\n                  const y = (G = A(a)) != null ? G : /* @__PURE__ */ new Date();\n                  a = (he = $(a, {\n                    // Added to support moving to the beginning of a day, but in a selected timezone\n                    hour: y.getUTCHours() * -1 + (e.timezoneSource ? ((ge = Ie(e.timezoneSource)) != null ? ge : 0) / 60 : 0),\n                    hours: \"StartOf\"\n                  })) != null ? he : 0;\n                }\n                break;\n              case \"EndOf\":\n                {\n                  const y = (de = A(a)) != null ? de : /* @__PURE__ */ new Date();\n                  a = (Ae = $(a, {\n                    hour: 23 - y.getUTCHours(),\n                    hours: \"EndOf\"\n                  })) != null ? Ae : 0;\n                }\n                break;\n              default:\n                a += f(e[_]) * 24 * 60 * 60 * 1e3;\n                break;\n            }\n            break;\n          case \"hour\":\n          case \"hours\":\n            switch (e[_]) {\n              case \"StartOf\":\n                {\n                  const y = (Se = A(a)) != null ? Se : /* @__PURE__ */ new Date();\n                  a = (ye = $(a, {\n                    minute: y.getUTCMinutes() * -1,\n                    minutes: \"StartOf\"\n                  })) != null ? ye : 0;\n                }\n                break;\n              case \"EndOf\":\n                {\n                  const y = (ve = A(a)) != null ? ve : /* @__PURE__ */ new Date();\n                  a = (De = $(a, {\n                    minute: 59 - y.getUTCMinutes(),\n                    minutes: \"EndOf\"\n                  })) != null ? De : 0;\n                }\n                break;\n              default:\n                a += f(e[_]) * 60 * 60 * 1e3;\n                break;\n            }\n            break;\n          case \"minute\":\n          case \"minutes\":\n            switch (e[_]) {\n              case \"StartOf\":\n                {\n                  const y = (Te = A(a)) != null ? Te : /* @__PURE__ */ new Date();\n                  a = (Me = $(a, {\n                    second: y.getUTCSeconds() * -1,\n                    seconds: \"StartOf\"\n                  })) != null ? Me : 0;\n                }\n                break;\n              case \"EndOf\":\n                {\n                  const y = (Ce = A(a)) != null ? Ce : /* @__PURE__ */ new Date();\n                  a = (be = $(a, {\n                    second: 59 - y.getUTCSeconds(),\n                    seconds: \"EndOf\"\n                  })) != null ? be : 0;\n                }\n                break;\n              default:\n                a += f(e[_]) * 60 * 1e3;\n                break;\n            }\n            break;\n          case \"second\":\n          case \"seconds\":\n            switch (e[_]) {\n              case \"StartOf\":\n                {\n                  const y = (we = A(a)) != null ? we : /* @__PURE__ */ new Date();\n                  a = (ke = $(a, {\n                    millisecond: y.getUTCMilliseconds() * -1\n                  })) != null ? ke : 0;\n                }\n                break;\n              case \"EndOf\":\n                {\n                  const y = (Oe = A(a)) != null ? Oe : /* @__PURE__ */ new Date();\n                  a = (K = $(a, {\n                    millisecond: 999 - y.getUTCMilliseconds()\n                  })) != null ? K : 0;\n                }\n                break;\n              default:\n                a += f(e[_]) * 1e3;\n                break;\n            }\n            break;\n          case \"millisecond\":\n          case \"milliseconds\":\n            a += f(e[_]);\n            break;\n        }\n        break;\n    }\n  }\n  return a;\n}, ct = (n, e) => {\n  let a = b(n);\n  const r = b(e);\n  if (!a || !r || a === r)\n    return 0;\n  let t = 0;\n  for (; L(a, \"IsBefore\", r, \"day\"); ) {\n    const i = cn(a);\n    i !== 0 && i !== 6 && t++, a = b(a, { days: 1 });\n  }\n  for (; L(a, \"IsAfter\", r, \"day\"); ) {\n    a = b(a, { days: -1 });\n    const i = cn(a);\n    i !== 0 && i !== 6 && t--;\n  }\n  return t;\n}, q = (n, e, a) => {\n  var i, u;\n  let r = R(n), t = R(e);\n  if (!r || !t)\n    return null;\n  if (r === t)\n    return 0;\n  switch (a) {\n    case \"year\":\n    case \"years\":\n    case \"month\":\n    case \"months\":\n      const l = r < t, o = ([\"year\", \"years\"].includes(a) ? 12 : 1) * (l ? -1 : 1);\n      let s = 0, m = (i = $e(t, o)) != null ? i : 0;\n      for (; l ? r <= m : r >= m; )\n        s -= l ? -1 : 1, m = (u = $e(m, o)) != null ? u : 0;\n      return s;\n    default: {\n      const g = t - r;\n      switch (a) {\n        case \"week\":\n        case \"weeks\":\n          return g < 0 ? sn(g * -1) * -1 : sn(g);\n        case \"day\":\n        case \"days\":\n          return g < 0 ? P(g * -1) * -1 : P(g);\n        case \"hour\":\n        case \"hours\":\n          return g < 0 ? z(g * -1) * -1 : z(g);\n        case \"minute\":\n        case \"minutes\":\n          return g < 0 ? B(g * -1) * -1 : B(g);\n        case \"second\":\n        case \"seconds\":\n          return g < 0 ? pe(g * -1) * -1 : pe(g);\n        case \"millisecond\":\n        case \"milliseconds\":\n          return g;\n      }\n    }\n  }\n  return null;\n}, mt = (n, e, a) => f(ce(n, p(e, a))), ft = (n, e) => {\n  console.error(\"Deprecated!  Use: DateWeekISONumber\");\n  const a = A(n != null ? n : \"now\", D({ timezoneSource: \"UTC\" }, e));\n  if (!a)\n    return null;\n  const r = f(ce(\"YYYY\", n)), t = new Date(r, 0, 1), i = Math.floor((a.valueOf() - t.valueOf()) / (24 * 60 * 60 * 1e3)) + 7, u = Math.ceil(i / 7);\n  return { year: r, week: u };\n}, ya = (n, e) => {\n  const a = A(n != null ? n : \"now\", e);\n  if (!a)\n    return null;\n  const r = new Date(a.valueOf()), t = (a.getDay() + 6) % 7;\n  r.setDate(r.getDate() - t + 3);\n  const i = r.valueOf();\n  r.setMonth(0, 1), r.getDay() !== 4 && r.setMonth(0, 1 + (4 - r.getDay() + 7) % 7);\n  const u = 1 + Math.ceil((i - r.valueOf()) / 6048e5), l = a;\n  return l.setDate(l.getDate() + 3 - (l.getDay() + 6) % 7), { year: l.getFullYear(), week: u };\n}, Q = (n, e) => {\n  var a;\n  return (a = ya(n, e)) != null ? a : { year: (/* @__PURE__ */ new Date()).getFullYear(), week: 1 };\n}, wn = (n) => {\n  var i, u;\n  if (!(n != null && n.year))\n    return null;\n  const e = (n.week - 1) * 7;\n  let a = b(new Date(n.year, 0, e), { week: \"StartOfMon\" }), r = (i = Q(a)) != null ? i : n, t = 0;\n  for (; n.week !== r.week || n.year !== r.year; ) {\n    if (t > 4)\n      return null;\n    t++, r.year < n.year || r.year === n.year && r.week < n.week ? a = b(a, { weeks: 1 }) : a = b(a, { weeks: -1 }), r = (u = Q(a)) != null ? u : n;\n  }\n  return a;\n}, va = (n) => {\n  const e = wn(n);\n  return e ? {\n    start: e,\n    end: b(e, { days: 6 })\n  } : null;\n}, gt = (n) => {\n  var e;\n  return (e = va(n)) != null ? e : {\n    start: b(\"now\", { week: \"StartOfMon\" }),\n    end: b(\"now\", { week: \"StartOfMon\", days: 6 })\n  };\n}, ht = (n) => {\n  const e = b(n != null ? n : \"now\", { month: \"StartOf\", days: 6, week: \"StartOfMon\" });\n  let a = b(e, { weeks: 2 });\n  for (; L(e, \"IsSame\", a, \"month\"); )\n    a = b(a, { week: 1 });\n  return a = b(a, { week: -1, days: 6 }), { start: e, end: a };\n}, dt = (n, e) => {\n  let a = wn(n);\n  return a ? Q(b(a, typeof e == \"number\" ? { weeks: e } : e)) : null;\n}, Da = (n, e) => {\n  var i, u, l, o, s, m, g, h, S, M, I, N, O, d, c;\n  let a = {\n    year: 0,\n    month: 0,\n    day: 0,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0\n  };\n  const r = (i = p(n)) != null ? i : 0;\n  let t = (u = p(e)) != null ? u : 0;\n  return a.year = (l = q(r, t, \"year\")) != null ? l : 0, a.year && (t = (o = p(t, { year: a.year * -1 })) != null ? o : 0), a.month = (s = q(r, t, \"month\")) != null ? s : 0, a.month && (t = (m = p(t, { month: a.month * -1 })) != null ? m : 0), a.day = (g = q(r, t, \"day\")) != null ? g : 0, a.day && (t = (h = p(t, { day: a.day * -1 })) != null ? h : 0), a.hour = (S = q(r, t, \"hour\")) != null ? S : 0, a.hour && (t = (M = p(t, { hour: a.hour * -1 })) != null ? M : 0), a.minute = (I = q(r, t, \"minute\")) != null ? I : 0, a.minute && (t = (N = p(t, { minute: a.minute * -1 })) != null ? N : 0), a.second = (O = q(r, t, \"second\")) != null ? O : 0, a.second && (t = (d = p(t, { second: a.second * -1 })) != null ? d : 0), a.millisecond = (c = q(r, t, \"millisecond\")) != null ? c : 0, a;\n}, Ta = (n, e, a = !1, r = !1) => {\n  const t = Da(n, e);\n  let i = \"\";\n  return t.year ? (i += ` ${v(t.year)}${r ? \"Y\" : \" \" + k(\"Year\", t.year)}`, i += ` ${v(t.month)}${r ? \"Mo\" : \" \" + k(\"Month\", t.month)}`, t.day && !a && (i += ` ${v(t.day)}${r ? \"D\" : \" \" + k(\"Day\", t.day)}`)) : t.month ? (i += ` ${v(t.month)}${r ? \"Mo\" : \" \" + k(\"Month\", t.month)}`, t.day && (i += ` ${v(t.day)}${r ? \"D\" : \" \" + k(\"Day\", t.day)}`)) : t.day ? (i += ` ${v(t.day)}${r ? \"D\" : \" \" + k(\"Day\", t.day)}`, t.hour && (i += ` ${v(t.hour)}${r ? \"h\" : \" \" + k(\"Hour\", t.hour)}`), t.minute && !a && (i += ` ${v(t.minute)}${r ? \"m\" : \" \" + k(\"Minute\", t.minute)}`)) : t.hour ? (i += ` ${v(t.hour)}${r ? \"h\" : \" \" + k(\"Hour\", t.hour)}`, t.minute && (i += ` ${v(t.minute)}${r ? \"m\" : \" \" + k(\"Minute\", t.minute)}`)) : ((t.minute || !i && a) && (i += ` ${v(t.minute)}${r ? \"m\" : \" \" + k(\"Minute\", t.minute)}`), (!i || !a && t.second) && (i += ` ${v(t.second)}${r ? \"s\" : \" \" + k(\"Second\", t.second)}`)), i.trim();\n}, At = (n, e = !1, a = !1) => {\n  const r = n * 1e3;\n  let t = \"\";\n  return Fe(r) ? (t += ` ${v(Fe(r), 0)}${a ? \"Y\" : \" \" + k(\"Year\", Fe(r))}`, t += ` ${v(oe(r, !0), 0)}${a ? \"Mo\" : \" \" + k(\"Month\", oe(r, !0))}`, P(r, !0) && !e && (t += ` ${v(P(r, !0), 0)}${a ? \"D\" : \" \" + k(\"Day\", P(r, !0))}`)) : oe(r, !0) ? (t += ` ${v(oe(r, !0), 0)}${a ? \"Mo\" : \" \" + k(\"Month\", oe(r, !0))}`, P(r, !0) && (t += ` ${v(P(r, !0), 0)}${a ? \"D\" : \" \" + k(\"Day\", P(r, !0))}`)) : P(r, !0) ? (t += ` ${v(P(r, !0), 0)}${a ? \"D\" : \" \" + k(\"Day\", P(r, !0))}`, z(r, !0) && (t += ` ${v(z(r, !0), 0)}${a ? \"h\" : \" \" + k(\"Hour\", z(r, !0))}`), B(r, !0) && !e && (t += ` ${v(B(r, !0), 0)}${a ? \"m\" : \" \" + k(\"Minute\", B(r, !0))}`)) : z(r, !0) ? (t += ` ${v(z(r, !0), 0)}${a ? \"h\" : \" \" + k(\"Hour\", z(r, !0))}`, B(r, !0) && (t += ` ${v(B(r, !0), 0)}${a ? \"m\" : \" \" + k(\"Minute\", B(r, !0))}`)) : ((B(r, !0) || !t && e) && (t += ` ${v(B(r, !0), 0)}${a ? \"m\" : \" \" + k(\"Minute\", B(r, !0))}`), (!t || !e && pe(r, !0)) && (t += ` ${v(pe(r, !0), 0)}${a ? \"s\" : \" \" + k(\"Second\", pe(r, !0))}`)), t.trim();\n}, w = (n, e) => e === 0 ? [\"IsSame\", \"IsSameOrBefore\", \"IsSameOrAfter\"].includes(n) : e > 0 ? [\"IsAfter\", \"IsSameOrAfter\"].includes(n) : [\"IsBefore\", \"IsSameOrBefore\"].includes(n), L = (n, e, a, r) => {\n  var u, l, o, s, m, g, h, S, M, I;\n  const t = a && typeof a == \"object\" && !(a instanceof Date) ? p(\"now\", a) : a, i = ((u = R(n, void 0, !0)) != null ? u : 0) - ((l = R(t, void 0, !0)) != null ? l : 0);\n  if (i === 0)\n    return w(e, i);\n  if (r) {\n    const N = (o = A(n)) != null ? o : /* @__PURE__ */ new Date(), O = (s = A(t)) != null ? s : /* @__PURE__ */ new Date(), d = N.getUTCFullYear() - O.getUTCFullYear();\n    if ([\"year\", \"years\"].includes(r))\n      return w(e, d);\n    const c = N.getUTCMonth() - O.getUTCMonth();\n    if ([\"month\", \"months\"].includes(r))\n      return d !== 0 ? w(e, d) : w(e, c);\n    if ([\"week\", \"weeks\"].includes(r)) {\n      if (Math.abs(i) > 7 * 24 * 60 * 60 * 1e3)\n        return w(e, i);\n      const G = ((g = (m = Q(n)) == null ? void 0 : m.week) != null ? g : 0) - ((S = (h = Q(t)) == null ? void 0 : h.week) != null ? S : 0);\n      return G === 0 && ((I = (M = Q(n)) == null ? void 0 : M.week) != null ? I : 0) === 1 && Math.abs(d) > 1 && d !== 0 ? w(e, d) : w(e, G);\n    }\n    const C = N.getUTCDate() - O.getUTCDate();\n    if ([\"day\", \"days\"].includes(r))\n      return d !== 0 ? w(e, d) : c !== 0 ? w(e, c) : w(e, C);\n    const U = N.getUTCHours() - O.getUTCHours();\n    if ([\"hour\", \"hours\"].includes(r))\n      return d !== 0 ? w(e, d) : c !== 0 ? w(e, c) : C !== 0 ? w(e, C) : w(e, U);\n    const W = N.getUTCMinutes() - O.getUTCMinutes();\n    if ([\"minute\", \"minutes\"].includes(r))\n      return d !== 0 ? w(e, d) : c !== 0 ? w(e, c) : C !== 0 ? w(e, C) : U !== 0 ? w(e, U) : w(e, W);\n    const ee = N.getUTCSeconds() - O.getUTCSeconds();\n    if ([\"second\", \"second\"].includes(r))\n      return d !== 0 ? w(e, d) : c !== 0 ? w(e, c) : C !== 0 ? w(e, C) : U !== 0 ? w(e, U) : W !== 0 ? w(e, W) : w(e, ee);\n  }\n  return w(e, i);\n};\nfunction St(...n) {\n  var e;\n  return (e = n == null ? void 0 : n.reduce((a, r) => {\n    const t = ie(r);\n    return t && (!a || L(t, \"IsBefore\", a, \"day\")) ? t : a;\n  }, null)) != null ? e : null;\n}\nfunction yt(...n) {\n  var e;\n  return (e = n == null ? void 0 : n.reduce((a, r) => {\n    const t = ie(r);\n    return t && (!a || L(t, \"IsAfter\", a, \"day\")) ? t : a;\n  }, null)) != null ? e : null;\n}\nconst vt = (n, e, a) => L(n, \"IsSameOrAfter\", e, \"day\") && L(n, \"IsSameOrBefore\", a, \"day\"), Ma = (n, e, a) => L(n, \"IsBefore\", e, a) ? -1 : L(n, \"IsAfter\", e, a) ? 1 : null, Ca = (n, e, a) => {\n  var r;\n  return (r = Ma(n, e, a)) != null ? r : 0;\n};\nvar ba = /* @__PURE__ */ ((n) => (n[n.Q1 = 1] = \"Q1\", n[n.Q2 = 2] = \"Q2\", n[n.Q3 = 3] = \"Q3\", n[n.Q4 = 4] = \"Q4\", n))(ba || {});\nconst Dt = (n, e) => {\n  var r, t;\n  const a = R(`${n}-${(e * 3 - 1).toString().padStart(2, \"0\")}-01`, \"UTC\");\n  return a ? {\n    start: ((r = Y(a, { quarter: \"StartOf\" })) != null ? r : \"\").substring(0, 10),\n    end: ((t = Y(a, { quarter: \"EndOf\" })) != null ? t : \"\").substring(0, 10)\n  } : null;\n}, Tt = () => ({\n  year: (/* @__PURE__ */ new Date()).getFullYear(),\n  quarter: Math.floor((/* @__PURE__ */ new Date()).getUTCMonth() / 3) + 1\n}), Mt = (n) => {\n  const e = A(n);\n  return e ? {\n    year: e.getUTCFullYear(),\n    quarter: Math.floor(e.getUTCMonth() / 3) + 1\n  } : null;\n}, Ct = (n, e) => {\n  var r, t;\n  const a = R(`${n}-${e.toString().padStart(2, \"0\")}-01`, \"UTC\");\n  return a ? {\n    start: ((r = Y(a, { month: \"StartOf\" })) != null ? r : \"\").substring(0, 10),\n    end: ((t = Y(a, { month: \"EndOf\" })) != null ? t : \"\").substring(0, 10)\n  } : null;\n}, bt = () => ({\n  year: (/* @__PURE__ */ new Date()).getFullYear(),\n  monthOneBased: Math.floor((/* @__PURE__ */ new Date()).getUTCMonth()) + 1\n}), wt = (n) => {\n  const e = A(n);\n  return e ? {\n    year: e.getUTCFullYear(),\n    monthOneBased: Math.floor(e.getUTCMonth()) + 1\n  } : null;\n}, kt = [0, 1, 2, 3, 4, 5, 6], cn = (n) => {\n  const e = ie(n);\n  if (!e)\n    return null;\n  const a = A(e);\n  return a ? a.getUTCDay() : null;\n}, ie = (n, e) => {\n  var a, r, t;\n  if (!n)\n    return null;\n  try {\n    const i = !n || typeof n == \"object\" || typeof n == \"number\" || [\"now\", \"today\"].includes(n) ? (r = me(\"Date\", n, (a = e == null ? void 0 : e.timezoneDisplay) != null ? a : fa())) != null ? r : \"\" : (n != null ? n : \"\").substring(0, 10);\n    if (!n || !i)\n      return null;\n    if (e != null && e.fromFormat) {\n      if (i.length && i.length === e.fromFormat.length) {\n        const l = e.fromFormat.indexOf(\"Y\"), o = e.fromFormat.lastIndexOf(\"Y\"), s = e.fromFormat.indexOf(\"M\"), m = e.fromFormat.lastIndexOf(\"M\"), g = e.fromFormat.indexOf(\"D\"), h = e.fromFormat.lastIndexOf(\"D\"), S = i.slice(l, o + 1), M = i.slice(s, m + 1), I = i.slice(g, h + 1);\n        if (f(S) && f(M) && f(S))\n          return ie(\n            `${S.padStart(4, \"20\")}-${M.padStart(2, \"0\")}-${I.padStart(2, \"0\")}`,\n            qe(e, \"fromFormat\")\n          );\n      }\n      return null;\n    }\n    let u = new Date(i);\n    return u instanceof Date && isFinite(u) ? (e && (u = (t = A(u, e)) != null ? t : u, Object.values(e).includes(\"EndOf\") && u.setUTCHours(10)), me(e != null && e.formatLocale ? \"Local\" : \"Date\", u, \"UTC\")) : null;\n  } catch (i) {\n    return null;\n  }\n}, b = (n, e) => {\n  var a, r, t;\n  return (t = (r = ie(n, e)) != null ? r : me(e != null && e.formatLocale ? \"Local\" : \"Date\", /* @__PURE__ */ new Date(), (a = e == null ? void 0 : e.timezoneDisplay) != null ? a : \"UTC\")) != null ? t : (/* @__PURE__ */ new Date()).toISOString().substring(0, 10);\n}, X = (n, e) => {\n  var a, r, t;\n  if ((!n || typeof n == \"string\" && !Cn(n)) && n !== \"now\" && n !== \"today\")\n    return null;\n  try {\n    let i = ce(\n      e != null && e.formatLocale ? te : \"HH:mm:ss\",\n      p(n, e),\n      (a = e == null ? void 0 : e.timezoneSource) != null ? a : void 0\n    );\n    if (i)\n      return i;\n    let u = (n != null ? n : \"\").toString().toLowerCase().trim(), l = 0;\n    u.endsWith(\"am\") && (u = u.substring(0, u.length - 2).trim()), u.endsWith(\"a\") && (u = u.substring(0, u.length - 1).trim()), u.endsWith(\"pm\") && (u = u.substring(0, u.length - 2).trim(), l += 12), u.endsWith(\"p\") && (u = u.substring(0, u.length - 1).trim(), l += 12), u.substring(1, 2) === \":\" && (u = `0${u}`), u = b(\"now\") + \"T\" + u;\n    let o = p(u, e);\n    if (o) {\n      let s = ce(\n        e != null && e.formatLocale ? te : \"HH:mm:ss\",\n        o + l * 60 * 60 * 1e3,\n        (r = e == null ? void 0 : e.timezoneSource) != null ? r : \"UTC\",\n        (t = e == null ? void 0 : e.timezoneSource) != null ? t : \"UTC\"\n      );\n      if (s)\n        return s;\n    }\n  } catch (i) {\n  }\n  return null;\n}, Ot = (n, e = \"00:00\", a = \"24:00\") => {\n  let r = X(e);\n  if (!r)\n    return [];\n  const t = [r], i = X(a, { minutes: n * -1 });\n  if (!i || n <= 0)\n    return t;\n  for (; r < i && (r = X(r, { minutes: n }), !!r); )\n    t.push(r);\n  return t;\n}, wa = (n, e = 1) => {\n  if (typeof n != \"string\" || en(n)) {\n    const a = A(n);\n    return a ? (a.setMilliseconds(0), a.setSeconds(0), a.setMinutes(a.getMinutes() - a.getMinutes() % e), Y(a)) : null;\n  } else {\n    const a = X(n);\n    return a ? X(wa(A(`${b(\"now\")} ${a}`), e)) : null;\n  }\n}, kn = () => (/* @__PURE__ */ new Date()).toLocaleString(\"en-US\", { timeZone: \"America/New_York\" }), Nt = () => {\n  var n;\n  return (n = me(\"Date\", \"now\", \"America/New_York\")) != null ? n : b(\"now\");\n}, Et = (n, e, a = \"now\") => {\n  var t;\n  if (!n)\n    return \"\";\n  const r = (t = q(b(a, { week: e }), b(n, { week: e }), \"weeks\")) != null ? t : 0;\n  switch (r) {\n    case 0:\n      return \"This Week\";\n    case -1:\n      return \"Last Week\";\n    case 1:\n      return \"Next Week\";\n    default:\n      return `${v(Math.abs(r))} Weeks ${r < 0 ? \"Ago\" : \"from Now\"}`;\n  }\n}, ka = (n = \"now\") => E(ce(\"d\", b(n))), It = (n = \"now\") => {\n  const e = ka(n);\n  return e === null ? !1 : e === 0 || e === 6;\n}, pt = (n, e, a = { day: 1 }, r = 1e3) => {\n  if (!Object.values(a).some((l) => f(l) > 0))\n    return [];\n  const t = L(n, \"IsAfter\", e, \"day\");\n  let i = b(t ? e : n), u = [];\n  for (; L(i, \"IsSameOrBefore\", t ? n : e, \"day\") && (u.push(i), i = b(i, a), !(u.length >= r)); )\n    ;\n  return u.sort((l, o) => Ca(t ? o : l, t ? l : o));\n}, nn = [\n  {\n    group: \"US (Common)\",\n    zones: [\n      { value: \"America/Puerto_Rico\", name: \"Puerto Rico (Atlantic)\" },\n      { value: \"America/New_York\", name: \"New York (Eastern)\" },\n      { value: \"America/Chicago\", name: \"Chicago (Central)\" },\n      { value: \"America/Denver\", name: \"Denver (Mountain)\" },\n      { value: \"America/Phoenix\", name: \"Phoenix (MST)\" },\n      { value: \"America/Los_Angeles\", name: \"Los Angeles (Pacific)\" },\n      { value: \"America/Anchorage\", name: \"Anchorage (Alaska)\" },\n      { value: \"Pacific/Honolulu\", name: \"Honolulu (Hawaii)\" }\n    ]\n  },\n  {\n    group: \"America\",\n    zones: [\n      { value: \"America/Adak\", name: \"Adak\" },\n      { value: \"America/Anchorage\", name: \"Anchorage\" },\n      { value: \"America/Anguilla\", name: \"Anguilla\" },\n      { value: \"America/Antigua\", name: \"Antigua\" },\n      { value: \"America/Araguaina\", name: \"Araguaina\" },\n      { value: \"America/Argentina/Buenos_Aires\", name: \"Argentina - Buenos Aires\" },\n      { value: \"America/Argentina/Catamarca\", name: \"Argentina - Catamarca\" },\n      { value: \"America/Argentina/ComodRivadavia\", name: \"Argentina - ComodRivadavia\" },\n      { value: \"America/Argentina/Cordoba\", name: \"Argentina - Cordoba\" },\n      { value: \"America/Argentina/Jujuy\", name: \"Argentina - Jujuy\" },\n      { value: \"America/Argentina/La_Rioja\", name: \"Argentina - La Rioja\" },\n      { value: \"America/Argentina/Mendoza\", name: \"Argentina - Mendoza\" },\n      { value: \"America/Argentina/Rio_Gallegos\", name: \"Argentina - Rio Gallegos\" },\n      { value: \"America/Argentina/Salta\", name: \"Argentina - Salta\" },\n      { value: \"America/Argentina/San_Juan\", name: \"Argentina - San Juan\" },\n      { value: \"America/Argentina/San_Luis\", name: \"Argentina - San Luis\" },\n      { value: \"America/Argentina/Tucuman\", name: \"Argentina - Tucuman\" },\n      { value: \"America/Argentina/Ushuaia\", name: \"Argentina - Ushuaia\" },\n      { value: \"America/Aruba\", name: \"Aruba\" },\n      { value: \"America/Asuncion\", name: \"Asuncion\" },\n      { value: \"America/Atikokan\", name: \"Atikokan\" },\n      { value: \"America/Atka\", name: \"Atka\" },\n      { value: \"America/Bahia\", name: \"Bahia\" },\n      { value: \"America/Barbados\", name: \"Barbados\" },\n      { value: \"America/Belem\", name: \"Belem\" },\n      { value: \"America/Belize\", name: \"Belize\" },\n      { value: \"America/Blanc-Sablon\", name: \"Blanc-Sablon\" },\n      { value: \"America/Boa_Vista\", name: \"Boa Vista\" },\n      { value: \"America/Bogota\", name: \"Bogota\" },\n      { value: \"America/Boise\", name: \"Boise\" },\n      { value: \"America/Buenos_Aires\", name: \"Buenos Aires\" },\n      { value: \"America/Cambridge_Bay\", name: \"Cambridge Bay\" },\n      { value: \"America/Campo_Grande\", name: \"Campo Grande\" },\n      { value: \"America/Cancun\", name: \"Cancun\" },\n      { value: \"America/Caracas\", name: \"Caracas\" },\n      { value: \"America/Catamarca\", name: \"Catamarca\" },\n      { value: \"America/Cayenne\", name: \"Cayenne\" },\n      { value: \"America/Cayman\", name: \"Cayman\" },\n      { value: \"America/Chicago\", name: \"Chicago\" },\n      { value: \"America/Chihuahua\", name: \"Chihuahua\" },\n      { value: \"America/Coral_Harbour\", name: \"Coral Harbour\" },\n      { value: \"America/Cordoba\", name: \"Cordoba\" },\n      { value: \"America/Costa_Rica\", name: \"Costa Rica\" },\n      { value: \"America/Cuiaba\", name: \"Cuiaba\" },\n      { value: \"America/Curacao\", name: \"Curacao\" },\n      { value: \"America/Danmarkshavn\", name: \"Danmarkshavn\" },\n      { value: \"America/Dawson\", name: \"Dawson\" },\n      { value: \"America/Dawson_Creek\", name: \"Dawson Creek\" },\n      { value: \"America/Denver\", name: \"Denver\" },\n      { value: \"America/Detroit\", name: \"Detroit\" },\n      { value: \"America/Dominica\", name: \"Dominica\" },\n      { value: \"America/Edmonton\", name: \"Edmonton\" },\n      { value: \"America/Eirunepe\", name: \"Eirunepe\" },\n      { value: \"America/El_Salvador\", name: \"El Salvador\" },\n      { value: \"America/Ensenada\", name: \"Ensenada\" },\n      { value: \"America/Fortaleza\", name: \"Fortaleza\" },\n      { value: \"America/Fort_Wayne\", name: \"Fort Wayne\" },\n      { value: \"America/Glace_Bay\", name: \"Glace Bay\" },\n      { value: \"America/Godthab\", name: \"Godthab\" },\n      { value: \"America/Goose_Bay\", name: \"Goose Bay\" },\n      { value: \"America/Grand_Turk\", name: \"Grand Turk\" },\n      { value: \"America/Grenada\", name: \"Grenada\" },\n      { value: \"America/Guadeloupe\", name: \"Guadeloupe\" },\n      { value: \"America/Guatemala\", name: \"Guatemala\" },\n      { value: \"America/Guayaquil\", name: \"Guayaquil\" },\n      { value: \"America/Guyana\", name: \"Guyana\" },\n      { value: \"America/Halifax\", name: \"Halifax\" },\n      { value: \"America/Havana\", name: \"Havana\" },\n      { value: \"America/Hermosillo\", name: \"Hermosillo\" },\n      { value: \"America/Indiana/Indianapolis\", name: \"Indiana - Indianapolis\" },\n      { value: \"America/Indiana/Knox\", name: \"Indiana - Knox\" },\n      { value: \"America/Indiana/Marengo\", name: \"Indiana - Marengo\" },\n      { value: \"America/Indiana/Petersburg\", name: \"Indiana - Petersburg\" },\n      { value: \"America/Indiana/Tell_City\", name: \"Indiana - Tell City\" },\n      { value: \"America/Indiana/Vevay\", name: \"Indiana - Vevay\" },\n      { value: \"America/Indiana/Vincennes\", name: \"Indiana - Vincennes\" },\n      { value: \"America/Indiana/Winamac\", name: \"Indiana - Winamac\" },\n      { value: \"America/Indianapolis\", name: \"Indianapolis\" },\n      { value: \"America/Inuvik\", name: \"Inuvik\" },\n      { value: \"America/Iqaluit\", name: \"Iqaluit\" },\n      { value: \"America/Jamaica\", name: \"Jamaica\" },\n      { value: \"America/Jujuy\", name: \"Jujuy\" },\n      { value: \"America/Juneau\", name: \"Juneau\" },\n      { value: \"America/Kentucky/Louisville\", name: \"Kentucky - Louisville\" },\n      { value: \"America/Kentucky/Monticello\", name: \"Kentucky - Monticello\" },\n      { value: \"America/Knox_IN\", name: \"Knox IN\" },\n      { value: \"America/La_Paz\", name: \"La Paz\" },\n      { value: \"America/Lima\", name: \"Lima\" },\n      { value: \"America/Los_Angeles\", name: \"Los Angeles\" },\n      { value: \"America/Louisville\", name: \"Louisville\" },\n      { value: \"America/Maceio\", name: \"Maceio\" },\n      { value: \"America/Managua\", name: \"Managua\" },\n      { value: \"America/Manaus\", name: \"Manaus\" },\n      { value: \"America/Marigot\", name: \"Marigot\" },\n      { value: \"America/Martinique\", name: \"Martinique\" },\n      { value: \"America/Matamoros\", name: \"Matamoros\" },\n      { value: \"America/Mazatlan\", name: \"Mazatlan\" },\n      { value: \"America/Mendoza\", name: \"Mendoza\" },\n      { value: \"America/Menominee\", name: \"Menominee\" },\n      { value: \"America/Merida\", name: \"Merida\" },\n      { value: \"America/Mexico_City\", name: \"Mexico City\" },\n      { value: \"America/Miquelon\", name: \"Miquelon\" },\n      { value: \"America/Moncton\", name: \"Moncton\" },\n      { value: \"America/Monterrey\", name: \"Monterrey\" },\n      { value: \"America/Montevideo\", name: \"Montevideo\" },\n      { value: \"America/Montreal\", name: \"Montreal\" },\n      { value: \"America/Montserrat\", name: \"Montserrat\" },\n      { value: \"America/Nassau\", name: \"Nassau\" },\n      { value: \"America/New_York\", name: \"New York\" },\n      { value: \"America/Nipigon\", name: \"Nipigon\" },\n      { value: \"America/Nome\", name: \"Nome\" },\n      { value: \"America/Noronha\", name: \"Noronha\" },\n      { value: \"America/North_Dakota/Center\", name: \"North Dakota - Center\" },\n      { value: \"America/North_Dakota/New_Salem\", name: \"North Dakota - New Salem\" },\n      { value: \"America/Ojinaga\", name: \"Ojinaga\" },\n      { value: \"America/Panama\", name: \"Panama\" },\n      { value: \"America/Pangnirtung\", name: \"Pangnirtung\" },\n      { value: \"America/Paramaribo\", name: \"Paramaribo\" },\n      { value: \"America/Phoenix\", name: \"Phoenix\" },\n      { value: \"America/Port-au-Prince\", name: \"Port-au-Prince\" },\n      { value: \"America/Porto_Acre\", name: \"Porto Acre\" },\n      { value: \"America/Port_of_Spain\", name: \"Port of Spain\" },\n      { value: \"America/Porto_Velho\", name: \"Porto Velho\" },\n      { value: \"America/Puerto_Rico\", name: \"Puerto Rico\" },\n      { value: \"America/Rainy_River\", name: \"Rainy River\" },\n      { value: \"America/Rankin_Inlet\", name: \"Rankin Inlet\" },\n      { value: \"America/Recife\", name: \"Recife\" },\n      { value: \"America/Regina\", name: \"Regina\" },\n      { value: \"America/Resolute\", name: \"Resolute\" },\n      { value: \"America/Rio_Branco\", name: \"Rio Branco\" },\n      { value: \"America/Rosario\", name: \"Rosario\" },\n      { value: \"America/Santa_Isabel\", name: \"Santa Isabel\" },\n      { value: \"America/Santarem\", name: \"Santarem\" },\n      { value: \"America/Santiago\", name: \"Santiago\" },\n      { value: \"America/Santo_Domingo\", name: \"Santo Domingo\" },\n      { value: \"America/Sao_Paulo\", name: \"Sao Paulo\" },\n      { value: \"America/Scoresbysund\", name: \"Scoresbysund\" },\n      { value: \"America/Shiprock\", name: \"Shiprock\" },\n      { value: \"America/St_Barthelemy\", name: \"St Barthelemy\" },\n      { value: \"America/St_Johns\", name: \"St Johns\" },\n      { value: \"America/St_Kitts\", name: \"St Kitts\" },\n      { value: \"America/St_Lucia\", name: \"St Lucia\" },\n      { value: \"America/St_Thomas\", name: \"St Thomas\" },\n      { value: \"America/St_Vincent\", name: \"St Vincent\" },\n      { value: \"America/Swift_Current\", name: \"Swift Current\" },\n      { value: \"America/Tegucigalpa\", name: \"Tegucigalpa\" },\n      { value: \"America/Thule\", name: \"Thule\" },\n      { value: \"America/Thunder_Bay\", name: \"Thunder Bay\" },\n      { value: \"America/Tijuana\", name: \"Tijuana\" },\n      { value: \"America/Toronto\", name: \"Toronto\" },\n      { value: \"America/Tortola\", name: \"Tortola\" },\n      { value: \"America/Vancouver\", name: \"Vancouver\" },\n      { value: \"America/Virgin\", name: \"Virgin\" },\n      { value: \"America/Whitehorse\", name: \"Whitehorse\" },\n      { value: \"America/Winnipeg\", name: \"Winnipeg\" },\n      { value: \"America/Yakutat\", name: \"Yakutat\" },\n      { value: \"America/Yellowknife\", name: \"Yellowknife\" }\n    ]\n  },\n  {\n    group: \"Europe\",\n    zones: [\n      { value: \"Europe/Amsterdam\", name: \"Amsterdam\" },\n      { value: \"Europe/Andorra\", name: \"Andorra\" },\n      { value: \"Europe/Athens\", name: \"Athens\" },\n      { value: \"Europe/Belfast\", name: \"Belfast\" },\n      { value: \"Europe/Belgrade\", name: \"Belgrade\" },\n      { value: \"Europe/Berlin\", name: \"Berlin\" },\n      { value: \"Europe/Bratislava\", name: \"Bratislava\" },\n      { value: \"Europe/Brussels\", name: \"Brussels\" },\n      { value: \"Europe/Bucharest\", name: \"Bucharest\" },\n      { value: \"Europe/Budapest\", name: \"Budapest\" },\n      { value: \"Europe/Chisinau\", name: \"Chisinau\" },\n      { value: \"Europe/Copenhagen\", name: \"Copenhagen\" },\n      { value: \"Europe/Dublin\", name: \"Dublin\" },\n      { value: \"Europe/Gibraltar\", name: \"Gibraltar\" },\n      { value: \"Europe/Guernsey\", name: \"Guernsey\" },\n      { value: \"Europe/Helsinki\", name: \"Helsinki\" },\n      { value: \"Europe/Isle_of_Man\", name: \"Isle of Man\" },\n      { value: \"Europe/Istanbul\", name: \"Istanbul\" },\n      { value: \"Europe/Jersey\", name: \"Jersey\" },\n      { value: \"Europe/Kaliningrad\", name: \"Kaliningrad\" },\n      { value: \"Europe/Kiev\", name: \"Kiev\" },\n      { value: \"Europe/Lisbon\", name: \"Lisbon\" },\n      { value: \"Europe/Ljubljana\", name: \"Ljubljana\" },\n      { value: \"Europe/London\", name: \"London\" },\n      { value: \"Europe/Luxembourg\", name: \"Luxembourg\" },\n      { value: \"Europe/Madrid\", name: \"Madrid\" },\n      { value: \"Europe/Malta\", name: \"Malta\" },\n      { value: \"Europe/Mariehamn\", name: \"Mariehamn\" },\n      { value: \"Europe/Minsk\", name: \"Minsk\" },\n      { value: \"Europe/Monaco\", name: \"Monaco\" },\n      { value: \"Europe/Moscow\", name: \"Moscow\" },\n      { value: \"Europe/Nicosia\", name: \"Nicosia\" },\n      { value: \"Europe/Oslo\", name: \"Oslo\" },\n      { value: \"Europe/Paris\", name: \"Paris\" },\n      { value: \"Europe/Podgorica\", name: \"Podgorica\" },\n      { value: \"Europe/Prague\", name: \"Prague\" },\n      { value: \"Europe/Riga\", name: \"Riga\" },\n      { value: \"Europe/Rome\", name: \"Rome\" },\n      { value: \"Europe/Samara\", name: \"Samara\" },\n      { value: \"Europe/San_Marino\", name: \"San Marino\" },\n      { value: \"Europe/Sarajevo\", name: \"Sarajevo\" },\n      { value: \"Europe/Simferopol\", name: \"Simferopol\" },\n      { value: \"Europe/Skopje\", name: \"Skopje\" },\n      { value: \"Europe/Sofia\", name: \"Sofia\" },\n      { value: \"Europe/Stockholm\", name: \"Stockholm\" },\n      { value: \"Europe/Tallinn\", name: \"Tallinn\" },\n      { value: \"Europe/Tirane\", name: \"Tirane\" },\n      { value: \"Europe/Tiraspol\", name: \"Tiraspol\" },\n      { value: \"Europe/Uzhgorod\", name: \"Uzhgorod\" },\n      { value: \"Europe/Vaduz\", name: \"Vaduz\" },\n      { value: \"Europe/Vatican\", name: \"Vatican\" },\n      { value: \"Europe/Vienna\", name: \"Vienna\" },\n      { value: \"Europe/Vilnius\", name: \"Vilnius\" },\n      { value: \"Europe/Volgograd\", name: \"Volgograd\" },\n      { value: \"Europe/Warsaw\", name: \"Warsaw\" },\n      { value: \"Europe/Zagreb\", name: \"Zagreb\" },\n      { value: \"Europe/Zaporozhye\", name: \"Zaporozhye\" },\n      { value: \"Europe/Zurich\", name: \"Zurich\" }\n    ]\n  },\n  {\n    group: \"Asia\",\n    zones: [\n      { value: \"Asia/Aden\", name: \"Aden\" },\n      { value: \"Asia/Almaty\", name: \"Almaty\" },\n      { value: \"Asia/Amman\", name: \"Amman\" },\n      { value: \"Asia/Anadyr\", name: \"Anadyr\" },\n      { value: \"Asia/Aqtau\", name: \"Aqtau\" },\n      { value: \"Asia/Aqtobe\", name: \"Aqtobe\" },\n      { value: \"Asia/Ashgabat\", name: \"Ashgabat\" },\n      { value: \"Asia/Ashkhabad\", name: \"Ashkhabad\" },\n      { value: \"Asia/Baghdad\", name: \"Baghdad\" },\n      { value: \"Asia/Bahrain\", name: \"Bahrain\" },\n      { value: \"Asia/Baku\", name: \"Baku\" },\n      { value: \"Asia/Bangkok\", name: \"Bangkok\" },\n      { value: \"Asia/Beirut\", name: \"Beirut\" },\n      { value: \"Asia/Bishkek\", name: \"Bishkek\" },\n      { value: \"Asia/Brunei\", name: \"Brunei\" },\n      { value: \"Asia/Calcutta\", name: \"Calcutta\" },\n      { value: \"Asia/Choibalsan\", name: \"Choibalsan\" },\n      { value: \"Asia/Chongqing\", name: \"Chongqing\" },\n      { value: \"Asia/Chungking\", name: \"Chungking\" },\n      { value: \"Asia/Colombo\", name: \"Colombo\" },\n      { value: \"Asia/Dacca\", name: \"Dacca\" },\n      { value: \"Asia/Damascus\", name: \"Damascus\" },\n      { value: \"Asia/Dhaka\", name: \"Dhaka\" },\n      { value: \"Asia/Dili\", name: \"Dili\" },\n      { value: \"Asia/Dubai\", name: \"Dubai\" },\n      { value: \"Asia/Dushanbe\", name: \"Dushanbe\" },\n      { value: \"Asia/Gaza\", name: \"Gaza\" },\n      { value: \"Asia/Harbin\", name: \"Harbin\" },\n      { value: \"Asia/Ho_Chi_Minh\", name: \"Ho Chi Minh\" },\n      { value: \"Asia/Hong_Kong\", name: \"Hong Kong\" },\n      { value: \"Asia/Hovd\", name: \"Hovd\" },\n      { value: \"Asia/Irkutsk\", name: \"Irkutsk\" },\n      { value: \"Asia/Istanbul\", name: \"Istanbul\" },\n      { value: \"Asia/Jakarta\", name: \"Jakarta\" },\n      { value: \"Asia/Jayapura\", name: \"Jayapura\" },\n      { value: \"Asia/Jerusalem\", name: \"Jerusalem\" },\n      { value: \"Asia/Kabul\", name: \"Kabul\" },\n      { value: \"Asia/Kamchatka\", name: \"Kamchatka\" },\n      { value: \"Asia/Karachi\", name: \"Karachi\" },\n      { value: \"Asia/Kashgar\", name: \"Kashgar\" },\n      { value: \"Asia/Kathmandu\", name: \"Kathmandu\" },\n      { value: \"Asia/Katmandu\", name: \"Katmandu\" },\n      { value: \"Asia/Kolkata\", name: \"Kolkata\" },\n      { value: \"Asia/Krasnoyarsk\", name: \"Krasnoyarsk\" },\n      { value: \"Asia/Kuala_Lumpur\", name: \"Kuala Lumpur\" },\n      { value: \"Asia/Kuching\", name: \"Kuching\" },\n      { value: \"Asia/Kuwait\", name: \"Kuwait\" },\n      { value: \"Asia/Macao\", name: \"Macao\" },\n      { value: \"Asia/Macau\", name: \"Macau\" },\n      { value: \"Asia/Magadan\", name: \"Magadan\" },\n      { value: \"Asia/Makassar\", name: \"Makassar\" },\n      { value: \"Asia/Manila\", name: \"Manila\" },\n      { value: \"Asia/Muscat\", name: \"Muscat\" },\n      { value: \"Asia/Nicosia\", name: \"Nicosia\" },\n      { value: \"Asia/Novokuznetsk\", name: \"Novokuznetsk\" },\n      { value: \"Asia/Novosibirsk\", name: \"Novosibirsk\" },\n      { value: \"Asia/Omsk\", name: \"Omsk\" },\n      { value: \"Asia/Oral\", name: \"Oral\" },\n      { value: \"Asia/Phnom_Penh\", name: \"Phnom Penh\" },\n      { value: \"Asia/Pontianak\", name: \"Pontianak\" },\n      { value: \"Asia/Pyongyang\", name: \"Pyongyang\" },\n      { value: \"Asia/Qatar\", name: \"Qatar\" },\n      { value: \"Asia/Qyzylorda\", name: \"Qyzylorda\" },\n      { value: \"Asia/Rangoon\", name: \"Rangoon\" },\n      { value: \"Asia/Riyadh\", name: \"Riyadh\" },\n      { value: \"Asia/Saigon\", name: \"Saigon\" },\n      { value: \"Asia/Sakhalin\", name: \"Sakhalin\" },\n      { value: \"Asia/Samarkand\", name: \"Samarkand\" },\n      { value: \"Asia/Seoul\", name: \"Seoul\" },\n      { value: \"Asia/Shanghai\", name: \"Shanghai\" },\n      { value: \"Asia/Singapore\", name: \"Singapore\" },\n      { value: \"Asia/Taipei\", name: \"Taipei\" },\n      { value: \"Asia/Tashkent\", name: \"Tashkent\" },\n      { value: \"Asia/Tbilisi\", name: \"Tbilisi\" },\n      { value: \"Asia/Tehran\", name: \"Tehran\" },\n      { value: \"Asia/Tel_Aviv\", name: \"Tel Aviv\" },\n      { value: \"Asia/Thimbu\", name: \"Thimbu\" },\n      { value: \"Asia/Thimphu\", name: \"Thimphu\" },\n      { value: \"Asia/Tokyo\", name: \"Tokyo\" },\n      { value: \"Asia/Ujung_Pandang\", name: \"Ujung Pandang\" },\n      { value: \"Asia/Ulaanbaatar\", name: \"Ulaanbaatar\" },\n      { value: \"Asia/Ulan_Bator\", name: \"Ulan Bator\" },\n      { value: \"Asia/Urumqi\", name: \"Urumqi\" },\n      { value: \"Asia/Vientiane\", name: \"Vientiane\" },\n      { value: \"Asia/Vladivostok\", name: \"Vladivostok\" },\n      { value: \"Asia/Yakutsk\", name: \"Yakutsk\" },\n      { value: \"Asia/Yekaterinburg\", name: \"Yekaterinburg\" },\n      { value: \"Asia/Yerevan\", name: \"Yerevan\" }\n    ]\n  },\n  {\n    group: \"Africa\",\n    zones: [\n      { value: \"Africa/Abidjan\", name: \"Abidjan\" },\n      { value: \"Africa/Accra\", name: \"Accra\" },\n      { value: \"Africa/Addis_Ababa\", name: \"Addis Ababa\" },\n      { value: \"Africa/Algiers\", name: \"Algiers\" },\n      { value: \"Africa/Asmara\", name: \"Asmara\" },\n      { value: \"Africa/Asmera\", name: \"Asmera\" },\n      { value: \"Africa/Bamako\", name: \"Bamako\" },\n      { value: \"Africa/Bangui\", name: \"Bangui\" },\n      { value: \"Africa/Banjul\", name: \"Banjul\" },\n      { value: \"Africa/Bissau\", name: \"Bissau\" },\n      { value: \"Africa/Blantyre\", name: \"Blantyre\" },\n      { value: \"Africa/Brazzaville\", name: \"Brazzaville\" },\n      { value: \"Africa/Bujumbura\", name: \"Bujumbura\" },\n      { value: \"Africa/Cairo\", name: \"Cairo\" },\n      { value: \"Africa/Casablanca\", name: \"Casablanca\" },\n      { value: \"Africa/Ceuta\", name: \"Ceuta\" },\n      { value: \"Africa/Conakry\", name: \"Conakry\" },\n      { value: \"Africa/Dakar\", name: \"Dakar\" },\n      { value: \"Africa/Dar_es_Salaam\", name: \"Dar es Salaam\" },\n      { value: \"Africa/Djibouti\", name: \"Djibouti\" },\n      { value: \"Africa/Douala\", name: \"Douala\" },\n      { value: \"Africa/El_Aaiun\", name: \"El Aaiun\" },\n      { value: \"Africa/Freetown\", name: \"Freetown\" },\n      { value: \"Africa/Gaborone\", name: \"Gaborone\" },\n      { value: \"Africa/Harare\", name: \"Harare\" },\n      { value: \"Africa/Johannesburg\", name: \"Johannesburg\" },\n      { value: \"Africa/Kampala\", name: \"Kampala\" },\n      { value: \"Africa/Khartoum\", name: \"Khartoum\" },\n      { value: \"Africa/Kigali\", name: \"Kigali\" },\n      { value: \"Africa/Kinshasa\", name: \"Kinshasa\" },\n      { value: \"Africa/Lagos\", name: \"Lagos\" },\n      { value: \"Africa/Libreville\", name: \"Libreville\" },\n      { value: \"Africa/Lome\", name: \"Lome\" },\n      { value: \"Africa/Luanda\", name: \"Luanda\" },\n      { value: \"Africa/Lubumbashi\", name: \"Lubumbashi\" },\n      { value: \"Africa/Lusaka\", name: \"Lusaka\" },\n      { value: \"Africa/Malabo\", name: \"Malabo\" },\n      { value: \"Africa/Maputo\", name: \"Maputo\" },\n      { value: \"Africa/Maseru\", name: \"Maseru\" },\n      { value: \"Africa/Mbabane\", name: \"Mbabane\" },\n      { value: \"Africa/Mogadishu\", name: \"Mogadishu\" },\n      { value: \"Africa/Monrovia\", name: \"Monrovia\" },\n      { value: \"Africa/Nairobi\", name: \"Nairobi\" },\n      { value: \"Africa/Ndjamena\", name: \"Ndjamena\" },\n      { value: \"Africa/Niamey\", name: \"Niamey\" },\n      { value: \"Africa/Nouakchott\", name: \"Nouakchott\" },\n      { value: \"Africa/Ouagadougou\", name: \"Ouagadougou\" },\n      { value: \"Africa/Porto-Novo\", name: \"Porto-Novo\" },\n      { value: \"Africa/Sao_Tome\", name: \"Sao Tome\" },\n      { value: \"Africa/Timbuktu\", name: \"Timbuktu\" },\n      { value: \"Africa/Tripoli\", name: \"Tripoli\" },\n      { value: \"Africa/Tunis\", name: \"Tunis\" },\n      { value: \"Africa/Windhoek\", name: \"Windhoek\" }\n    ]\n  },\n  {\n    group: \"Australia\",\n    zones: [\n      { value: \"Australia/ACT\", name: \"ACT\" },\n      { value: \"Australia/Adelaide\", name: \"Adelaide\" },\n      { value: \"Australia/Brisbane\", name: \"Brisbane\" },\n      { value: \"Australia/Broken_Hill\", name: \"Broken Hill\" },\n      { value: \"Australia/Canberra\", name: \"Canberra\" },\n      { value: \"Australia/Currie\", name: \"Currie\" },\n      { value: \"Australia/Darwin\", name: \"Darwin\" },\n      { value: \"Australia/Eucla\", name: \"Eucla\" },\n      { value: \"Australia/Hobart\", name: \"Hobart\" },\n      { value: \"Australia/LHI\", name: \"LHI\" },\n      { value: \"Australia/Lindeman\", name: \"Lindeman\" },\n      { value: \"Australia/Lord_Howe\", name: \"Lord Howe\" },\n      { value: \"Australia/Melbourne\", name: \"Melbourne\" },\n      { value: \"Australia/North\", name: \"North\" },\n      { value: \"Australia/NSW\", name: \"NSW\" },\n      { value: \"Australia/Perth\", name: \"Perth\" },\n      { value: \"Australia/Queensland\", name: \"Queensland\" },\n      { value: \"Australia/South\", name: \"South\" },\n      { value: \"Australia/Sydney\", name: \"Sydney\" },\n      { value: \"Australia/Tasmania\", name: \"Tasmania\" },\n      { value: \"Australia/Victoria\", name: \"Victoria\" },\n      { value: \"Australia/West\", name: \"West\" },\n      { value: \"Australia/Yancowinna\", name: \"Yancowinna\" }\n    ]\n  },\n  {\n    group: \"Indian\",\n    zones: [\n      { value: \"Indian/Antananarivo\", name: \"Antananarivo\" },\n      { value: \"Indian/Chagos\", name: \"Chagos\" },\n      { value: \"Indian/Christmas\", name: \"Christmas\" },\n      { value: \"Indian/Cocos\", name: \"Cocos\" },\n      { value: \"Indian/Comoro\", name: \"Comoro\" },\n      { value: \"Indian/Kerguelen\", name: \"Kerguelen\" },\n      { value: \"Indian/Mahe\", name: \"Mahe\" },\n      { value: \"Indian/Maldives\", name: \"Maldives\" },\n      { value: \"Indian/Mauritius\", name: \"Mauritius\" },\n      { value: \"Indian/Mayotte\", name: \"Mayotte\" },\n      { value: \"Indian/Reunion\", name: \"Reunion\" }\n    ]\n  },\n  {\n    group: \"Atlantic\",\n    zones: [\n      { value: \"Atlantic/Azores\", name: \"Azores\" },\n      { value: \"Atlantic/Bermuda\", name: \"Bermuda\" },\n      { value: \"Atlantic/Canary\", name: \"Canary\" },\n      { value: \"Atlantic/Cape_Verde\", name: \"Cape Verde\" },\n      { value: \"Atlantic/Faeroe\", name: \"Faeroe\" },\n      { value: \"Atlantic/Faroe\", name: \"Faroe\" },\n      { value: \"Atlantic/Jan_Mayen\", name: \"Jan Mayen\" },\n      { value: \"Atlantic/Madeira\", name: \"Madeira\" },\n      { value: \"Atlantic/Reykjavik\", name: \"Reykjavik\" },\n      { value: \"Atlantic/South_Georgia\", name: \"South Georgia\" },\n      { value: \"Atlantic/Stanley\", name: \"Stanley\" },\n      { value: \"Atlantic/St_Helena\", name: \"St Helena\" }\n    ]\n  },\n  {\n    group: \"Pacific\",\n    zones: [\n      { value: \"Pacific/Apia\", name: \"Apia\" },\n      { value: \"Pacific/Auckland\", name: \"Auckland\" },\n      { value: \"Pacific/Chatham\", name: \"Chatham\" },\n      { value: \"Pacific/Easter\", name: \"Easter\" },\n      { value: \"Pacific/Efate\", name: \"Efate\" },\n      { value: \"Pacific/Enderbury\", name: \"Enderbury\" },\n      { value: \"Pacific/Fakaofo\", name: \"Fakaofo\" },\n      { value: \"Pacific/Fiji\", name: \"Fiji\" },\n      { value: \"Pacific/Funafuti\", name: \"Funafuti\" },\n      { value: \"Pacific/Galapagos\", name: \"Galapagos\" },\n      { value: \"Pacific/Gambier\", name: \"Gambier\" },\n      { value: \"Pacific/Guadalcanal\", name: \"Guadalcanal\" },\n      { value: \"Pacific/Guam\", name: \"Guam\" },\n      { value: \"Pacific/Honolulu\", name: \"Honolulu\" },\n      { value: \"Pacific/Johnston\", name: \"Johnston\" },\n      { value: \"Pacific/Kiritimati\", name: \"Kiritimati\" },\n      { value: \"Pacific/Kosrae\", name: \"Kosrae\" },\n      { value: \"Pacific/Kwajalein\", name: \"Kwajalein\" },\n      { value: \"Pacific/Majuro\", name: \"Majuro\" },\n      { value: \"Pacific/Marquesas\", name: \"Marquesas\" },\n      { value: \"Pacific/Midway\", name: \"Midway\" },\n      { value: \"Pacific/Nauru\", name: \"Nauru\" },\n      { value: \"Pacific/Niue\", name: \"Niue\" },\n      { value: \"Pacific/Norfolk\", name: \"Norfolk\" },\n      { value: \"Pacific/Noumea\", name: \"Noumea\" },\n      { value: \"Pacific/Pago_Pago\", name: \"Pago Pago\" },\n      { value: \"Pacific/Palau\", name: \"Palau\" },\n      { value: \"Pacific/Pitcairn\", name: \"Pitcairn\" },\n      { value: \"Pacific/Ponape\", name: \"Ponape\" },\n      { value: \"Pacific/Port_Moresby\", name: \"Port Moresby\" },\n      { value: \"Pacific/Rarotonga\", name: \"Rarotonga\" },\n      { value: \"Pacific/Saipan\", name: \"Saipan\" },\n      { value: \"Pacific/Samoa\", name: \"Samoa\" },\n      { value: \"Pacific/Tahiti\", name: \"Tahiti\" },\n      { value: \"Pacific/Tarawa\", name: \"Tarawa\" },\n      { value: \"Pacific/Tongatapu\", name: \"Tongatapu\" },\n      { value: \"Pacific/Truk\", name: \"Truk\" },\n      { value: \"Pacific/Wake\", name: \"Wake\" },\n      { value: \"Pacific/Wallis\", name: \"Wallis\" },\n      { value: \"Pacific/Yap\", name: \"Yap\" }\n    ]\n  },\n  {\n    group: \"Antarctica\",\n    zones: [\n      { value: \"Antarctica/Casey\", name: \"Casey\" },\n      { value: \"Antarctica/Davis\", name: \"Davis\" },\n      { value: \"Antarctica/DumontDUrville\", name: \"DumontDUrville\" },\n      { value: \"Antarctica/Macquarie\", name: \"Macquarie\" },\n      { value: \"Antarctica/Mawson\", name: \"Mawson\" },\n      { value: \"Antarctica/McMurdo\", name: \"McMurdo\" },\n      { value: \"Antarctica/Palmer\", name: \"Palmer\" },\n      { value: \"Antarctica/Rothera\", name: \"Rothera\" },\n      { value: \"Antarctica/South_Pole\", name: \"South Pole\" },\n      { value: \"Antarctica/Syowa\", name: \"Syowa\" },\n      { value: \"Antarctica/Vostok\", name: \"Vostok\" }\n    ]\n  },\n  {\n    group: \"Arctic\",\n    zones: [{ value: \"Arctic/Longyearbyen\", name: \"Longyearbyen\" }]\n  },\n  {\n    group: \"UTC\",\n    zones: [{ value: \"UTC\", name: \"UTC\" }]\n  },\n  {\n    group: \"Manual Offsets\",\n    zones: [\n      { value: \"UTC-12\", name: \"UTC-12\" },\n      { value: \"UTC-11\", name: \"UTC-11\" },\n      { value: \"UTC-10\", name: \"UTC-10\" },\n      { value: \"UTC-9\", name: \"UTC-9\" },\n      { value: \"UTC-8\", name: \"UTC-8\" },\n      { value: \"UTC-7\", name: \"UTC-7\" },\n      { value: \"UTC-6\", name: \"UTC-6\" },\n      { value: \"UTC-5\", name: \"UTC-5\" },\n      { value: \"UTC-4\", name: \"UTC-4\" },\n      { value: \"UTC-3\", name: \"UTC-3\" },\n      { value: \"UTC-2\", name: \"UTC-2\" },\n      { value: \"UTC-1\", name: \"UTC-1\" },\n      { value: \"UTC+0\", name: \"UTC+0\" },\n      { value: \"UTC+1\", name: \"UTC+1\" },\n      { value: \"UTC+2\", name: \"UTC+2\" },\n      { value: \"UTC+3\", name: \"UTC+3\" },\n      { value: \"UTC+4\", name: \"UTC+4\" },\n      { value: \"UTC+5\", name: \"UTC+5\" },\n      { value: \"UTC+6\", name: \"UTC+6\" },\n      { value: \"UTC+7\", name: \"UTC+7\" },\n      { value: \"UTC+8\", name: \"UTC+8\" },\n      { value: \"UTC+9\", name: \"UTC+9\" },\n      { value: \"UTC+10\", name: \"UTC+10\" },\n      { value: \"UTC+11\", name: \"UTC+11\" },\n      { value: \"UTC+12\", name: \"UTC+12\" },\n      { value: \"UTC+13\", name: \"UTC+13\" },\n      { value: \"UTC+14\", name: \"UTC+14\" }\n    ]\n  }\n], $t = () => {\n  var n, e;\n  return ((e = (n = nn.find((a) => a.group === \"America\")) == null ? void 0 : n.zones) != null ? e : []).map((a) => a.value);\n}, Ut = () => nn.reduce((n, e) => [...n, ...e.zones.map((a) => a.value)], []), _t = () => {\n  var n, e;\n  return ((e = (n = nn.find((a) => a.group === \"US (Common)\")) == null ? void 0 : n.zones) != null ? e : []).map((a) => a.value);\n};\nfunction Oa(n, e) {\n  var r, t;\n  const a = (r = A(n, { timezoneSource: e != null ? e : void 0 })) != null ? r : /* @__PURE__ */ new Date();\n  try {\n    return (t = a.toLocaleDateString(void 0, { timeZoneName: \"short\", timeZone: e != null ? e : void 0 }).split(\",\").map((u) => u.trim()).at(1)) != null ? t : null;\n  } catch (i) {\n    return console.warn(\"Invalid timezone identifier (IANAZoneAbbrNull): \" + (e != null ? e : \"(NONE)\")), null;\n  }\n}\nfunction Lt(n, e) {\n  var r, t;\n  const a = (r = A(n, { timezoneSource: e != null ? e : void 0 })) != null ? r : /* @__PURE__ */ new Date();\n  try {\n    const i = a.toLocaleDateString(void 0, { timeZoneName: \"short\", timeZone: e != null ? e : void 0 });\n    return (t = i.split(\",\").map((u) => u.trim()).at(1)) != null ? t : i;\n  } catch (i) {\n    return console.warn(\"Invalid timezone identifier (IANAZoneAbbr): \" + (e != null ? e : \"(NONE)\")), \"\";\n  }\n}\nfunction Ft(n, e) {\n  var t, i;\n  if (!n)\n    return null;\n  const a = Oa((t = e == null ? void 0 : e.forDate) != null ? t : \"2020-01-01\", n);\n  return e != null && e.hideIANA && a ? a : `${T(\"_\", \" \", e != null && e.removePrefix ? (i = n.split(\"/\").at(1)) != null ? i : \"\" : n)}${a ? ` (${a})` : \"\"}`;\n}\nfunction Pt(n) {\n  const e = n % 19, a = Math.floor(n / 100), r = n % 100, t = Math.floor(a / 4), i = a % 4, u = Math.floor((a + 8) / 25), l = Math.floor((a - u + 1) / 3), o = (19 * e + a - t - l + 15) % 30, s = Math.floor(r / 4), m = r % 4, g = (32 + 2 * i + 2 * s - o - m) % 7, h = Math.floor((e + 11 * o + 22 * g) / 451), S = Math.floor((o + g - 7 * h + 114) / 31), M = (o + g - 7 * h + 114) % 31, I = S, N = M + 1;\n  return ie(`${n}-${I}-${N}`);\n}\nconst T = function(n, e, a) {\n  if (!a)\n    return \"\";\n  if (Array.isArray(n)) {\n    let r = a;\n    for (const t of n)\n      r = T(t, e, r);\n    return r;\n  }\n  return a.replace(new RegExp(n.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\"), \"g\"), e);\n}, Bt = function(n, e) {\n  if (!n || !n.length)\n    return \"\";\n  const a = H(n);\n  let r = e != null ? e : \"\";\n  for (const t of a)\n    Array.isArray(t) ? r = T(t[0], t[1], r) : r = T(Object.keys(t)[0], Object.values(t)[0], r);\n  return r;\n};\nfunction Na(n) {\n  const e = f(n, void 0, !0);\n  return e !== null && !isNaN(e);\n}\nfunction xt(n) {\n  return Na(n) && f(n, 0) === f(n, 8);\n}\nfunction Ea(n, e, a = 2) {\n  return E(n) === null ? null : e == 0 ? f(n, 0) : f(Math.round(f(n) / f(e)) * f(e), a);\n}\nfunction Rt(n, e, a = 2) {\n  var r;\n  return (r = Ea(n, e, a)) != null ? r : 0;\n}\nconst f = (n, e, a) => {\n  if (typeof n == \"number\")\n    return e !== void 0 ? Ze(n, e) : n;\n  if (!n)\n    return 0;\n  if (e === void 0) {\n    const t = +n;\n    if (!Number.isNaN(t))\n      return t;\n  }\n  let r = n.toString();\n  return r = T(\"$\", \"\", r), r = T('\"', \"\", r), r = T(\"'\", \"\", r), r = T(\",\", \"\", r), r = T(\"%\", \"\", r), r.trim().length === 0 || isNaN(r) ? a ? NaN : 0 : e !== void 0 ? Ze(parseFloat(r), e) : parseFloat(r);\n}, Yt = (n, e, a = 2) => E(n, a) !== null && E(n, a) === E(e, a);\nfunction Ht(n) {\n  let e = f(n, 8).toString(), a = e.indexOf(\".\");\n  return a === -1 ? 0 : e.length - a - 1;\n}\nconst Ia = (...n) => fe(n).reduce(\n  (e, a) => e === null || a > e ? a : e,\n  null\n), an = (...n) => {\n  var e;\n  return (e = Ia(...n)) != null ? e : 0;\n}, pa = (...n) => fe(n).reduce(\n  (e, a) => e === null || a < e ? a : e,\n  null\n), On = (...n) => {\n  var e;\n  return (e = pa(...n)) != null ? e : 0;\n}, fe = (...n) => {\n  let e = [];\n  for (const a of n) {\n    const r = H(a);\n    for (const t of r) {\n      const i = H(t);\n      for (const u of i) {\n        const l = E(u);\n        l !== null && (e = [...e, l]);\n      }\n    }\n  }\n  return e;\n}, $a = (n, ...e) => {\n  const a = fe(e);\n  return a.length === 0 ? null : f(Nn(n, a) / a.length, n);\n}, Wt = (n, ...e) => {\n  var a;\n  return (a = $a(n, ...e)) != null ? a : 0;\n};\nfunction zt(...n) {\n  const e = fe(n);\n  if (e.length === 0)\n    return null;\n  {\n    const a = e.sort((t, i) => t - i), r = Math.floor(a.length / 2);\n    return f(a[r]);\n  }\n}\nconst Ua = (n, e, a) => {\n  const r = E(n);\n  if (r === null)\n    return null;\n  const t = f(e);\n  return t === 0 ? null : a !== void 0 ? f(f(r) / t, a + 2) : f(r) / t;\n}, _a = (n, e, a) => {\n  var r;\n  return (r = Ua(n, e, a)) != null ? r : 0;\n}, Nn = (n, ...e) => fe(e).reduce((a, r) => f(a + r, n), 0), La = (n, ...e) => fe(e).reduce(\n  (a, r, t) => t ? f(a - r, n) : r,\n  0\n), E = (n, e) => {\n  if (n == null || n === \"\")\n    return null;\n  let a = f(n, e, !0);\n  return isNaN(a) ? null : a;\n}, Ve = (n) => {\n  if (!n)\n    return null;\n  if (typeof n == \"object\")\n    return n;\n  let e = null;\n  try {\n    e = JSON.parse(n);\n  } catch (a) {\n    return null;\n  }\n  return e;\n}, Gt = (n, e) => n.length > e ? n.substring(0, e - 1) + \"&hellip;\" : n, Kt = (n, e = \"\") => {\n  var t, i;\n  const a = (t = n[e + \"latitude\"]) != null ? t : \"\";\n  let r = (i = n[e + \"longitude\"]) != null ? i : \"\";\n  return \"http://maps.google.com/maps?q=\" + a + \",\" + r;\n}, Vt = (n, e = \"\") => {\n  var r, t, i, u, l, o, s;\n  if (!n || !((r = n[e + \"address1\"]) != null ? r : n[e + \"address_1\"]) || !n[e + \"zip\"])\n    return \"\";\n  let a = ((i = (t = n[e + \"address1\"]) != null ? t : n[e + \"address_1\"]) != null ? i : \"\") + \" \";\n  return (n[e + \"address2\"] || n[e + \"address_2\"]) && (a += ((u = n[e + \"address2\"]) != null ? u : n[e + \"address_2\"]) + \" \"), a += ((l = n[e + \"city\"]) != null ? l : \"\") + \", \", a += ((o = n[e + \"state\"]) != null ? o : \"\") + \" \", a += (s = n[e + \"zip\"]) != null ? s : \"\", \"https://www.google.com/maps/search/?api=1&query=\" + encodeURI(a);\n};\nfunction Zt(n, e, a = \"\", r = \"\") {\n  if (!n || !e)\n    return \"\";\n  const t = (s, m) => {\n    var g, h;\n    return !s || !((g = s[m + \"address1\"]) != null ? g : s[m + \"address_1\"]) || !s[m + \"zip\"] ? \"\" : `${(h = s[m + \"address1\"]) != null ? h : s[m + \"address_1\"]}, ${s[m + \"city\"]}, ${s[m + \"state\"]} ${s[m + \"zip\"]}`;\n  }, i = t(n, a);\n  if (!i)\n    return \"\";\n  const u = encodeURIComponent(i), l = t(e, r);\n  if (!l)\n    return \"\";\n  const o = encodeURIComponent(l);\n  return `https://www.google.com/maps/dir/?api=1&origin=${u}&destination=${o}`;\n}\nconst qt = (n) => {\n  const e = new RegExp(\"^\\\\d{1,}(\\\\.\\\\d{0,4})?$\");\n  return !n || e.test(n);\n}, Fa = () => {\n  let n = (/* @__PURE__ */ new Date()).getTime(), e = performance && performance.now && performance.now() * 1e3 || 0;\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(a) {\n    let r = Math.random() * 16;\n    return n > 0 ? (r = (n + r) % 16 | 0, n = Math.floor(n / 16)) : (r = (e + r) % 16 | 0, e = Math.floor(e / 16)), (a === \"x\" ? r : r & 11).toString(16);\n  });\n}, x = (n, e) => {\n  var t, i;\n  if (!n)\n    return !1;\n  if (n === !0)\n    return n;\n  const a = E(n);\n  if (a !== null)\n    return a > 0;\n  let r = n.toString().toLowerCase().trim();\n  return !((t = e == null ? void 0 : e.nos) != null ? t : []).some((u) => u.toString().toLowerCase().trim() === r) && [\"true\", \"active\", \"on\", \"yes\", \"y\", \"t\", ...(i = e == null ? void 0 : e.yeses) != null ? i : []].some(\n    (u) => u.toString().toLowerCase().trim() === r\n  );\n}, Jt = (n, e, a, r, t = !0, i = !0, u = !0, l = !0) => {\n  t && n[e + \"name\"] && (a[r + \"name\"] = n[e + \"name\"]), a[r + \"address_1\"] = n[e + \"address_1\"], a[r + \"address_2\"] = n[e + \"address_2\"], a[r + \"city\"] = n[e + \"city\"], a[r + \"state\"] = n[e + \"state\"], a[r + \"zip\"] = n[e + \"zip\"], i && n[e + \"phone\"] && (a[r + \"phone\"] = n[e + \"phone\"]), u && n[e + \"timezone\"] && (a[r + \"timezone\"] = n[e + \"timezone\"]), l && n[e + \"latitude\"] && (a[r + \"latitude\"] = n[e + \"latitude\"]), l && n[e + \"longitude\"] && (a[r + \"longitude\"] = n[e + \"longitude\"]);\n}, Qt = (n, e) => !!n[(e != null ? e : \"\") + \"address_1\"], Xt = (n, e) => {\n  var t, i, u, l, o;\n  const a = e != null ? e : \"\";\n  let r = ((t = n[a + \"address_1\"]) != null ? t : \"\").trim();\n  return (i = n[a + \"address_2\"]) != null && i && (r += \", \" + n[a + \"address_2\"]), (u = n[a + \"city\"]) != null && u && (r += \", \" + n[a + \"city\"]), (l = n[a + \"state\"]) != null && l && (r += \", \" + n[a + \"state\"]), (o = n[a + \"zip\"]) != null && o && (r += \"  \" + Dn(n[a + \"zip\"])), r;\n}, jt = (n, e) => {\n  var t, i, u, l, o;\n  const a = e != null ? e : \"\";\n  let r = ((t = n[a + \"address_1\"]) != null ? t : \"\").trim();\n  return n[a + \"address_2\"] && (r += `\n` + ((i = n[a + \"address_2\"]) != null ? i : \"\").trim()), (u = n[a + \"city\"]) != null && u && (r += `\n` + n[a + \"city\"]), (l = n[a + \"state\"]) != null && l && (r += \", \" + n[a + \"state\"]), (o = n[a + \"zip\"]) != null && o && (r += \"  \" + Dn(n[a + \"zip\"])), r;\n}, ei = (n) => Array.from(n, function(e) {\n  return (\"0\" + (e & 255).toString(16)).slice(-2);\n}).join(\"\").replace(/(.{8})(.{4})(.{4})(.{4})(.{12})/, \"$1-$2-$3-$4-$5\"), ni = (n) => {\n  let e = atob(n), a, r = e.length, t = new Uint8Array(r);\n  for (a = 0; a < r; ++a)\n    t[a] = e.charCodeAt(a);\n  return t;\n}, ai = (n) => Object.keys(n).reduce((e, a) => e + `&${a}=${encodeURIComponent(n[a])}`, \"\"), Ze = (n, e = 0, a = \"round\") => a === \"round\" ? +Math.round((f(n) + Number.EPSILON) * ne(10, e)) / ne(10, e) : a === \"down\" ? +Math.floor((f(n) + Number.EPSILON) * ne(10, e)) / ne(10, e) : +Math.ceil((f(n) + Number.EPSILON) * ne(10, e)) / ne(10, e), ri = (n) => `json:${JSON.stringify(n)}`, ti = (n) => n ? n === \"json:undefined\" ? void 0 : n === \"json:null\" ? null : Ve(n.toString().substring(5)) : void 0, Pa = (n) => n instanceof new Uint16Array().constructor.prototype.__proto__.constructor, ii = (n) => Pa(n) ? String.fromCharCode.apply(null, new Uint16Array(n)) : n, ui = (n) => {\n  let e = new ArrayBuffer(n.length * 2), a = new Uint16Array(e);\n  for (var r = 0, t = n.length; r < t; r++)\n    a[r] = n.charCodeAt(r);\n  return e;\n}, oi = (n, e) => ae(void 0, null, function* () {\n  for (const a of n)\n    if (yield e(a))\n      return a;\n}), li = (n, e) => ae(void 0, null, function* () {\n  for (const a of n)\n    if (yield e(a))\n      return !0;\n  return !1;\n}), si = (n, e) => ae(void 0, null, function* () {\n  for (const a of n)\n    if (!(yield e(a)))\n      return !1;\n  return !0;\n}), ci = (n, e) => ae(void 0, null, function* () {\n  let a = [];\n  for (const r of n)\n    (yield e(r)) && a.push(r);\n  return a;\n}), H = (n) => n == null ? [] : Array.isArray(n) ? n : [n], mi = (n, e = 1, a = 0) => {\n  const r = n > a ? e > 0 ? e : an(e * -1, 1) : e < 0 ? e : On(e * -1, -1);\n  let t = [], i = a;\n  for (; r > 0 ? n > i : n < i; )\n    t.push(i), i += r;\n  return t;\n}, fi = (n, e = \"\") => {\n  const a = `,; :.'\"\\`|*\t\\r\n`.split(\"\").filter((t) => !e.includes(t)).join(\"\"), r = new RegExp(`[${a}]`, \"g\");\n  return n.split(r).filter((t) => t.trim().length > 0);\n}, gi = (n, ...e) => e.every((a) => a in n), hi = (n, ...e) => e.every((a) => a in n && !!n[a]);\nfunction qe(n, ...e) {\n  let a = D({}, n);\n  for (let r of e)\n    delete a[r];\n  return a;\n}\nfunction di(n, ...e) {\n  let a = D({}, n);\n  const r = new Set(e);\n  for (let t in n)\n    r.has(t) && !a[t] && delete a[t];\n  return a;\n}\nfunction Ai(n) {\n  let e = D({}, n);\n  for (let a in n)\n    a in n && e[a] === void 0 && delete e[a];\n  return e;\n}\nfunction Si(n, ...e) {\n  let a = {};\n  for (let r of e)\n    r in n && (a[r] = n[r]);\n  return a;\n}\nfunction yi(n, e) {\n  let a = [];\n  const r = H(e).map((t) => t == null ? void 0 : t.toString().toLowerCase().trim()).filter((t) => !!t);\n  if (n && r.length) {\n    const t = Object.keys(n);\n    for (const i of r)\n      for (const u of t)\n        u.toLowerCase().trim() === i && a.push(n[u]);\n  }\n  if (a.length) {\n    const t = a.findIndex((i) => !!i && !!i.toString().trim().length);\n    return t >= 0 ? a[t] : a[0];\n  }\n}\nfunction vi(n, e, a = !1) {\n  if (!e || !n)\n    return \"\";\n  const r = H(n);\n  let t = e;\n  do\n    for (const i of r)\n      t.startsWith(i) && (t = t.substring(i.length));\n  while (a && r.some((i) => t.startsWith(i)));\n  return t;\n}\nfunction Di(n, e, a = !1) {\n  if (!e || !n)\n    return \"\";\n  const r = H(n);\n  let t = e;\n  do\n    for (const i of r)\n      t.endsWith(i) && (t = t.substring(0, t.length - i.length));\n  while (a && r.some((i) => t.endsWith(i)));\n  return t;\n}\nfunction Ti(n, ...e) {\n  if (n || e.length === 0)\n    return n;\n  for (const a of e)\n    if (a)\n      return a;\n  return e[e.length - 1];\n}\nconst En = (n, e, a) => n * 0.299 + e * 0.587 + a * 0.114, In = (n) => (n.indexOf(\"#\") === 0 && (n = n.slice(1)), n.length === 3 && (n = n[0] + n[0] + n[1] + n[1] + n[2] + n[2]), n.length !== 6 ? [0, 0, 0] : [parseInt(n.slice(0, 2), 16), parseInt(n.slice(2, 4), 16), parseInt(n.slice(4, 6), 16)]), Mi = (n) => {\n  const [e, a, r] = In(n);\n  return En(e, a, r);\n};\nfunction Ba(n, e, a, r = !1) {\n  if (r)\n    return En(n, e, a) > 186 ? \"#000000\" : \"#FFFFFF\";\n  const t = (255 - n).toString(16), i = (255 - e).toString(16), u = (255 - a).toString(16);\n  return \"#\" + t.padStart(2, \"0\") + i.padStart(2, \"0\") + u.padStart(2, \"0\");\n}\nfunction Ci(n, e = !1) {\n  const [a, r, t] = In(n);\n  return Ba(a, r, t, e);\n}\nfunction bi(n = 200) {\n  return new Promise((e) => setTimeout(e, n));\n}\nfunction wi(n, e) {\n  return ae(this, null, function* () {\n    const a = /* @__PURE__ */ new Date(), r = yield e;\n    return console.log(n, Ta(a, \"now\")), r;\n  });\n}\nfunction ki(n, e) {\n  return Object.keys(n).reduce((a, r) => (a[`${e}${r}`] = n[r], a), {});\n}\nfunction Oi(n, e) {\n  const a = {};\n  for (const r in n)\n    r.startsWith(e) && (a[r.slice(e.length)] = n[r]);\n  return a;\n}\nfunction Ni(n) {\n  const e = f(n, 5), a = n < 0 ? Math.ceil(e) : Math.floor(e), r = La(5, n, a);\n  return {\n    whole: a,\n    decimal: r\n  };\n}\nfunction Ei(n, e, a = 2) {\n  if (n === 0 || e.some((o) => o < 0) || !e.some((o) => !!o))\n    return [];\n  let r = e.reduce((o, s) => o + s, 0), t = e.map((o) => _a(o, r) * 100), i = [], u = e.reverse().findIndex((o) => o !== 0);\n  u = u < 0 ? 0 : e.length - 1 - u;\n  let l = n;\n  return t.forEach((o, s) => {\n    let m = parseFloat((n * (o / 100)).toFixed(a));\n    l -= m, s === u && (m = Nn(a, l, m)), i.push({ percentage: o, amount: m });\n  }), i;\n}\nfunction xa(n, e, a) {\n  var h, S, M, I, N;\n  const r = [], t = (h = a == null ? void 0 : a.startHue) != null ? h : e, i = (S = a == null ? void 0 : a.startSaturation) != null ? S : 30, u = (M = a == null ? void 0 : a.endSaturation) != null ? M : 80, l = (I = a == null ? void 0 : a.startLightness) != null ? I : 30, o = (N = a == null ? void 0 : a.endLightness) != null ? N : 60, s = (e - t) / (n - 1), m = (u - i) / (n - 1), g = (o - l) / (n - 1);\n  for (let O = 0; O < n; O++) {\n    const d = f(t + s * O), c = f(i + m * O), C = f(l + g * O), U = `hsl(${d}, ${c}%, ${C}%)`;\n    r.push(U);\n  }\n  return r.sort(() => a != null && a.randomize ? Math.random() - 0.5 : 0);\n}\nfunction Ii(n, e) {\n  var a, r, t, i, u, l, o;\n  return xa(n, (a = e == null ? void 0 : e.endHue) != null ? a : 360, {\n    startHue: (r = e == null ? void 0 : e.startHue) != null ? r : 0,\n    startSaturation: (t = e == null ? void 0 : e.saturation) != null ? t : 80,\n    endSaturation: (i = e == null ? void 0 : e.saturation) != null ? i : 80,\n    startLightness: (u = e == null ? void 0 : e.lightness) != null ? u : 60,\n    endLightness: (l = e == null ? void 0 : e.lightness) != null ? l : 60,\n    randomize: (o = e == null ? void 0 : e.randomize) != null ? o : !0\n  });\n}\nconst Ra = {\n  firstRowIsHeader: !0,\n  surroundingLines: !0,\n  columns: []\n}, pi = {\n  Reset: \"\\x1B[0m\",\n  // Bright: '\\x1b[1m',\n  // Dim: '\\x1b[2m',\n  Underscore: \"\\x1B[4m\",\n  // Blink: '\\x1b[5m',\n  Reverse: \"\\x1B[7m\",\n  // Hidden: '\\x1b[8m',\n  fg: {\n    Black: \"\\x1B[30m\",\n    Red: \"\\x1B[31m\",\n    Green: \"\\x1B[32m\",\n    Yellow: \"\\x1B[33m\",\n    Blue: \"\\x1B[34m\",\n    Magenta: \"\\x1B[35m\",\n    Cyan: \"\\x1B[36m\",\n    White: \"\\x1B[37m\",\n    Crimson: \"\\x1B[38m\"\n  },\n  bg: {\n    Black: \"\\x1B[40m\",\n    Red: \"\\x1B[41m\",\n    Green: \"\\x1B[42m\",\n    Yellow: \"\\x1B[43m\",\n    Blue: \"\\x1B[44m\",\n    Magenta: \"\\x1B[45m\",\n    Cyan: \"\\x1B[46m\",\n    White: \"\\x1B[47m\",\n    Crimson: \"\\x1B[48m\"\n  }\n}, $i = (n, e = Ra) => {\n  const a = \"(null)\";\n  if (n.length === 0)\n    return;\n  let r = D({}, e);\n  if (!r.columns || r.columns.length === 0) {\n    r.columns = [];\n    const i = n[0];\n    for (let u = 0; u < i.length; u++)\n      r.columns.push({\n        characters: n.reduce((l, o) => {\n          var m;\n          const s = ((m = o[u]) != null ? m : a).toString().length;\n          return s > l ? s : l;\n        }, 1),\n        justify: n.find(\n          (l, o) => {\n            var s;\n            return o === 0 ? !1 : isNaN(parseFloat(((s = l[u]) != null ? s : \"0\").toString()));\n          }\n        ) ? \"L\" : \"R\"\n      });\n  }\n  let t = !0;\n  r.surroundingLines && (console.log(\" \"), console.log(\n    n[0].map((i, u) => {\n      var s, m, g;\n      let l = \"\";\n      const o = ((s = r.columns) != null ? s : [])[u];\n      return o && (o.justify === \"L\" ? l = l.padEnd(o.characters, (m = o.padWith) != null ? m : \"-\") : l = l.padStart(o.characters, (g = o.padWith) != null ? g : \"-\")), l;\n    }).join(\"---\")\n  ));\n  for (const i of n)\n    console.log(\n      i.map((u, l) => {\n        var m, g, h;\n        let o = (u != null ? u : \"(null)\").toString();\n        const s = ((m = r.columns) != null ? m : [])[l];\n        return s && (s.justify === \"L\" ? o = o.padEnd(s.characters, (g = s.padWith) != null ? g : \" \") : o = o.padStart(s.characters, (h = s.padWith) != null ? h : \" \")), o;\n      }).join(\"   \")\n    ), r.firstRowIsHeader && t && console.log(\n      i.map((u, l) => {\n        var m, g, h;\n        let o = \"\";\n        const s = ((m = r.columns) != null ? m : [])[l];\n        return s && (s.justify === \"L\" ? o = o.padEnd(s.characters, (g = s.padWith) != null ? g : \"-\") : o = o.padStart(s.characters, (h = s.padWith) != null ? h : \"-\")), o;\n      }).join(\"---\")\n    ), t = !1;\n  r.surroundingLines && (console.log(\n    n[0].map((i, u) => {\n      var s, m, g;\n      let l = \"\";\n      const o = ((s = r.columns) != null ? s : [])[u];\n      return o && (o.justify === \"L\" ? l = l.padEnd(o.characters, (m = o.padWith) != null ? m : \"-\") : l = l.padStart(o.characters, (g = o.padWith) != null ? g : \"-\")), l;\n    }).join(\"---\")\n  ), console.log(\" \"));\n};\nfunction ze(n) {\n  return n != null && typeof n == \"object\";\n}\nconst mn = (n, e) => {\n  switch (typeof n) {\n    case \"function\":\n    case \"object\":\n      return !1;\n    default:\n      const a = E(n), r = a === null ? null : E(e);\n      return a !== null && r !== null ? a == r : n == e;\n  }\n}, Ui = (n, e) => {\n  const a = {};\n  return ze(n) ? ze(e) ? (Object.keys(n).forEach((r) => {\n    r in e ? xe(n[r], e[r]) || (a[r] = { val1: n[r], val2: e[r] }) : a[r] = { val1: n[r] };\n  }), Object.keys(e).filter((r) => !(r in n)).forEach((r) => {\n    a[r] = { val2: e[r] };\n  })) : Object.keys(n).forEach((r) => {\n    a[r] = { val1: n[r] };\n  }) : ze(e) && Object.keys(e).forEach((r) => {\n    a[r] = { val1: e[r] };\n  }), a;\n}, xe = (n, e) => {\n  var a, r;\n  if (n === void 0 && e === void 0 || n === null && e === null)\n    return !0;\n  if (!n && e || n && !e)\n    return !1;\n  if (Array.isArray(n)) {\n    if (n.length !== e.length)\n      return !1;\n    for (let t = 0; t < n.length; t++)\n      if (!xe(n[t], e[t]))\n        return !1;\n    return !0;\n  }\n  switch (typeof n) {\n    case \"function\":\n      return typeof e == \"function\";\n    case \"object\":\n      if (typeof e != \"object\")\n        return !1;\n      if (typeof n == \"object\" && ((a = n.type) != null && a.toString().includes(\"react.\")) || typeof e == \"object\" && ((r = e.type) != null && r.toString().includes(\"react.\")))\n        return !0;\n      const t = Object.keys(n), i = Object.keys(e);\n      if (t.length !== i.length)\n        return !1;\n      for (const u of t)\n        if (!xe(n[u], e[u]))\n          return !1;\n      return !0;\n    case \"string\": {\n      if (typeof e == \"string\" && (n.includes(\"-\") || n.includes(\"/\"))) {\n        const u = p(n);\n        if (u) {\n          const l = p(e);\n          if (l)\n            return L(u, \"IsSame\", l, \"second\");\n        }\n      }\n      return mn(n, e);\n    }\n    default:\n      return mn(n, e);\n  }\n}, fn = (n, e) => {\n  var a, r;\n  if (n === void 0 && e === void 0 || n === null && e === null)\n    return !0;\n  if (!n && e || n && !e)\n    return !1;\n  if (Array.isArray(n)) {\n    if (n.length !== e.length)\n      return !1;\n    for (let t = 0; t < n.length; t++)\n      if (!fn(n[t], e[t]))\n        return !1;\n    return !0;\n  }\n  switch (typeof n) {\n    case \"function\":\n      return !0;\n    case \"boolean\":\n      return x(n) === x(e);\n    case \"object\":\n      if (typeof n == \"object\" && ((a = n.type) != null && a.toString().includes(\"react.\")) || typeof e == \"object\" && ((r = e.type) != null && r.toString().includes(\"react.\")))\n        return !0;\n      const t = Object.keys(n);\n      for (const i of t)\n        if (!fn(n[i], e[i]))\n          return !1;\n      return !0;\n    case \"string\":\n      if (typeof e == \"boolean\")\n        return x(n) === x(e);\n      if (typeof e == \"string\") {\n        const i = p(n);\n        if (i) {\n          const u = p(e);\n          if (u)\n            return L(i, \"IsSame\", u, \"second\");\n        }\n      }\n      if (typeof e == \"number\") {\n        const i = E(n);\n        if (i !== null)\n          return e === i;\n      }\n      return n == e;\n    case \"number\":\n      if (typeof e == \"string\") {\n        const i = E(e);\n        if (i !== null)\n          return n === i;\n      }\n      return n == e;\n    default:\n      return n == e;\n  }\n}, gn = (n, e) => {\n  var a, r;\n  if (n === void 0 && e === void 0 || n === null && e === null || n === \"\" && e === null || n === null && e === \"\" || n === \"false\" && !e || !n && e === \"false\")\n    return !0;\n  if (!n && e || n && !e)\n    return !1;\n  if (Array.isArray(n)) {\n    if (n.length !== e.length)\n      return !1;\n    for (let t = 0; t < n.length; t++)\n      if (!gn(n[t], e[t]))\n        return !1;\n    return !0;\n  }\n  switch (typeof n) {\n    case \"function\":\n      return !0;\n    case \"boolean\":\n      return x(n) === x(e);\n    case \"object\":\n      if (typeof n == \"object\" && ((a = n.type) != null && a.toString().includes(\"react.\")) || typeof e == \"object\" && ((r = e.type) != null && r.toString().includes(\"react.\")))\n        return !0;\n      const t = Object.keys(n);\n      for (const i of t)\n        if (!gn(n[i], e[i]))\n          return !1;\n      return !0;\n    case \"string\":\n      if (typeof e == \"boolean\")\n        return x(n) === x(e);\n      if (typeof e == \"string\" && (n.includes(\"-\") || n.includes(\"/\"))) {\n        const i = p(n);\n        if (i && (e.includes(\"-\") || e.includes(\"/\"))) {\n          const u = p(e);\n          if (u)\n            return L(i, \"IsSame\", u, \"second\");\n        }\n      }\n      if (typeof e == \"number\") {\n        const i = E(n);\n        if (i !== null)\n          return e === i;\n      }\n      return n == e;\n    case \"number\":\n      if (typeof e == \"string\") {\n        const i = E(e);\n        if (i !== null)\n          return n === i;\n      }\n      return n == e;\n    default:\n      return n == e;\n  }\n};\nfunction hn(n) {\n  if (!n)\n    return n;\n  if (n instanceof Date)\n    return new Date(n.valueOf());\n  if (n instanceof Array) {\n    const e = [];\n    for (let a = 0, r = n.length; a < r; a++)\n      e[a] = hn(n[a]);\n    return e;\n  }\n  if (n instanceof Object) {\n    const e = {};\n    for (let a in n)\n      Object.prototype.hasOwnProperty.call(n, a) && (e[a] = hn(n[a]));\n    return e;\n  }\n  return n;\n}\nconst _i = {}, Li = (n, e, a, r) => {\n  a && e && a((t) => {\n    let i = D({}, t);\n    return r && Je(r[e], n) ? delete i[e] : i[e] = n, i;\n  });\n}, Fi = (n, e, a) => V(D({}, a), {\n  [n]: e\n}), Pi = (n, e) => D(D({}, n), e), Bi = {}, xi = (n, e, a, r, t = {}) => V(D({}, r), {\n  [n]: V(D(D({}, t), r[n]), {\n    [e]: a\n  })\n}), Ri = (n, e, a, r = {}) => V(D({}, a), {\n  [n]: D(D(D({}, r), a[n]), e)\n}), Ya = (n, e, a) => {\n  let r = [...n], t = r.findIndex(\n    (u) => !!e.id && e.id === u.id || !!e.uuid && e.uuid === u.uuid\n  );\n  if (t >= 0)\n    return r[t] = D(D({}, r[t]), e), r;\n  let i = D(D({}, a), e);\n  return !i.id && !i.uuid && (i.uuid = Fa()), [...r, D({}, i)];\n}, Yi = (n, e, a) => e.reduce((r, t) => Ya(r, t, a), n), Hi = (n, e) => n.map((a) => D(D({}, a), e[a.id])), Wi = function(n, e = !0) {\n  if (!n.length)\n    return \"\";\n  const a = Object.keys(n[0]);\n  return '\"' + a.join('\",\"') + `\"\n` + n.map(\n    (r) => a.map((t) => {\n      const i = r[t];\n      return e && (typeof i == \"number\" && !i || i === \"0\") ? \"\" : typeof i == \"string\" ? '\"' + T('\"', '\"\"', i) + '\"' : (i != null ? i : \"\").toString();\n    }).join(\",\")\n  ).join(`\n`);\n}, zi = function(n, e = !0) {\n  if (!n.length)\n    return \"\";\n  const a = Object.keys(n[0]);\n  return '\"' + a.join('\"\t\"') + `\"\n` + n.map(\n    (r) => a.map((t) => {\n      const i = r[t];\n      return e && (typeof i == \"number\" && !i || i === \"0\") ? \"\" : typeof i == \"string\" ? '\"' + T('\"', '\"\"', i) + '\"' : (i != null ? i : \"\").toString();\n    }).join(\"\t\")\n  ).join(`\n`);\n}, Ha = function(n, e = !0) {\n  return n.map(\n    (a) => a.map(\n      (r) => e && (typeof r == \"number\" && !r || r === \"0\") ? \"\" : typeof r == \"string\" ? '\"' + T('\"', '\"\"', r) + '\"' : (r != null ? r : \"\").toString()\n    ).join(\",\")\n  ).join(`\n`);\n}, Gi = function(n, e, a = !0) {\n  const r = Ha(e, a);\n  let t = document.createElement(\"a\");\n  const i = new Blob([r], { type: \"text/csv;charset=utf-8;\" });\n  t.href = URL.createObjectURL(i), t.setAttribute(\"download\", n), t.click();\n}, Ki = function(n, e) {\n  const a = e.map(\n    (i) => i.map((u) => u && !isNaN(u) ? Math.round(u * 100) / 100 : u != null ? u : \"\").join(\",\")\n  ).join(`\n`);\n  let r = document.createElement(\"a\");\n  const t = new Blob([a], { type: \"text/csv;charset=utf-8;\" });\n  r.href = URL.createObjectURL(t), r.setAttribute(\"download\", n), r.click();\n}, Vi = (n, e = !0, a = !0) => {\n  const r = n.reduce(\n    (i, u) => [\n      ...i,\n      ...Object.keys(u).filter((l) => !i.includes(l))\n    ],\n    []\n  );\n  let t = \"\";\n  e && (t += r.map((i) => `\"${a ? qn(i) : i}\"`).join(\"\t\"));\n  for (const i of n)\n    t && (t += `\\r\n`), t += r.map((u) => {\n      if (i[u] === void 0 || i[u] === null || typeof i[u] == \"string\" && i[u].trim() === \"\")\n        return \"\";\n      const l = E(i[u]);\n      return l !== null ? l.toString() : `\"${i[u]}\"`;\n    }).join(\"\t\");\n  return t;\n}, Zi = (n) => {\n  if (!n || typeof n != \"string\")\n    return !1;\n  try {\n    const e = JSON.parse(n), a = Object.prototype.toString.call(e);\n    return a === \"[object Object]\" || a === \"[object Array]\";\n  } catch (e) {\n    return !1;\n  }\n}, Je = (n, e, a = !1) => {\n  if (n === e)\n    return !0;\n  if (n === null)\n    return e === null;\n  if (e === null)\n    return a && console.log(n, e), !1;\n  if (n === void 0)\n    return e === void 0;\n  if (e === void 0)\n    return a && console.log(n, e), !1;\n  if (Array.isArray(n))\n    if (Array.isArray(e)) {\n      if (n.length !== e.length)\n        return a && console.log(\"Lengths\", n, e), !1;\n      for (let r = 0; r < n.length; r++)\n        if (!Je(n[r], e[r]))\n          return !1;\n      return !0;\n    } else\n      return a && console.log(\"Array/Not\", n, e), !1;\n  else if (Array.isArray(e))\n    return a && console.log(\"Array/Not\", n, e), !1;\n  if (typeof n == \"object\" || typeof e == \"object\") {\n    const r = Object.keys(n), t = Object.keys(e);\n    if (r.length !== t.length)\n      return a && console.log(\"Object Keys\", n, e), !1;\n    const i = r.findIndex((u) => !Je(n[u], e[u]));\n    if (i === -1)\n      return !0;\n    if (a)\n      return console.log(\"Object Key\", r[i], n, e), !1;\n  } else {\n    if (n === e)\n      return !0;\n    {\n      const r = E(n);\n      if (r !== null) {\n        const t = E(e);\n        if (t !== null && r === t)\n          return !0;\n        a && console.log(\"Numbers1\", n, e);\n      } else if (E(e) !== null)\n        return a && console.log(\"Numbers2\", n, e), !1;\n      if (ln(n)) {\n        let t = me(n, Be);\n        if (t)\n          if (ln(e)) {\n            let i = me(e, Be);\n            if (i && t === i)\n              return !0;\n            a && console.log(\"Dates\", n, e);\n          } else\n            a && console.log(\"Dates\", n, e);\n      }\n    }\n  }\n  return a && console.log(\"Fallout\", n, e), !1;\n}, pn = (n, e) => {\n  const a = D({}, n);\n  for (const r in e)\n    e.hasOwnProperty(r) && xe(e[r], a[r]) && delete a[r];\n  return a;\n}, qi = (n, e) => {\n  const a = D({}, n);\n  for (const r in e)\n    if (e.hasOwnProperty(r) && a.hasOwnProperty(r)) {\n      const t = pn(a[r], e[r]);\n      Object.keys(t).length === 0 ? delete a[r] : a[r] = t;\n    }\n  return a;\n}, Ji = (n, e) => {\n  const a = D({}, n);\n  for (const r in n)\n    if (n.hasOwnProperty(r)) {\n      const t = e.find((i) => i.id == r);\n      if (t) {\n        const i = pn(a[r], t);\n        Object.keys(i).length === 0 ? delete a[r] : a[r] = i;\n      }\n    }\n  return a;\n}, Qi = (n, e, a = []) => {\n  let r = {};\n  for (const t of Object.keys(n))\n    a.includes(t) || n[t] !== e[t] && (r[t] = n[t]);\n  return r;\n}, Xi = (n, e, a = []) => {\n  let r = {};\n  for (const t of Object.keys(n))\n    !a.includes(t) && e[t] !== void 0 && (r[t] = n[t]);\n  return r;\n}, Ne = [\"&&\", \"||\", \"!=\", \"<>\", \">=\", \"<=\", \"=\", \"<\", \">\", \"-\", \"+\", \"/\", \"*\", \"^\"], Wa = [\"abs\", \"pow\", \"int\", \"round\", \"includes\", \"includesinarray\"];\nfunction ji(n, e, a) {\n  return ae(this, null, function* () {\n    let r = /\\[(.*?)\\]/g, t = [], i;\n    const u = D({}, e != null ? e : {}), l = [], o = [];\n    for (; (i = r.exec(n)) !== null; )\n      if (u[i[1]] === void 0)\n        if (a != null && a.requestVariable) {\n          const s = yield a.requestVariable(i[1]);\n          typeof s == \"number\" || typeof s == \"string\" ? u[i[1]] = f(s, 5) : typeof s == \"object\" ? (F(s == null ? void 0 : s.value) ? t.push(i[1]) : u[i[1]] = f(s == null ? void 0 : s.value, 5), s != null && s.warning && l.push(s.warning), s != null && s.error && o.push(s.error)) : t.push(i[1]);\n        } else\n          t.push(i[1]);\n    return {\n      calculation: za(n, u),\n      missingVariables: t,\n      variables: u,\n      warnings: l,\n      errors: o\n    };\n  });\n}\nfunction za(n, e) {\n  return E(Re(`[${n}]`, e));\n}\nconst Re = (n, e) => {\n  var t, i, u;\n  let a = n;\n  if (e)\n    for (const l of Object.keys(e))\n      a = T(`[${l}]`, e[l], a);\n  let r = Ue(a, \"[\", \"]\");\n  for (; r; ) {\n    let l = (t = a.substring(0, r[0])) != null ? t : \"\", o = (i = Pe(a.substring(r[0] + 1, r[1]))) != null ? i : \"\", s = (u = a.substring(r[1] + 1)) != null ? u : \"\";\n    a = `${l}${o}${s}`, r = Ue(a, \"[\", \"]\");\n  }\n  return a = $n(a), a;\n}, eu = (n, e) => x(Re(`[${n}]`, e)), Ue = (n, e, a) => {\n  if (n) {\n    const r = n.length;\n    let t = null;\n    for (let i = 0; i < r; i++)\n      if (n.substring(i, i + 1) === e)\n        t = i;\n      else if (t !== null && n.substring(i, i + 1) === a)\n        return [t, i];\n  }\n  return null;\n}, dn = (n, e, a) => {\n  if (n) {\n    const r = n.indexOf(e);\n    if (r >= 0) {\n      let t = 0;\n      for (let i = r + 1; i < n.length; i++)\n        if (n.charAt(i) === e)\n          t++;\n        else if (n.charAt(i) === a)\n          if (t)\n            t--;\n          else\n            return [r, i];\n    }\n  }\n  return null;\n};\nfunction nu(n, e, a) {\n  if (!n)\n    return [];\n  let r = n;\n  const t = [];\n  let i = dn(r, e, a);\n  for (; i; )\n    t.push(r.substring(i[0] + 1, i[1])), r = r.substring(i[1] + 1), i = dn(r, e, a);\n  return t;\n}\nconst Pe = (n) => {\n  let e = $n(n);\n  e = T(\" \", \"\", e);\n  const a = [...Ne, \"(\"], r = [...Ne, \")\"];\n  let t = Ue(e, \"(\", \")\");\n  for (; t; ) {\n    let i = e.substring(0, t[0]);\n    i.length > 0 && a.indexOf(i.substring(i.length - 1)) === -1 && a.indexOf(i.substring(i.length - 2)) === -1 && (i = i.concat(\"*\")), i = i.concat(\n      Pe(e.substring(t[0] + 1, t[0] + 1 + (t[1] - t[0] - 1)))\n    );\n    let u = e.substring(t[1] + 1, t[1] + 1 + (e.length - t[1]));\n    u.length > 0 && r.indexOf(u.substring(0, 1)) === -1 && r.indexOf(u.substring(0, 2)) === -1 && (i = i.concat(\"*\")), e = i.concat(u), t = Ue(e, \"(\", \")\");\n  }\n  for (const i of Ne) {\n    let u = i, l = i, o = e.split(i);\n    if (o.length > 1) {\n      i === \"-\" && Ne.indexOf(o[0].substring(o[0].length - 1)) > -1 && (u = o[0].substring(o[0].length - 1), o[0] = o[0].substring(0, o[0].length - 1), o[1] = \"-\" + o[1]);\n      let s = Pe(o[0]);\n      for (let m = 1; m < o.length; m++) {\n        l = i, i === \"-\" && Ne.indexOf(o[m].substring(o[m].length - 1)) > -1 && (l = o[m].substring(o[m].length - 1), o[m] = o[m].substring(0, o[m].length - 1), o[m + 1] = \"-\" + o[m + 1]);\n        let g = Pe(o[m]);\n        const h = parseFloat(s), S = parseFloat(g), M = !isNaN(h) && !isNaN(S);\n        switch (u) {\n          case \"^\":\n            M ? s = Math.pow(h, S).toString() : s = g;\n            break;\n          case \"*\":\n            M ? s = (h * S).toString() : s = g;\n            break;\n          case \"/\":\n            M && (S === 0 ? s = \"0\" : s = (h / S).toString());\n            break;\n          case \"+\":\n            M ? s = (h + S).toString() : s = g;\n            break;\n          case \"-\":\n            M ? s = (h - S).toString() : s = `-${g}`;\n            break;\n          case \"<=\":\n            M ? s = h <= S ? \"1\" : \"0\" : s = s <= g ? \"1\" : \"0\";\n            break;\n          case \">=\":\n            M ? s = h >= S ? \"1\" : \"0\" : s = s >= g ? \"1\" : \"0\";\n            break;\n          case \"<\":\n            M ? s = h < S ? \"1\" : \"0\" : s = s < g ? \"1\" : \"0\";\n            break;\n          case \">\":\n            M ? s = h > S ? \"1\" : \"0\" : s = s > g ? \"1\" : \"0\";\n            break;\n          case \"=\":\n            s = s === g ? \"1\" : \"0\";\n            break;\n          case \"!=\":\n            s = s !== g ? \"1\" : \"0\";\n            break;\n          case \"||\":\n            s = s || g;\n            break;\n          case \"&&\":\n            s = s && g;\n            break;\n          default:\n            s = g;\n        }\n        u = l;\n      }\n      return s;\n    }\n  }\n  return e;\n}, An = (n, e) => {\n  if (!n)\n    return null;\n  for (const a of Wa) {\n    const r = (\"\" + n.toLowerCase()).indexOf(a + \"(\", e);\n    if (r >= 0) {\n      const t = n.substring(r + a.length).toLowerCase(), i = Ue(t, \"(\", \")\");\n      if (i) {\n        const u = t.substring(1, i[1]);\n        return {\n          expression: n,\n          pos: r,\n          pre: n.substring(0, r).trim(),\n          post: t.substring(i[1] + 1).trim(),\n          function: a,\n          argumentText: u,\n          arguments: u.split(\",\").map((l) => l.trim())\n        };\n      }\n    }\n  }\n  return null;\n}, Ga = (n) => {\n  var r, t;\n  const e = parseFloat(Re(`[${(r = n.arguments[0]) != null ? r : \"0\"}]`)), a = parseFloat(Re(`[${(t = n.arguments[1]) != null ? t : \"0\"}]`));\n  switch (n.function) {\n    case \"abs\":\n      if (!isNaN(e))\n        return Math.abs(e).toString();\n      break;\n    case \"pow\":\n      if (!isNaN(e) && !isNaN(a))\n        return Math.pow(e, a).toString();\n      break;\n    case \"int\":\n      if (!isNaN(e))\n        return parseInt(n.arguments[0]).toString();\n      break;\n    case \"round\":\n      if (!isNaN(e) && !isNaN(a)) {\n        const s = Math.pow(10, a), m = e * s;\n        return (Math.round(m) / s).toString();\n      }\n      break;\n    case \"includes\":\n      let i = 1, u = [];\n      for (; n.arguments[i] !== void 0; )\n        u.push(n.arguments[i]), i++;\n      return u.join(\",\").includes(n.arguments[0]) ? \"1\" : \"0\";\n    case \"includesinarray\":\n      let l = 1, o = [];\n      for (; n.arguments[l] !== void 0; )\n        o.push(n.arguments[l]), l++;\n      return o.includes(n.arguments[0]) ? \"1\" : \"0\";\n  }\n  return \"\";\n}, $n = (n) => {\n  let e = n, a = An(e, 0);\n  for (; a; )\n    e = a.pre + Ga(a) + a.post, a = An(e, 0);\n  return e;\n}, Un = (n) => {\n  const e = D({}, n);\n  return Object.values(n).forEach((a) => typeof a == \"number\" && delete e[a]), e;\n};\nfunction au(n) {\n  return Object.keys(n).map((e) => ({\n    key: e,\n    value: n[e]\n  }));\n}\nfunction ru(n) {\n  return Object.keys(n).map((e) => ({\n    key: n[e],\n    name: e\n  }));\n}\nconst tu = (n) => Object.keys(Un(n)), Ka = (n) => [...new Set(Object.values(Un(n)))], iu = (n, e) => e == null ? void 0 : Object.keys(n)[Object.values(n).indexOf(e)], uu = (n, e) => e == null ? void 0 : Object.values(n)[Object.keys(n).indexOf(e)];\nfunction ou(n, e, a) {\n  return !!e && Ka(n).some(\n    (r) => a != null && a.ignoreSpace ? T(\" \", \"\", r == null ? void 0 : r.toString()) === T(\" \", \"\", e == null ? void 0 : e.toString()) : r === e\n  );\n}\nvar Sn;\n((n) => {\n  n.Header = (r = \"calendar\") => ({\n    \"Content-Type\": \"text/Calendar\",\n    \"Content-Disposition\": `inline; filename=${r}.ics`\n  }), n.VCALENDAROpen_Text = `BEGIN:VCALENDAR\nVERSION:2.0\nCALSCALE:GREGORIAN\n`, n.VCALENDARClose_Text = `END:VCALENDAR\n`;\n  const e = (r, t) => {\n    var i;\n    return r ? `TZID=${t != null ? t : \"America/New_York\"}:${(i = Aa(p(r))) != null ? i : \"\"}` : \"\";\n  }, a = (r) => T(`\\r\n`, \"\\\\n\", T(`\n`, \"\\\\n\", T(\"\\r\", \"\\\\n\", T(\",\", \"\\\\,\", T(\";\", \"\\\\;\", T(\"\\\\\", \"\\\\\\\\\", r))))));\n  n.VEVENT_Text = (r) => {\n    var i, u;\n    let t = \"\";\n    return t += `BEGIN:VEVENT\n`, t += `CLASS:PUBLIC\n`, t += \"CREATED;\" + e((i = r.dateTimeCreated) != null ? i : (/* @__PURE__ */ new Date()).toISOString()) + `\n`, t += \"DESCRIPTION:\" + a(r.description) + `\n`, t += \"DTSTART;\" + e(r.dateTimeStart) + `\n`, r.durationMinutes ? t += \"DURATION:PT\" + r.durationMinutes + `M\n` : r.dateTimeEnd && (t += \"DTEND;\" + e(r.dateTimeEnd) + `\n`), t += \"DTSTAMP;\" + e((/* @__PURE__ */ new Date()).toISOString()) + `\n`, r.organizerName && r.organizerEmail && (t += `ORGANIZER;CN=${r.organizerName}:MAILTO:${r.organizerEmail}\n`), t += \"LAST-MODIFIED;\" + e((u = r.dateTimeModified) != null ? u : (/* @__PURE__ */ new Date()).toISOString()) + `\n`, r.location && (r.location_altrep ? t += `LOCATION;ALTREP=\"${a(r.location_altrep)}\":` + a(r.location) + `\n` : t += \"LOCATION:\" + a(r.location) + `\n`), r.priority && (t += `PRIORITY:${r.priority}\n`), t += `SEQUENCE:0\n`, t += \"SUMMARY:\" + a(r.subject) + `\n`, t += `TRANSP:OPAQUE\n`, t += \"UID:\" + r.UID + `\n`, r.alarmTriggerMinutes !== void 0 && (t += `BEGIN:VALARM\n`, t += `TRIGGER:-PT${r.alarmTriggerMinutes}M\n`, t += `ACTION:DISPLAY\n`, t += `DESCRIPTION:Reminder\n`, t += `END:VALARM\n`), t += `END:VEVENT\n`, t;\n  }, n.ICS_Text = (r) => n.VCALENDAROpen_Text + (0, n.VEVENT_Text)(r) + n.VCALENDARClose_Text;\n})(Sn || (Sn = {}));\nfunction lu(n) {\n  var r, t;\n  const e = n.some((i) => !!i.id);\n  let a = `!TRNS${e ? \"\tTRNSID\" : \"\"}\tTRNSTYPE\tDATE\tACCNT\tNAME\tAMOUNT\tMEMO\tNUM\n!SPL${e ? \"\tSPLID\" : \"\"}\tDATE\tACCNT\tNAME\tAMOUNT\tMEMO\n!ENDTRNS\n`;\n  for (const i of n) {\n    const u = `TRNS${e ? `\t${(r = i.id) != null ? r : \"\"}` : \"\"}\tCHECK\t${b(i.date, {\n      formatLocale: !0\n    })}\t${T(\"\t\", \"\", i.account)}\t${T(\"\t\", \"\", i.payee)}\t-${f(\n      i.amount,\n      2\n    ).toString()}\t${T(\"\t\", \"\", i.memo)}\t${f(i.number, 0).toString()}\n`, l = `SPL${e ? `\t${(t = i.id) != null ? t : \"\"}` : \"\"}\t${b(i.date, {\n      formatLocale: !0\n    })}\t${T(\"\t\", \"\", i.category)}\t${T(\"\t\", \"\", i.payee)}\t${f(\n      i.amount,\n      2\n    ).toString()}\t${T(\"\t\", \"\", i.memo)}\n`;\n    a += `${u}${l}ENDTRNS\n`;\n  }\n  return a;\n}\nconst Ge = (n, e) => {\n  var a, r, t, i, u, l, o, s, m, g;\n  if (e.nullIfFalsey && !n || n === null || n === void 0)\n    return e.nullable || e.nullIfFalsey ? null : e.type === \"date\" ? b((a = e.default) != null ? a : \"now\") : e.type === \"datetime\" ? Y((r = e.default) != null ? r : \"now\") : e.type === \"time\" ? X((t = e.default) != null ? t : \"now\") : e.type === \"number\" ? f(e.default) : e.type === \"boolean\" ? x((i = e.default) != null ? i : !0) : e.type === \"object\" ? typeof e.default == \"string\" ? (u = Ve(e.default)) != null ? u : {} : (l = e.default) != null ? l : {} : ((o = e.default) != null ? o : \"\").toString();\n  if (e.type === \"boolean\") {\n    if (typeof n != \"boolean\")\n      return x(n);\n  } else if (e.type === \"number\") {\n    if (typeof n != \"number\")\n      return e.nullable ? E(n) : f(n);\n  } else {\n    if (e.type === \"date\")\n      return e.nullable ? ie(n) : b(n);\n    if (e.type === \"datetime\")\n      return e.nullable ? Y(n) : (s = Y(n)) != null ? s : ma();\n    if (e.type === \"time\")\n      return e.nullable ? X(n) : (m = X(n)) != null ? m : \"00:00\";\n    if (e.type === \"object\") {\n      if (typeof n == \"string\")\n        return (g = Ve(n)) != null ? g : e.nullable ? null : {};\n      if (typeof n != \"object\")\n        return e.nullable ? null : {};\n    } else if (typeof n != \"string\")\n      return n ? n.toString() : \"\";\n  }\n  return n;\n}, Ke = (n, e) => {\n  let a = n;\n  if (e.length && n)\n    switch (typeof n) {\n      case \"string\":\n        a = n.substring(0, e.length);\n        break;\n      case \"number\":\n        const r = n.toString();\n        if (!r.includes(\".\") && n.toString().length > e.length)\n          throw new Error(\n            `Value ${n} longer than ${v(e.length)}, is ${r.length}`\n          );\n        if (r.toString().length > e.length + 1) {\n          const t = r.split(\".\")[0];\n          if (t.toString().length > e.length)\n            throw new Error(\n              `Whole value ${n} longer than ${v(e.length)}, is ${r.length}`\n            );\n          if (a = f(n, e.length - t.length), a.toString().length > e.length + 1)\n            throw new Error(\n              `Value ${a} longer than ${v(e.length)}, is ${a.toString().length}`\n            );\n        }\n    }\n  if (!e.nullable || n) {\n    if (e.values && !e.values.includes(n))\n      return null;\n    if (e.minValue !== void 0 && e.minValue > n)\n      return e.minValue;\n    if (e.maxValue !== void 0 && e.maxValue < n)\n      return e.maxValue;\n  }\n  return a;\n}, Va = (n, e) => {\n  if (!n)\n    return n;\n  const a = D({}, n);\n  for (const r of Object.keys(n)) {\n    const t = e[r];\n    t ? (t.isArray ? !a[r] && t.nullable ? a[r] = null : (a[r] = H(a[r]).filter(\n      (i) => t.type !== \"number\" || i !== \"\" && !F(i)\n    ).map((i) => Ge(i, t)).filter(\n      (i) => t.arrayAllowFalsey || (t.type === \"number\" ? !F(i) : !!i)\n    ).map((i) => Ke(i, t)).filter(\n      (i) => t.arrayAllowFalsey || (t.type === \"number\" ? !F(i) : !!i)\n    ), t.isArray && t.type === \"object\" && a[r].length === 1 && Array.isArray(a[r].at(0)) && (a[r] = a[r].at(0))) : a[r] = Ke(Ge(a[r], t), t), !t.nullIfFalsey && t.nullable && (t.type === \"number\" ? F(a[r]) || a[r] === \"\" : !a[r]) && typeof a[r] != \"boolean\" && (a[r] = null), t.nullIfFalsey && !a[r] && (a[r] = null)) : delete a[r];\n  }\n  for (const r of Object.keys(e))\n    if (!(r in a)) {\n      const t = e[r];\n      t && (a[r] = Ke(Ge(a[r], t), t), t.isArray && !Array.isArray(a[r]) && (a[r] = H(a.key)));\n    }\n  return a;\n}, su = (n, e) => {\n  var r, t, i, u;\n  let a = {};\n  if (e != null && e.default)\n    for (const l of Object.keys(e.default).filter((o) => {\n      var s, m;\n      return (s = e.includeColumns) != null && s.includes(o) ? !0 : !e.includeColumns && !((m = e.excludeColumns) != null && m.includes(o));\n    })) {\n      let o = Array.isArray(e.default[l]) || (r = e.arrayFormDataItems) != null && r.includes(l) ? (i = (t = n.getAll(l)) != null ? t : e == null ? void 0 : e.default[l]) != null ? i : null : n.get(l);\n      o !== void 0 && typeof e.default[l] == \"boolean\" && (o = x(o)), o !== void 0 && typeof e.default[l] == \"number\" && (o = f(o)), a[l] = (u = o != null ? o : e == null ? void 0 : e.default[l]) != null ? u : null;\n    }\n  else\n    n.forEach((l, o) => {\n      const s = n.getAll(o);\n      Array.isArray(s) && s.length > 1 ? a[o] = s : a[o] = l;\n    });\n  return e != null && e.constraint && (a = Va(a, e.constraint)), a;\n}, cu = (n) => {\n  if (n instanceof FormData)\n    return n;\n  const e = new FormData();\n  for (const a of Object.keys(n))\n    if (Array.isArray(n[a]))\n      for (const r of n[a])\n        e.append(a, r);\n    else\n      e.append(a, n[a]);\n  return e;\n};\nvar Za = /* @__PURE__ */ ((n) => (n.Local = \"local\", n.Migrate = \"migrate\", n.Dev = \"dev\", n.Test = \"test\", n.QA = \"qa\", n.Demo = \"demo\", n.ProdSupport = \"prodsupport\", n.Prod = \"prod\", n))(Za || {});\nconst _n = (n) => {\n  let e;\n  return typeof n == \"string\" ? e = [n] : e = n, !!e.find((a) => Ln() === a);\n}, Ln = () => {\n  var n, e, a;\n  return (a = (e = (n = process.env.REACT_APP_STAGE) != null ? n : process.env.STAGE) != null ? e : process.env.VITE_APP_STAGE) != null ? a : \"local\";\n}, mu = (n) => {\n  var a;\n  const e = n != null ? n : Ln();\n  switch (e) {\n    case \"dev\":\n      return \"Development\";\n    case \"qa\":\n      return \"QA\";\n    case \"prodsupport\":\n      return \"Production Support\";\n    case \"prod\":\n      return \"Production\";\n    default:\n      return (a = jn(e)) != null ? a : \"Local\";\n  }\n}, qa = () => _n([\n  \"local\",\n  \"migrate\",\n  \"dev\",\n  \"qa\"\n  /* QA */\n]), Ja = () => _n([\n  \"qa\",\n  \"test\"\n  /* Test */\n]), fu = () => qa() || Ja();\nclass gu {\n  constructor(e) {\n    _e(this, \"events\");\n    _e(this, \"offendingMS\");\n    _e(this, \"warnAutomatically\", !1);\n    var a, r;\n    this.events = [\n      {\n        eventMS: (/* @__PURE__ */ new Date()).valueOf(),\n        label: \"Start\",\n        durationMS: 0\n      }\n    ], this.offendingMS = (a = e == null ? void 0 : e.offendingMS) != null ? a : 500, this.warnAutomatically = (r = e == null ? void 0 : e.warnAutomatically) != null ? r : !1;\n  }\n  /**\n   * Reset the control to start tracking times from this point forward\n   */\n  reset() {\n    this.events = [\n      {\n        eventMS: (/* @__PURE__ */ new Date()).valueOf(),\n        label: \"Start\",\n        durationMS: 0\n      }\n    ];\n  }\n  /**\n   * Get the maximum TS in the events\n   */\n  get maxTS() {\n    return this.events.reduce((e, a) => an(e, a.eventMS), 0);\n  }\n  /**\n   * Get the minimum TS in the events\n   */\n  get minTS() {\n    return this.events.reduce((e, a) => On(e, a.eventMS), this.maxTS);\n  }\n  /**\n   * Get the total duration of all events\n   */\n  get duration() {\n    return this.maxTS - this.minTS;\n  }\n  /**\n   * Mark the current time with a label for analysis later, and throw a console warn if appropriate\n   * @param label\n   * @param options\n   */\n  mark(e, a) {\n    var u, l;\n    const r = this.maxTS, t = (/* @__PURE__ */ new Date()).valueOf(), i = {\n      eventMS: t,\n      label: e,\n      durationMS: t - r\n    };\n    return this.events.push(i), ((u = a == null ? void 0 : a.warnAutomatically) != null ? u : this.warnAutomatically) && i.durationMS > ((l = a == null ? void 0 : a.offendingMS) != null ? l : this.offendingMS) && console.info(`Time exceeded - ${e} - ${v(i.durationMS)}ms (${kn()})`), i;\n  }\n  /**\n   * Mark the current time with a label for analysis later, and throw a console warn if appropriate\n   * @param label\n   * @param promiseFunction\n   * @param options\n   */\n  markResolved(e, a, r) {\n    return a.then(() => {\n      this.mark(e, r);\n    }), a;\n  }\n  /**\n   * Report back only the events that exceeded the offending MS\n   */\n  get offendingEvents() {\n    return this.events.reduce((e, a) => a.durationMS > this.offendingMS ? [...e, a] : e, []);\n  }\n  /**\n   * Analyze events, and if any are offending, or if the sum offends, then display those events and return them\n   * @param options\n   */\n  durationOffends(e) {\n    var r, t, i;\n    const a = this.offendingEvents;\n    if (a.length || this.duration > ((r = e == null ? void 0 : e.offendingMS) != null ? r : this.offendingMS)) {\n      const u = e != null && e.showAll ? this.events.filter((l) => l.durationMS) : a;\n      return ((t = e == null ? void 0 : e.warnAutomatically) != null ? t : this.warnAutomatically) && (console.info(`\"${(i = e == null ? void 0 : e.label) != null ? i : \"Unknown Event\"}\" took ${v(this.duration)}ms`), console.table(u.map((l) => qe(l, \"eventMS\")))), u;\n    }\n    return null;\n  }\n  /**\n   * Analyze events, and if any are offending, or if the sum offends, then display those events and return them\n   * @param label\n   * @param offendingMS\n   * @param showAll\n   */\n  consoleDurationOffends(e, a, r = !1) {\n    const t = this.offendingEvents;\n    if (t.length || this.duration > (a != null ? a : this.offendingMS)) {\n      const i = r ? this.events.filter((u) => u.durationMS) : t;\n      return console.info(`\"${e}\" took ${v(this.duration)}ms`), i.length && console.table(i.map((u) => qe(u, \"eventMS\"))), i;\n    }\n    return null;\n  }\n}\nfunction hu(n, e, a) {\n  const r = (/* @__PURE__ */ new Date()).valueOf(), t = E(e);\n  return a.then(() => {\n    const i = (/* @__PURE__ */ new Date()).valueOf() - r;\n    t && i > t && console.info(`Time Exceeded - ${n} - ${v(i)}ms (${kn()})`);\n  }), a;\n}\nconst Ee = (n) => typeof n == \"number\" ? n : n.id;\nvar yn;\n((n) => {\n  n.IsSelected = (e, a) => !a.includes(Ee(e)), n.SelectedIDs = (e, a) => e.reduce(\n    (r, t) => {\n      const i = Ee(t);\n      return a.find((u) => u === i) ? r : [...r, i];\n    },\n    []\n  ), n.ToggleUnSelectedID = (e, a) => a.includes(e) ? a.filter((r) => r !== e) : [...a, e], n.SelectIDs = (e, a) => a.filter((r) => !e.find((t) => r === Ee(t))), n.UnSelectIDs = (e, a) => [...a, ...e.map((r) => Ee(r))], n.SelectedBetween = (e, a, r, t) => {\n    const i = e.map((s) => Ee(s)), u = !(0, n.IsSelected)(r, t);\n    let l = [], o = !1;\n    for (const s of i)\n      if (s === a || s === r) {\n        if (l.push(s), o)\n          break;\n        o = !0;\n      } else\n        o && l.push(s);\n    return u ? (0, n.SelectIDs)(l, t) : (0, n.UnSelectIDs)(l, t);\n  };\n})(yn || (yn = {}));\nconst du = (n, e, a, r = !0) => {\n  let t = [], i = !1;\n  for (const u of n)\n    if (u === e || u === a) {\n      if (r && t.push(u), i)\n        break;\n      i = !0;\n    } else\n      i && t.push(u);\n  return t;\n};\nexport {\n  Fi as AddChange,\n  xi as AddIDChange,\n  Ri as AddIDChanges,\n  k as AddS,\n  Vr as AddSBlank,\n  aa as AddSNull,\n  ha as AddSecondsToDateTimeString,\n  Jt as AddressCopy,\n  jt as AddressMultiRow,\n  Xt as AddressSingleRow,\n  Qt as AddressValid,\n  fi as ArrayFromStringWS,\n  mi as ArrayRange,\n  Wi as ArrayToCSVString,\n  ei as ArrayToGuidString,\n  zi as ArrayToTSVString,\n  Hi as ArrayWithIDChanges,\n  Jr as AsteriskMatch,\n  Wt as AverageNumber,\n  $a as AverageNumberNull,\n  Qr as BuildPath,\n  Ya as ChangeArrayByIDOrUUID,\n  Li as ChangeValueChanges,\n  lu as ChecksToIIF,\n  _a as CleanDivide,\n  Ua as CleanDivideNull,\n  f as CleanNumber,\n  E as CleanNumberNull,\n  Nn as CleanNumbers,\n  vn as CleanScripts,\n  La as CleanSubtractNumbers,\n  Ti as CoalesceFalsey,\n  Mi as ColorBrightnessHex,\n  En as ColorBrightnessRGB,\n  Yi as CombineArrayWithIDOrUUIDChanges,\n  wi as ConsoleAsyncTime,\n  pi as ConsoleColor,\n  Va as ConstrainObject,\n  Ht as CountDecimalDigits,\n  fa as CurrentTimeZone,\n  Be as DATE_FORMAT_DATE,\n  Xe as DATE_FORMAT_DATE_DISPLAY,\n  Tn as DATE_FORMAT_DATE_DISPLAY_DOW,\n  Mn as DATE_FORMAT_DATE_DISPLAY_DOW_LONG,\n  je as DATE_FORMAT_DATE_DISPLAY_LONG,\n  ua as DATE_FORMAT_DATE_TIME,\n  oa as DATE_FORMAT_DATE_TIME_DISPLAY,\n  la as DATE_FORMAT_DATE_TIME_DISPLAY_DOW,\n  ca as DATE_FORMAT_DATE_TIME_DISPLAY_DOW_LONG,\n  sa as DATE_FORMAT_DATE_TIME_DISPLAY_LONG,\n  te as DATE_FORMAT_TIME_DISPLAY,\n  at as DATE_FORMAT_TIME_NO_SECONDS,\n  ia as DATE_FORMAT_TIME_SECONDS,\n  Gi as DataToCSVExport,\n  Ki as DataToCSVExportNoQuotes,\n  Ha as DataToCSVString,\n  Vi as DataToTabDelim,\n  $ as DateAdjustTS,\n  L as DateCompare,\n  mt as DateComponent,\n  cn as DateDayOfWeek,\n  q as DateDiff,\n  Da as DateDiffComponents,\n  Ta as DateDiffLongDescription,\n  ka as DateDoWSundayZero,\n  me as DateFormat,\n  ce as DateFormatAny,\n  wn as DateFromWeekNumber,\n  tt as DateICS,\n  Y as DateISO,\n  vt as DateIsBetween,\n  It as DateIsWeekend,\n  wt as DateMonth,\n  A as DateObject,\n  b as DateOnly,\n  ie as DateOnlyNull,\n  p as DateParseTS,\n  Mt as DateQuarter,\n  Q as DateWeekISONumber,\n  ya as DateWeekISONumberNull,\n  ft as DateWeekNumber,\n  pt as DatesBetween,\n  gt as DatesFromWeekNumber,\n  va as DatesFromWeekNumberNull,\n  Ct as DatesMonth,\n  Dt as DatesQuarter,\n  ct as DayDiffNoWeekend,\n  st as DaysInMonth,\n  J as DaysInMonthYear,\n  hn as DeepClone,\n  xe as DeepEqual,\n  Ui as Differences,\n  Z as DigitsNth,\n  Xn as DisplayNameFromFL,\n  Gr as DisplayNameFromObject,\n  Ei as DistributeEvenly,\n  kt as DoWs,\n  At as DurationLongDescription,\n  ba as EQuarter,\n  Nt as ESTTodayDate,\n  kn as ESTTodayDateTimeLabel,\n  ra as EStringComparisonResult,\n  Pt as EasterDate,\n  qr as EllipsesAtMax,\n  au as EnumArray,\n  iu as EnumKeyFromValue,\n  ru as EnumKeyNames,\n  tu as EnumKeys,\n  ou as EnumValidValue,\n  uu as EnumValueFromKey,\n  Ka as EnumValues,\n  Yt as EqualNumber,\n  eu as EvaluateCondition,\n  za as EvaluateMath,\n  Re as EvaluateString,\n  Oi as ExtractPrefixedKeys,\n  Ni as ExtractWholeDecimal,\n  ja as FindIsActive,\n  er as FindIsActiveString,\n  cu as FormDataFromObject,\n  ai as FormUrlEncoded,\n  zr as FormatExternalURL,\n  Br as FormatPhoneNumber,\n  Hr as FormatPhoneNumberDashes,\n  Yr as FormatPhoneNumberDots,\n  xr as FormatPhoneNumberE164US,\n  Rr as FormatPhoneNumberOld,\n  Pr as FormatSSN,\n  Wr as FormatTaxID,\n  Dn as FormatZip,\n  Fa as GenerateUUID,\n  yi as GetPropertyValueCaseInsensitive,\n  Ln as GetStage,\n  mu as GetStageName,\n  Vt as GoogleMapsAddressLink,\n  Zt as GoogleMapsDirectionsLink,\n  Kt as GoogleMapsGPSLink,\n  yt as GreaterDate,\n  an as GreaterNumber,\n  Ia as GreaterNumberNull,\n  lt as HHcmmcss,\n  Mr as HTMLToText,\n  jr as HasAlpha,\n  Xr as HasDigits,\n  Ft as IANADescription,\n  Ie as IANAOffset,\n  Lt as IANAZoneAbbr,\n  Oa as IANAZoneAbbrNull,\n  Sn as ICS,\n  vr as IncludesHTML,\n  bt as InitialDateMonth,\n  Tt as InitialDateQuarter,\n  Ci as InvertColorHex,\n  Ba as InvertColorRGB,\n  ln as IsDateString,\n  Je as IsEqual,\n  Zi as IsJSON,\n  Na as IsNumber,\n  x as IsOn,\n  _n as IsStage,\n  qa as IsStageDevFocused,\n  fu as IsStageDevTestFocused,\n  Ja as IsStageTestFocused,\n  qt as IsValidInputDecimal,\n  na as IsVowel,\n  xt as IsWholeNumber,\n  Ve as JSONParse,\n  ti as JSONStringToObject,\n  St as LeastDate,\n  On as LeastNumber,\n  pa as LeastNumberNull,\n  Jn as LeftPad,\n  da as ManualParse,\n  zt as MedianNumber,\n  ht as MonthDatesFromDateISOWeeks,\n  Le as MonthNames,\n  ma as NowISOString,\n  Rt as NumberConstrainToIncrement,\n  Ea as NumberConstrainToIncrementNull,\n  mr as ObjectContainsSearch,\n  se as ObjectContainsSearchTerms,\n  Qi as ObjectDiffs,\n  su as ObjectFromFormData,\n  ta as ObjectToFixedFields,\n  ri as ObjectToJSONString,\n  Pi as ObjectWithChanges,\n  nt as ObjectsToFixedFields,\n  di as OmitFalsey,\n  qe as OmitProperty,\n  Ai as OmitUndefined,\n  Xa as PagesForRange,\n  He as PhoneComponents,\n  Si as PickProperty,\n  ki as PrefixKeys,\n  ji as ProcessMath,\n  gi as PropertiesExist,\n  hi as PropertiesNotFalsey,\n  In as RBGFromHex,\n  Kr as RandomKey,\n  ea as RandomString,\n  or as ReSortOrder,\n  Xi as ReduceObjectToOtherKeys,\n  pn as RemoveDupProperties,\n  qi as RemoveDupPropertiesByID,\n  Ji as RemoveDupPropertiesByIDArray,\n  Di as RemoveEnding,\n  vi as RemoveStarting,\n  T as ReplaceAll,\n  Bt as ReplaceAllMultiple,\n  Dr as ReplaceLinks,\n  Qn as RightPad,\n  Ze as RoundTo,\n  fr as SearchRow,\n  on as SearchRows,\n  gr as SearchSort,\n  Ye as SearchTerms,\n  du as SelectBetweenIDs,\n  Zr as ShortNumber,\n  bi as Sleep,\n  rr as SortColumnUpdate,\n  tn as SortColumns,\n  le as SortCompare,\n  Ca as SortCompareDate,\n  Ma as SortCompareDateNull,\n  Wn as SortCompareNull,\n  ir as SortCompares,\n  tr as SortIndex,\n  Hn as SortIndexNull,\n  lr as SortPerArray,\n  Gn as SortPerArrayNull,\n  ur as SortSplitItems,\n  zn as SortSplitItemsNull,\n  Vn as SplitNonWhiteSpace,\n  Za as Stages,\n  et as StringCompares,\n  cr as StringContainsSearch,\n  Kn as StringContainsSearchTerms,\n  nr as StringFindIsActive,\n  nu as StringGetSets,\n  en as StringHasDateData,\n  Cn as StringHasTimeData,\n  bn as StringHasTimeZoneData,\n  rt as StringIncludesIANA,\n  ga as StringIsIANA,\n  mn as StringOrNumberEqual,\n  ni as StringToByteArray,\n  fn as SubsetEqual,\n  gn as SubsetFormEqual,\n  P as TSDays,\n  z as TSHours,\n  B as TSMinutes,\n  oe as TSMonthsEstimate,\n  pe as TSSeconds,\n  sn as TSWeeks,\n  Fe as TSYearsEstimate,\n  sr as TermsToSearch,\n  Tr as TextToHTML,\n  wa as TimeFloorMinute,\n  X as TimeOnly,\n  Ot as TimeSeries,\n  hu as TimeTrackResolved,\n  gu as TimeTracker,\n  Ut as TimeZoneOlsons,\n  nn as TimeZoneOlsonsAll,\n  $t as TimeZoneOlsonsAmerica,\n  _t as TimeZoneOlsonsAmericaCommon,\n  H as ToArray,\n  Ar as ToCamelCase,\n  Cr as ToCurrency,\n  Or as ToCurrencyBlank,\n  Nr as ToCurrencyDash,\n  br as ToCurrencyMax,\n  v as ToDigits,\n  $r as ToDigitsBlank,\n  Ur as ToDigitsBlankMax,\n  _r as ToDigitsDash,\n  Lr as ToDigitsDashMax,\n  pr as ToDigitsMax,\n  Zn as ToFirstLetterUpper,\n  Qe as ToFirstLetterUpperSmart,\n  Ee as ToID,\n  yr as ToInitials,\n  dr as ToKebabCase,\n  Sr as ToPascalCase,\n  wr as ToPercent,\n  Er as ToPercentBlank,\n  Ir as ToPercentDash,\n  kr as ToPercentMax,\n  hr as ToSnakeCase,\n  Fr as ToStringArray,\n  qn as ToUpperCaseWords,\n  j as ToWords,\n  Gt as Trunc,\n  jn as UCWords,\n  yn as UnselectedIDList,\n  fe as ValidNumbers,\n  ue as WeekDays,\n  dt as WeekNumberAdjust,\n  Et as WeeksFromLabel,\n  Aa as YYYYMMDDHHmmss,\n  it as YYYY_MM_DD_HH_mm_ss,\n  ot as YYYYsMMsDD,\n  ut as YYYYsMMsDDsHHcmmcss,\n  ii as ab2str,\n  $i as consoleLogTable,\n  si as everyAsync,\n  ci as filterAsync,\n  oi as findAsync,\n  Ii as hslRainbow,\n  xa as hslShades,\n  _i as initialChanges,\n  Ra as initialConsoleLogTableDef,\n  ar as initialFilterSortPaginator,\n  Bi as initialIDChanges,\n  Yn as initialSortColumn,\n  Pa as isAB,\n  F as isNullUndefined,\n  li as someAsync,\n  ui as str2ab\n};\n","import {CleanNumber, IPaginatorRequest, IPaginatorResponse} from '@empowerfresh/intelliwake'\n\n/**\n * Creates a paginated response from a request count.\n *\n * @param {IPaginatorRequest} paginatorRequest - The paginator request object.\n * @param {number} rowCount - The total number of rows in the result set.\n * @returns {PaginatorReturnRowCount} - The paginated response.\n */\nexport const PaginatorResponseFromRequestCount = <SORT = Record<string, any>, FILTER = Record<string, any>>(paginatorRequest: IPaginatorRequest<SORT, FILTER>, rowCount: number) =>\n\tPaginatorReturnRowCount<SORT>(PaginatorInitializeResponseFromRequest(paginatorRequest), CleanNumber(rowCount))\n\nexport const PaginatorInitializeResponseFromRequest = <SORT = Record<string, any>, FILTER = Record<string, any>, RES = Record<string, any>>(paginatorRequest: IPaginatorRequest<SORT, FILTER>): IPaginatorResponse<RES> => ({\n\tpage: paginatorRequest.page < 1 ? 1 : paginatorRequest.page,\n\tpageCount: 1,\n\trowCount: 0,\n\tcountPerPage: paginatorRequest.countPerPage,\n\tcurrentOffset: 1,\n\trows: []\n})\n\n/**\n * Applies row count to a paginator response.\n *\n * @param {IPaginatorResponse<T>} paginatorResponse - The paginator response object.\n * @param {number} rowCount - The row count to be applied.\n * @template T - The type of the records in the paginator response.\n */\nexport const PaginatorApplyRowCount = <T = Record<string, any>>(paginatorResponse: IPaginatorResponse<T>, rowCount: number) => {\n\tconsole.warn('\"PaginatorApplyRowCount\" will deprecate for \"PaginatorReturnRowCount\"')\n\tpaginatorResponse.rowCount = CleanNumber(rowCount)\n\n\tif (+rowCount > 0) {\n\t\tpaginatorResponse.pageCount = Math.floor((CleanNumber(rowCount) + (CleanNumber(paginatorResponse.countPerPage - 1))) / CleanNumber(paginatorResponse.countPerPage))\n\n\t\tif (CleanNumber(paginatorResponse.page) < 1) paginatorResponse.page = 1\n\t\tif (CleanNumber(paginatorResponse.page) > CleanNumber(paginatorResponse.pageCount)) paginatorResponse.page = CleanNumber(paginatorResponse.pageCount)\n\n\t\tpaginatorResponse.currentOffset = (+paginatorResponse.page - 1) * +paginatorResponse.countPerPage\n\t} else {\n\t\tpaginatorResponse.pageCount = 0\n\t\tpaginatorResponse.currentOffset = 0\n\t\tpaginatorResponse.page = 1\n\t}\n}\n\n/**\n * Updates the row count and calculates the page count and current offset\n * for a given paginator response.\n *\n * @param {IPaginatorResponse<T>} paginatorResponse - The paginator response object.\n * @param {number} rowCount - The total number of rows.\n * @returns {IPaginatorResponse<T>} - The updated paginator response object.\n */\nexport const PaginatorReturnRowCount = <T = Record<string, any>>(paginatorResponse: IPaginatorResponse<T>, rowCount: number): IPaginatorResponse<T> => {\n\tlet response = {...paginatorResponse}\n\n\tresponse.rowCount = CleanNumber(rowCount)\n\tresponse.page = CleanNumber(response.page)\n\n\tif (response.rowCount > 0) {\n\t\tresponse.pageCount = Math.floor((CleanNumber(rowCount) + (CleanNumber(response.countPerPage) - 1)) / CleanNumber(response.countPerPage))\n\n\t\tif (response.page < 1) response.page = 1\n\t\tif (response.page > response.pageCount) response.page = response.pageCount\n\n\t\tresponse.currentOffset = (response.page - 1) * response.countPerPage\n\t} else {\n\t\tresponse.pageCount = 0\n\t\tresponse.currentOffset = 0\n\t\tresponse.page = 1\n\t}\n\n\treturn response\n}\n","import {ToPascalCase, ToSnakeCase} from '@empowerfresh/intelliwake'\n\nexport class PGEnum {\n\tpublic enumName = ''\n\tpublic values: string[] = []\n\tpublic defaultValue: string | null | undefined\n\t\n\tconstructor(instanceData?: Partial<PGEnum>) {\n\t\tif (instanceData) {\n\t\t\tthis.deserialize(instanceData)\n\t\t}\n\t}\n\t\n\tprivate deserialize(instanceData: Partial<PGEnum>) {\n\t\tconst keys = Object.keys(this)\n\t\t\n\t\tfor (const key of keys) {\n\t\t\tif (instanceData.hasOwnProperty(key)) {\n\t\t\t\t;(this as any)[key] = (instanceData as any)[key]\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic get columnName(): string {\n\t\treturn ToSnakeCase(this.enumName)\n\t}\n\t\n\tpublic get typeName(): string {\n\t\t\treturn this.enumName\n\t}\n\t\n\tstatic TypeName(columnName: string): string {\n\t\treturn ToPascalCase(columnName)\n\t}\n\t\n\tpublic ddlRemove(): string {\n\t\treturn `DROP TYPE IF EXISTS ${this.columnName} CASCADE `\n\t}\n\t\n\tpublic ddlDefinition(): string {\n\t\treturn `CREATE TYPE ${this.columnName} AS ENUM ('${this.values.join('\\',\\'')}')`\n\t}\n}\n","import {PGEnum} from './PGEnum'\nimport {IsOn, ToArray} from '@empowerfresh/intelliwake'\n\nexport interface IPGColumn {\n\tcolumn_name: string\n\tordinal_position: number\n\tcolumn_default: string | number | boolean | null | undefined\n\tis_nullable: 'YES' | 'NO'\n\tudt_name: string | PGEnum\n\tcharacter_maximum_length: number | null\n\tcharacter_octet_length: number | null\n\t/** Total number of digits */\n\tnumeric_precision: number | null\n\t/** Number of digits after the decimal point */\n\tnumeric_scale: number | null\n\tdatetime_precision: number | null\n\tis_identity: 'YES' | 'NO'\n\tis_self_referencing: 'YES' | 'NO'\n\tidentity_generation: 'BY DEFAULT' | null\n\tarray_dimensions: (number | null)[]\n\tcheck: string | null\n\tcheckStringValues: string[]\n\tgeneratedAlwaysAs: string | null\n\t/** Comment on column, except for within {}'s\n\t * {} can contain comma separated values\n\t * {enum: EDeclaration: default_value} or {enum: EDeclaration.default_value} or {enum: EDeclaration}\n\t * {interface: IDeclaration} or {interface: IDeclaration.initialDeclaration} */\n\tcolumn_comment: string\n\tisAutoIncrement: boolean\n}\n\nexport class PGColumn implements IPGColumn {\n\tpublic column_name = ''\n\tpublic ordinal_position = 0\n\tpublic column_default: string | number | boolean | null | undefined = null\n\tpublic is_nullable: 'YES' | 'NO' = 'YES'\n\tpublic udt_name: string | PGEnum = ''\n\tpublic character_maximum_length: number | null = null\n\tpublic character_octet_length: number | null = null\n\t/** Total number of digits */\n\tpublic numeric_precision: number | null = null\n\t/** Number of digits after the decimal point */\n\tpublic numeric_scale: number | null = null\n\tpublic datetime_precision: number | null = null\n\tpublic is_identity: 'YES' | 'NO' = 'NO'\n\tpublic is_self_referencing: 'YES' | 'NO' = 'NO'\n\tpublic identity_generation: 'BY DEFAULT' | null = null\n\tpublic array_dimensions: (number | null)[] = []\n\tpublic check: string | null = null\n\tpublic checkStringValues: string[] = []\n\tpublic generatedAlwaysAs: string | null = null\n\n\t/** Comment on column, except for within {}'s\n\t * {} can contain comma separated values\n\t * {enum: EDeclaration: default_value} or {enum: EDeclaration.default_value} or {enum: EDeclaration}\n\t * {interface: IDeclaration} or {interface: IDeclaration.initialDeclaration} */\n\tpublic column_comment: string = ''\n\tpublic isAutoIncrement = true\n\n\tstatic readonly TYPE_BOOLEAN = 'bool' // Changed from boolean\n\tstatic readonly TYPE_NUMERIC = 'numeric'\n\tstatic readonly TYPE_FLOAT8 = 'float8'\n\tstatic readonly TYPE_POINT = 'point'\n\n\tstatic readonly TYPE_SMALLINT = 'smallint'\n\tstatic readonly TYPE_INTEGER = 'integer'\n\tstatic readonly TYPE_BIGINT = 'bigint'\n\n\tstatic readonly TYPE_VARCHAR = 'varchar'\n\tstatic readonly TYPE_TEXT = 'text'\n\n\tstatic readonly TYPE_JSON = 'json'\n\tstatic readonly TYPE_JSONB = 'jsonb'\n\n\tstatic readonly TYPE_DATE = 'date'\n\tstatic readonly TYPE_TIME = 'time'\n\tstatic readonly TYPE_TIMETZ = 'timetz'\n\tstatic readonly TYPE_TIMESTAMP = 'timestamp'\n\tstatic readonly TYPE_TIMESTAMPTZ = 'timestamptz'\n\n\tstatic readonly TYPE_BYTEA = 'bytea'\n\n\tstatic readonly TYPE_UUID = 'uuid'\n\n\tstatic readonly TYPES_ALL = [\n\t\tPGColumn.TYPE_BOOLEAN,\n\t\tPGColumn.TYPE_NUMERIC,\n\t\tPGColumn.TYPE_FLOAT8,\n\t\tPGColumn.TYPE_POINT,\n\t\tPGColumn.TYPE_SMALLINT,\n\t\tPGColumn.TYPE_INTEGER,\n\t\tPGColumn.TYPE_BIGINT,\n\t\tPGColumn.TYPE_VARCHAR,\n\t\tPGColumn.TYPE_TEXT,\n\t\tPGColumn.TYPE_JSON,\n\t\tPGColumn.TYPE_JSONB,\n\t\tPGColumn.TYPE_BYTEA,\n\t\tPGColumn.TYPE_DATE,\n\t\tPGColumn.TYPE_TIME,\n\t\tPGColumn.TYPE_TIMETZ,\n\t\tPGColumn.TYPE_TIMESTAMP,\n\t\tPGColumn.TYPE_TIMESTAMPTZ,\n\t\tPGColumn.TYPE_UUID\n\t]\n\n\tpublic jsType = (): string => {\n\t\tif (typeof this.udt_name !== 'string') {\n\t\t\treturn (this.udt_name as any).enumName\n\t\t} else if (this.jsonType()) {\n\t\t\treturn 'any'\n\t\t} else if (this.booleanType()) {\n\t\t\treturn 'boolean'\n\t\t} else if (this.integerFloatType()) {\n\t\t\treturn 'number'\n\t\t} else if (this.udt_name === PGColumn.TYPE_BYTEA) {\n\t\t\treturn 'ArrayBuffer'\n\t\t} else if (this.udt_name === PGColumn.TYPE_POINT) {\n\t\t\treturn '[number, number]'\n\t\t} else if (this.udt_name.startsWith('e_')) {\n\t\t\treturn PGEnum.TypeName(this.udt_name)\n\t\t} else {\n\t\t\treturn 'string' // Date or String or Enum\n\t\t}\n\t}\n\n\tpublic isArray = (): boolean => {\n\t\tif (!!ToArray(this.array_dimensions)[0] ||\n\t\t\t!!this.array_dimensions.length ||\n\t\t\t((this.column_default ?? '')?.toString()?.includes('{}') && !this.jsonType()) ||\n\t\t\t(this.column_default ?? '')?.toString()?.includes('[]'))\n\t\t\treturn true\n\n\t\tif (!this.jsonType()) return false\n\n\t\tconst regex = /\\{.*\\[.*\\].*\\}/\n\t\treturn regex.test(this.column_comment ?? '')\n\t}\n\n\tpublic isNullable = (): boolean => IsOn(this.is_nullable)\n\n\tpublic enumType = (): boolean => {\n\t\treturn typeof this.udt_name !== 'string'\n\t}\n\n\tpublic integerType = (): boolean => {\n\t\treturn (typeof this.udt_name === 'string') && (this.udt_name.toLowerCase().startsWith('int') || [PGColumn.TYPE_SMALLINT, PGColumn.TYPE_INTEGER, PGColumn.TYPE_BIGINT].includes(this.udt_name.toLowerCase()))\n\t}\n\n\tpublic floatType = (): boolean => {\n\t\treturn (typeof this.udt_name === 'string') && [PGColumn.TYPE_NUMERIC, PGColumn.TYPE_FLOAT8].includes(this.udt_name.toLowerCase())\n\t}\n\n\tpublic integerFloatType = (): boolean => {\n\t\treturn this.integerType() || this.floatType()\n\t}\n\n\tpublic booleanType = (): boolean => {\n\t\treturn (typeof this.udt_name === 'string') && [PGColumn.TYPE_BOOLEAN].includes(this.udt_name.toLowerCase())\n\t}\n\n\tpublic jsonType = (): boolean => {\n\t\treturn (typeof this.udt_name === 'string') && [PGColumn.TYPE_JSON, PGColumn.TYPE_JSONB].includes(this.udt_name.toLowerCase())\n\t}\n\n\tpublic generalStringType = (): boolean => {\n\t\treturn (typeof this.udt_name !== 'string') || [PGColumn.TYPE_VARCHAR].includes(this.udt_name.toLowerCase())\n\t}\n\n\tpublic dateType = (): boolean => {\n\t\treturn (typeof this.udt_name === 'string') && [\n\t\t\tPGColumn.TYPE_DATE,\n\t\t\tPGColumn.TYPE_TIME,\n\t\t\tPGColumn.TYPE_TIMETZ,\n\t\t\tPGColumn.TYPE_TIMESTAMP,\n\t\t\tPGColumn.TYPE_TIMESTAMPTZ\n\t\t].includes(this.udt_name.toLowerCase())\n\t}\n\n\tpublic dateOnlyType = (): boolean => {\n\t\treturn (typeof this.udt_name === 'string') && [\n\t\t\tPGColumn.TYPE_DATE\n\t\t].includes(this.udt_name.toLowerCase())\n\t}\n\n\tpublic timeOnlyType = (): boolean => {\n\t\treturn (typeof this.udt_name === 'string') && [\n\t\t\tPGColumn.TYPE_TIME,\n\t\t\tPGColumn.TYPE_TIMETZ\n\t\t].includes(this.udt_name.toLowerCase())\n\t}\n\n\tpublic dateTimeOnlyType = (): boolean => {\n\t\treturn (typeof this.udt_name === 'string') && [\n\t\t\tPGColumn.TYPE_TIMESTAMP,\n\t\t\tPGColumn.TYPE_TIMESTAMPTZ\n\t\t].includes(this.udt_name.toLowerCase())\n\t}\n\n\tpublic blobType = (): boolean => {\n\t\treturn (typeof this.udt_name === 'string') && [PGColumn.TYPE_TEXT].includes(this.udt_name.toLowerCase())\n\t}\n\n\tpublic otherType = (): boolean => {\n\t\treturn (\n\t\t\t!this.integerFloatType && !this.booleanType && !this.dateType() && !this.generalStringType() && !this.blobType()\n\t\t)\n\t}\n\n\tconstructor(instanceData?: Partial<IPGColumn>) {\n\t\tif (instanceData) {\n\t\t\tthis.deserialize(instanceData)\n\t\t}\n\t}\n\n\tprivate deserialize(instanceData: Partial<IPGColumn>) {\n\t\tconst keys = Object.keys(this)\n\n\t\tfor (const key of keys) {\n\t\t\tif (instanceData.hasOwnProperty(key) && typeof (instanceData as any) !== 'function') {\n\t\t\t\t;(this as any)[key] = (instanceData as any)[key]\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic clean() {\n\t\t//\t\tif (this.dateType()) {\n\t\t//\t\t\tif (IsEmpty(this.DATETIME_PRECISION) || this.DATETIME_PRECISION < 3 || this.DATETIME_PRECISION > 6) {\n\t\t//\t\t\t\tthis.DATETIME_PRECISION = 6;\n\t\t//\t\t\t}\n\t\t//\t\t}\n\t}\n\n\tpublic ddlDefinition(): string {\n\t\tlet ddl = '\"' + this.column_name + '\" '\n\n\t\tddl += (typeof this.udt_name === 'string') ? this.udt_name : this.udt_name.columnName\n\n\t\tif (this.array_dimensions.length > 0) {\n\t\t\tddl += `[${this.array_dimensions\n\t\t\t               .map((array_dimension) => (!!array_dimension ? array_dimension.toString() : ''))\n\t\t\t               .join('],[')}] `\n\t\t} else {\n\t\t\tif (this.udt_name !== PGColumn.TYPE_POINT) {\n\t\t\t\tif (this.floatType() && this.udt_name !== PGColumn.TYPE_FLOAT8) {\n\t\t\t\t\tddl += '(' + this.numeric_precision + ',' + (this.numeric_scale ?? 0) + ') '\n\t\t\t\t} else if (this.dateType()) {\n\t\t\t\t\tif (!!this.datetime_precision) {\n\t\t\t\t\t\tddl += '(' + this.datetime_precision + ') '\n\t\t\t\t\t} else {\n\t\t\t\t\t\tddl += ' '\n\t\t\t\t\t}\n\t\t\t\t} else if (this.generalStringType()) {\n\t\t\t\t\tif (!this.blobType() && (typeof this.udt_name === 'string')) {\n\t\t\t\t\t\tddl += '(' + (this.character_maximum_length ?? 255) + ') '\n\t\t\t\t\t} else {\n\t\t\t\t\t\tddl += ' '\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tddl += ' '\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tddl += ' '\n\t\t\t}\n\t\t}\n\n\t\tif (!IsOn(this.is_nullable)) {\n\t\t\tddl += 'NOT NULL '\n\t\t}\n\t\tif (!!this.generatedAlwaysAs) {\n\t\t\tddl += `GENERATED ALWAYS AS (${PGColumn.CleanComment(this.generatedAlwaysAs)}) STORED `\n\t\t} else {\n\t\t\tif (typeof this.column_default === 'string' && this.column_default.toLowerCase().includes('null')) {\n\t\t\t\tthis.column_default = null\n\t\t\t}\n\n\t\t\tif ((this.column_default !== undefined && this.column_default !== null) || this.is_identity || this.isAutoIncrement) {\n\t\t\t\tif (!(this.dateType() && (!this.column_default || (this.column_default ?? '').toString().toUpperCase().includes('NULL')))) {\n\t\t\t\t\tif (this.isArray()) {\n\t\t\t\t\t\tif (IsOn(this.is_nullable)) {\n\t\t\t\t\t\t\tddl += `DEFAULT ${this.column_default ?? 'NULL'} `\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tddl += `DEFAULT ${this.column_default ?? ((typeof this.udt_name === 'string') ? '\\'{}\\'' : this.udt_name.defaultValue ?? '\\'{}')} `\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!this.blobType()) {\n\t\t\t\t\t\t\tif (IsOn(this.is_identity)) {\n\t\t\t\t\t\t\t\tif (this.isAutoIncrement) {\n\t\t\t\t\t\t\t\t\tif (!!this.identity_generation) {\n\t\t\t\t\t\t\t\t\t\tddl += `GENERATED ${this.identity_generation} AS IDENTITY `\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tddl += `GENERATED BY DEFAULT AS IDENTITY `\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (this.booleanType()) {\n\t\t\t\t\t\t\t\tif (IsOn(this.is_nullable) || this.column_default === null) {\n\t\t\t\t\t\t\t\t\tddl += `DEFAULT NULL `\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tddl += `DEFAULT ${IsOn(this.column_default) ? 'true' : 'false'} `\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (!this.column_default && (typeof this.udt_name !== 'string') && !!this.udt_name.defaultValue) {\n\t\t\t\t\t\t\t\tddl += `DEFAULT '${this.udt_name.defaultValue}' `\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (!!this.column_default) {\n\t\t\t\t\t\t\t\t\tif (this.integerFloatType() || this.dateType() || (this.column_default ?? '').toString().includes('::') || (this.column_default ?? '').toString().includes('()')) {\n\t\t\t\t\t\t\t\t\t\tddl += `DEFAULT ${this.column_default} `\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tddl += `DEFAULT '${this.column_default}' `\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (IsOn(this.is_nullable)) {\n\t\t\t\t\t\t\t\t\tddl += `DEFAULT NULL `\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (this.integerFloatType()) {\n\t\t\t\t\t\t\t\t\t\tddl += `DEFAULT 0 `\n\t\t\t\t\t\t\t\t\t} else if (this.dateType()) {\n\t\t\t\t\t\t\t\t\t\tddl += `DEFAULT now() `\n\t\t\t\t\t\t\t\t\t\t// if (!!this.datetime_precision) {\n\t\t\t\t\t\t\t\t\t\t// \tddl += `(${this.datetime_precision} `;\n\t\t\t\t\t\t\t\t\t\t// } else {\n\t\t\t\t\t\t\t\t\t\t// \tddl += ` `;\n\t\t\t\t\t\t\t\t\t\t// }\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tddl += `DEFAULT '' `\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!!this.check) {\n\t\t\t\tddl += `CHECK (${this.check}) `\n\t\t\t} else if (this.checkStringValues.length > 0) {\n\t\t\t\tddl += `CHECK (${IsOn(this.is_nullable) ? this.column_name + ' IS NULL OR ' : ''}${this.column_name} IN ('${this.checkStringValues.join('\\', \\'')}')) `\n\t\t\t}\n\t\t}\n\n\t\treturn ddl.trim()\n\t}\n\n\tpublic static CleanComment(comment: string): string {\n\t\tif (!comment) {\n\t\t\treturn comment\n\t\t}\n\n\t\treturn comment.replace(/[\\n\\r]/g, ' ')\n\t}\n}\n","import {PGTable} from './PGTable'\nimport {GreaterNumber} from '@empowerfresh/intelliwake'\n\nexport class PGIndex {\n\tpublic columns: string[] = []\n\tpublic whereCondition: string | null = null\n\tpublic isUnique = false\n\tpublic concurrently = false\n\tpublic using = 'BTREE'\n\n\tconstructor(instanceData?: Partial<PGIndex>) {\n\t\tif (instanceData) {\n\t\t\tthis.deserialize(instanceData)\n\t\t}\n\t}\n\n\tprivate deserialize(instanceData: Partial<PGIndex>) {\n\t\tconst keys = Object.keys(this)\n\n\t\tfor (const key of keys) {\n\t\t\tif (instanceData.hasOwnProperty(key)) {\n\t\t\t\t;(this as any)[key] = (instanceData as any)[key]\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic name(pgTable: PGTable): string {\n\t\treturn (\n\t\t\t'idx_' +\n\t\t\tpgTable.name.substring(GreaterNumber(pgTable.name.length - 25, 0)) +\n\t\t\t'_' +\n\t\t\tthis.columns\n\t\t\t    .map((column) =>\n\t\t\t\t    column\n\t\t\t\t\t    .replace(' ASC', '')\n\t\t\t\t\t    .replace(' DESC', '')\n\t\t\t\t\t    .replace(' NULLS', '')\n\t\t\t\t\t    .replace(' FIRST', '')\n\t\t\t\t\t    .replace(' LAST', '')\n\t\t\t\t\t    .replace('(', '_')\n\t\t\t\t\t    .replace(')', '_')\n\t\t\t\t\t    .trim()\n\t\t\t    )\n\t\t\t    .map(column => column.substring(GreaterNumber(column.length - 25, 0)))\n\t\t\t    .join('_')\n\t\t)\n\t}\n\n\tpublic ddlDefinition(pgTable: PGTable): string {\n\t\tlet ddl = 'CREATE '\n\n\t\tif (this.isUnique) {\n\t\t\tddl += 'UNIQUE '\n\t\t}\n\t\tddl += 'INDEX IF NOT EXISTS '\n\t\tddl += `\"${this.name(pgTable)}\" `\n\t\tddl += 'ON '\n\t\tddl += `\"${pgTable.name}\" `\n\t\tddl += 'USING btree '\n\t\tddl += '(' + this.columns.join(',') + ')'\n\t\tif (this.whereCondition) {\n\t\t\tddl += ' WHERE ' + this.whereCondition\n\t\t}\n\t\tddl += ';'\n\n\t\treturn ddl\n\t}\n}\n","import {PGTable} from './PGTable'\nimport {GreaterNumber} from '@empowerfresh/intelliwake'\n\nexport class PGForeignKey {\n\tpublic columnNames: string[] = []\n\tpublic primaryTable = ''\n\tpublic primaryColumns: string[] = []\n\n\tpublic onDelete = 'RESTRICT'\n\tpublic onUpdate = 'RESTRICT'\n\n\tconstructor(instanceData?: Partial<PGForeignKey>) {\n\t\tif (instanceData) {\n\t\t\tthis.deserialize(instanceData)\n\t\t}\n\t}\n\n\tprivate deserialize(instanceData: Partial<PGForeignKey>) {\n\t\tconst keys = Object.keys(this)\n\n\t\tfor (const key of keys) {\n\t\t\tif (instanceData.hasOwnProperty(key)) {\n\t\t\t\t;(this as any)[key] = (instanceData as any)[key]\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic fkName(pgTable: PGTable) {\n\t\treturn pgTable.name + '_' + this.columnNames.map(column => column.substring(GreaterNumber(column.length-25, 0))).join('_') + '_fkey'\n\t}\n\n\tpublic ddlConstraintDefinition(pgTable: PGTable): string {\n\t\treturn `\n\t\tDO $$\n\t\tBEGIN\n\t\t\tIF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = '${this.fkName(pgTable)}') THEN\n\t\t\t\tALTER TABLE \"${pgTable.name}\"\n\t\t\t\t\tADD CONSTRAINT \"${this.fkName(pgTable)}\"\n\t\t\t\t\tFOREIGN KEY (\"${this.columnNames.join('\",\"')}\") REFERENCES \"${this.primaryTable}\"(\"${this.primaryColumns.join(\n\t\t\t'\",\"'\n\t\t)}\") DEFERRABLE INITIALLY DEFERRED;\n\t\t\tEND IF;\n\t\tEND;\n\t\t$$;` // was INITIALLY IMMEDIATE\n\t}\n}\n","import {PGColumn} from './PGColumn'\nimport {PGIndex} from './PGIndex'\nimport {PGForeignKey} from './PGForeignKey'\nimport {\n\tCleanNumber,\n\tCoalesceFalsey,\n\tIsOn,\n\tRemoveEnding,\n\tReplaceAll,\n\tSortCompare,\n\tStringGetSets,\n\tToArray,\n\tTObjectConstraint,\n\tTObjectFieldConstraint,\n\tYYYY_MM_DD_HH_mm_ss\n} from '@empowerfresh/intelliwake'\nimport {PGEnum} from './PGEnum'\n\nexport const TS_EOL = '\\n' // was \\r\\n\n\nexport interface ICTableRelativePaths extends TPGTableTextOptions {\n\t/** @Common/Tables */\n\tinitials?: string\n\t/** ../Database */\n\ttTables?: string\n\tresponseContext?: string\n\tresponseContextName?: string\n\tresponseContextClass?: string\n}\n\nexport interface IFixedWidthMapOptions {\n\tstartColumnName?: string\n\tstartPosition: number\n\tlastColumnName?: string\n\tstopBeforeColumnName?: string\n}\n\nexport interface IFixedWidthMap<T> {\n\tcolumn_name: keyof T,\n\tstartPosition: number\n\tpositionWidth: number\n}\n\nexport const initialFixedWidthMapOptions: IFixedWidthMapOptions = {\n\tstartPosition: 0\n}\n\nexport type TPGTableTextOptions = {\n\tincludeConstraint?: boolean\n\tsingleQuote?: boolean\n\tspaceInImports?: boolean\n\tnoConstraintKeyQuotes?: boolean,\n\ttabsForObjects?: boolean\n}\n\nexport class PGTable {\n\tpublic name = ''\n\tpublic description = ''\n\tpublic check: string | string[] | null = null\n\n\tpublic inherits: string[] = []\n\n\tpublic columns: PGColumn[] = []\n\n\tpublic indexes: PGIndex[] = []\n\n\tpublic foreignKeys: PGForeignKey[] = []\n\n\tpublic importWithTypes = false\n\n\tconstructor(instanceData?: Partial<PGTable>) {\n\t\tif (instanceData) {\n\t\t\tthis.deserialize(instanceData)\n\t\t}\n\t}\n\n\tprotected deserialize(instanceData: Partial<PGTable>) {\n\t\tconst keys = Object.keys(this)\n\n\t\tfor (const key of keys) {\n\t\t\tif (instanceData.hasOwnProperty(key)) {\n\t\t\t\tswitch (key) {\n\t\t\t\t\tcase 'columns':\n\t\t\t\t\t\tfor (const column of (instanceData as any)[key] as PGColumn[]) {\n\t\t\t\t\t\t\t;(this as any)[key].push(new PGColumn(column))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase 'indexes':\n\t\t\t\t\t\tfor (const index of (instanceData as any)[key] as PGIndex[]) {\n\t\t\t\t\t\t\t;(this as any)[key].push(new PGIndex(index))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase 'foreignKeys':\n\t\t\t\t\t\tfor (const foreignKey of (instanceData as any)[key] as PGForeignKey[]) {\n\t\t\t\t\t\t\t;(this as any)[key].push(new PGForeignKey(foreignKey))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t;(this as any)[key] = (instanceData as any)[key]\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic indexOfColumn(columnName: string): number {\n\t\treturn this.columns.findIndex((column) => column.column_name === columnName)\n\t}\n\n\tpublic indexesOfForeignKeyByColumn(columnName: string): number[] {\n\t\tlet indexes: number[] = []\n\n\t\tfor (let i = 0; i < this.foreignKeys.length; i++) {\n\t\t\tif (this.foreignKeys[i].columnNames.includes(columnName)) {\n\t\t\t\tindexes.push(i)\n\t\t\t}\n\t\t}\n\n\t\treturn indexes\n\t}\n\n\tpublic getForeignKeysByColumn(columnName: string): PGForeignKey[] {\n\t\tlet fks: PGForeignKey[] = []\n\n\t\tconst indexes = this.indexesOfForeignKeyByColumn(columnName)\n\n\t\tfor (const index of indexes) {\n\t\t\tfks.push(this.foreignKeys[index])\n\t\t}\n\n\t\treturn fks\n\t}\n\n\tpublic removeForeignKeysByColumn(columnName: string) {\n\t\tthis.foreignKeys = this.foreignKeys.filter((foreignKey) => !foreignKey.columnNames.includes(columnName))\n\t}\n\n\tpublic renameForeignKeysByColumn(fromName: string, toName: string, pgTables?: PGTable[]) {\n\t\tconst thisObject = this\n\n\t\tthis.foreignKeys.forEach(fk => {\n\t\t\tif (fk.columnNames.includes(fromName)) {\n\t\t\t\tfk.columnNames = [...fk.columnNames.filter(cN => cN !== fromName), toName]\n\t\t\t}\n\t\t})\n\n\t\tif (pgTables) {\n\t\t\tpgTables.filter(pgTable => pgTable.name !== thisObject.name).forEach(pgTable => {\n\t\t\t\tpgTable.foreignKeys.forEach(fk => {\n\t\t\t\t\tif (fk.primaryTable === thisObject.name) {\n\t\t\t\t\t\tif (fk.primaryColumns.includes(fromName)) {\n\t\t\t\t\t\t\tfk.primaryColumns = [...fk.primaryColumns.filter(pC => pC !== fromName), toName]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t}\n\n\tpublic removeIndexsByColumn(columnName: string) {\n\t\tthis.indexes = this.indexes.filter((index) => !index.columns.includes(columnName))\n\t}\n\n\tpublic renameIndexsByColumn(fromName: string, toName: string) {\n\t\tthis.indexes.forEach(idx => {\n\t\t\tif (idx.columns.includes(fromName)) {\n\t\t\t\tidx.columns = [...idx.columns.filter(cN => cN !== fromName), toName]\n\t\t\t}\n\t\t})\n\t}\n\n\tpublic addForeignKey(pgForeignKey: PGForeignKey) {\n\t\tthis.foreignKeys.push(pgForeignKey)\n\t}\n\n\tpublic getColumn(columnName: string): PGColumn | null {\n\t\treturn this.columns.find((column) => column.column_name === columnName) ?? null\n\t}\n\n\tpublic removeColumn(columnName: string) {\n\t\tconst column = this.getColumn(columnName)\n\n\t\tif (!!column) {\n\t\t\tthis.removeForeignKeysByColumn(columnName)\n\t\t\tthis.removeIndexsByColumn(columnName)\n\n\t\t\tthis.columns = this.columns.filter((column) => column.column_name !== columnName)\n\n\t\t\tthis.reOrderColumns()\n\t\t}\n\t}\n\n\tpublic renameColumn(fromName: string, toName: string, pgTables?: PGTable[]) {\n\t\tconst column = this.getColumn(fromName)\n\n\t\tif (!!column) {\n\t\t\tcolumn.column_name = toName\n\n\t\t\tthis.renameForeignKeysByColumn(fromName, toName, pgTables)\n\t\t\tthis.renameIndexsByColumn(fromName, toName)\n\t\t}\n\t}\n\n\tpublic addColumn(pgColumn: Partial<PGColumn>) {\n\t\tconst pgColumnToAdd = new PGColumn(pgColumn)\n\n\t\tif (!pgColumnToAdd.ordinal_position) {\n\t\t\tpgColumnToAdd.ordinal_position = 999999\n\t\t}\n\n\t\tthis.columns = this.columns.filter((column) => column.column_name !== pgColumnToAdd.column_name)\n\n\t\tfor (let i = 0; i < this.columns.length; i++) {\n\t\t\tif (this.columns[i].ordinal_position >= pgColumnToAdd.ordinal_position) {\n\t\t\t\tthis.columns[i].ordinal_position++\n\t\t\t}\n\t\t}\n\n\t\tthis.columns.push(pgColumnToAdd)\n\n\t\tthis.reOrderColumns()\n\t}\n\n\tpublic reOrderColumns() {\n\t\tthis.columns = this.columns.sort((a, b) => a.ordinal_position - b.ordinal_position)\n\n\t\tlet position = 0\n\n\t\tfor (let i = 0; i < this.columns.length; i++) {\n\t\t\tposition++\n\t\t\tthis.columns[i].ordinal_position = position\n\t\t}\n\t}\n\n\tpublic addIndex(pgIndex: PGIndex) {\n\t\tthis.indexes.push(pgIndex)\n\t}\n\n\tpublic tableHeaderText(forTableText: string, modifyStatement = 'DO NOT MODIFY'): string {\n\t\tlet text = '/**' + TS_EOL\n\t\ttext += ' * Automatically generated: ' + YYYY_MM_DD_HH_mm_ss('now') + TS_EOL\n\t\ttext += ' *  ' + (new Date()).getFullYear() + ', Solid Basis Ventures, LLC.' + TS_EOL // Must come after generated date so it doesn't keep regenerating\n\t\ttext += ` * ${modifyStatement}` + TS_EOL\n\t\ttext += ' *' + TS_EOL\n\t\ttext += ' * ' + forTableText + ': ' + this.name + TS_EOL\n\t\tif (!!this.description) {\n\t\t\ttext += ' *' + TS_EOL\n\t\t\ttext += ' * ' + PGTable.CleanComment(this.description) + TS_EOL\n\t\t}\n\t\ttext += ' */' + TS_EOL\n\t\ttext += TS_EOL\n\n\t\treturn text\n\t}\n\n\t/**\n\t * Generates type definitions for a table.\n\t *\n\t * @param options\n\t */\n\tpublic tsText(options?: TPGTableTextOptions): string {\n\t\tlet text = this.tableHeaderText('Table Manager for')\n\n\t\tfunction AddSpaceImport(importObject: string | (string | null)[]) {\n\t\t\treturn !options?.spaceInImports ? ToArray(importObject).filter(iO => !!iO).join(', ') : ' ' + ToArray(importObject).filter(iO => !!iO).join(', ') + ' '\n\t\t}\n\n\t\tfunction AddQuote(item: string | string[]) {\n\t\t\treturn !options?.singleQuote ? `\"${ToArray(item).join('\", \"')}\"` : `'${ToArray(item).join('\\', \\'')}'`\n\t\t}\n\n\t\tif (options?.includeConstraint) {\n\t\t\ttext += `import type {${AddSpaceImport('TObjectConstraint')}} from ${AddQuote(`@empowerfresh/intelliwake`)}${TS_EOL}`\n\t\t}\n\n\t\tif (this.inherits.length > 0) {\n\t\t\tfor (const inherit of this.inherits) {\n\t\t\t\tif (this.importWithTypes) {\n\t\t\t\t\ttext += `import type {${AddSpaceImport(`I${inherit}`)}} from ${AddQuote(`./I${inherit}`)}${TS_EOL}`\n\t\t\t\t\ttext += `import {${AddSpaceImport(`initial_${inherit}`)}} from ${AddQuote(`./I${inherit}`)}${TS_EOL}`\n\t\t\t\t} else {\n\t\t\t\t\ttext += `import {${AddSpaceImport([`I${inherit}`, `initial_${inherit}`])}} from ${AddQuote(`./I${inherit}`)}${TS_EOL}`\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst enums: { column_name: string, enum_name: string, default_value?: string }[] = Array.from(\n\t\t\tnew Set(\n\t\t\t\t[\n\t\t\t\t\t...this.columns\n\t\t\t\t\t       .map((column) => ({\n\t\t\t\t\t\t       column_name: column.column_name,\n\t\t\t\t\t\t       enum_name: (typeof column.udt_name !== 'string' ? column.udt_name.enumName : '')\n\t\t\t\t\t       })),\n\t\t\t\t\t...this.columns\n\t\t\t\t\t       .map((column) => ({\n\t\t\t\t\t\t       column_name: column.column_name,\n\t\t\t\t\t\t       enum_name: (typeof column.udt_name === 'string' && column.udt_name.startsWith('e_') ? PGEnum.TypeName(column.udt_name) : '')\n\t\t\t\t\t       })),\n\t\t\t\t\t...this.columns\n\t\t\t\t\t       .map(column => {\n\t\t\t\t\t\t       const regExp = /{([^}]*)}/\n\t\t\t\t\t\t       const results = regExp.exec(column.column_comment)\n\t\t\t\t\t\t       if (!!results && !!results[1]) {\n\t\t\t\t\t\t\t       const commaItems = results[1].split(',')\n\t\t\t\t\t\t\t       for (const commaItem of commaItems) {\n\t\t\t\t\t\t\t\t       const items = commaItem.split(':')\n\t\t\t\t\t\t\t\t       if ((items[0] ?? '').toLowerCase().trim() === 'enum') {\n\t\t\t\t\t\t\t\t\t       const enumName = items[1]?.split('.')[0]?.trim()\n\t\t\t\t\t\t\t\t\t       let enumDefault = CoalesceFalsey(items[1]?.split('.')[1], items[2], column.column_default)?.toString()?.trim()\n\t\t\t\t\t\t\t\t\t       if (enumDefault?.startsWith('\\'{}\\'')) {\n\t\t\t\t\t\t\t\t\t\t       enumDefault = '[]'\n\t\t\t\t\t\t\t\t\t       }\n\n\t\t\t\t\t\t\t\t\t       // console.info(column.column_name, enumName, enumDefault)\n\n\t\t\t\t\t\t\t\t\t       if (!enumName) {\n\t\t\t\t\t\t\t\t\t\t       throw new Error('Enum requested in comment, but not specified  - Format {Enum: ETest} for nullable or {Enum: ETest.FirstValue}')\n\t\t\t\t\t\t\t\t\t       }\n\t\t\t\t\t\t\t\t\t       if (!IsOn(column.is_nullable) && !enumDefault && !column.isArray()) {\n\t\t\t\t\t\t\t\t\t\t       throw new Error(`Not Nullable Enum requested in comment, but no default value specified for ${this.name}.${column.column_name} - ${column.column_comment}`)\n\t\t\t\t\t\t\t\t\t       }\n\t\t\t\t\t\t\t\t\t       return {\n\t\t\t\t\t\t\t\t\t\t       column_name: column.column_name,\n\t\t\t\t\t\t\t\t\t\t       enum_name: enumName,\n\t\t\t\t\t\t\t\t\t\t       default_value: column.isArray() ?\n\t\t\t\t\t\t\t\t\t\t\t       (IsOn(column.is_nullable) ? 'null' : enumDefault ?? '[]') :\n\t\t\t\t\t\t\t\t\t\t\t       (!enumDefault ? 'null' : `${enumName}.${enumDefault}`)\n\t\t\t\t\t\t\t\t\t       }\n\t\t\t\t\t\t\t\t       }\n\t\t\t\t\t\t\t       }\n\t\t\t\t\t\t       }\n\t\t\t\t\t\t       return {column_name: column.column_name, enum_name: ''}\n\t\t\t\t\t       })\n\t\t\t\t]\n\t\t\t\t\t.filter(enumName => !!enumName.enum_name)\n\t\t\t)\n\t\t)\n\n\t\ttype TInterfaceBuild = {\n\t\t\tcolumn_name: string,\n\t\t\tinterface_name: string,\n\t\t\tdefault_value?: string,\n\t\t\totherImportItem?: string | null\n\t\t}\n\t\tconst interfaces: TInterfaceBuild[] = Array.from(\n\t\t\tnew Set(\n\t\t\t\t[\n\t\t\t\t\t...this.columns\n\t\t\t\t\t       .map(column => {\n\t\t\t\t\t\t       const regExp = /{([^}]*)}/\n\t\t\t\t\t\t       const results = regExp.exec(column.column_comment)\n\t\t\t\t\t\t       if (!!results && !!results[1]) {\n\t\t\t\t\t\t\t       const commaItems = results[1].split(',')\n\t\t\t\t\t\t\t       for (const commaItem of commaItems) {\n\t\t\t\t\t\t\t\t       const items = commaItem.split(':')\n\t\t\t\t\t\t\t\t       if ((items[0] ?? '').toLowerCase().trim() === 'interface') {\n\t\t\t\t\t\t\t\t\t       const interfaceName = items[1]?.split('.')[0]?.trim()\n\t\t\t\t\t\t\t\t\t       let interfaceDefault = (CoalesceFalsey(items[1]?.split('.')[1], items[2], column.column_default)?.toString()?.trim()) ?? (IsOn(column.is_nullable) ? 'null' : '{}')\n\n\t\t\t\t\t\t\t\t\t       if (!interfaceName) {\n\t\t\t\t\t\t\t\t\t\t       throw new Error('Interface requested in comment, but not specified  - Format {Interface: ITest} for nullable or {Interface: ITest.initialValue}')\n\t\t\t\t\t\t\t\t\t       }\n\n\t\t\t\t\t\t\t\t\t       return {\n\t\t\t\t\t\t\t\t\t\t       column_name: column.column_name,\n\t\t\t\t\t\t\t\t\t\t       interface_name: interfaceName,\n\t\t\t\t\t\t\t\t\t\t       otherImportItem: interfaceDefault,\n\t\t\t\t\t\t\t\t\t\t       default_value: column.isArray() ?\n\t\t\t\t\t\t\t\t\t\t\t       (IsOn(column.is_nullable) ? 'null' : interfaceDefault ?? '[]') :\n\t\t\t\t\t\t\t\t\t\t\t       interfaceDefault\n\t\t\t\t\t\t\t\t\t       }\n\t\t\t\t\t\t\t\t       }\n\t\t\t\t\t\t\t       }\n\t\t\t\t\t\t       }\n\t\t\t\t\t\t       return {column_name: column.column_name, interface_name: ''}\n\t\t\t\t\t       })\n\t\t\t\t]\n\t\t\t\t\t.filter(enumName => !!enumName.interface_name)\n\t\t\t)\n\t\t)\n\n\t\ttype TTypeBuild = { column_name: string, type_name: string }\n\t\tconst types = this.columns\n\t\t                  .reduce<TTypeBuild[]>((types, column) => {\n\t\t\t                  const regExp = /{([^}]*)}/\n\t\t\t                  const results = regExp.exec(column.column_comment)\n\t\t\t                  if (!!results && !!results[1]) {\n\t\t\t\t                  const commaItems = results[1].split(',')\n\t\t\t\t                  for (const commaItem of commaItems) {\n\t\t\t\t\t                  const items = commaItem.split(':')\n\t\t\t\t\t                  if ((items[0] ?? '').toLowerCase().trim() === 'type') {\n\t\t\t\t\t\t                  const typeName = items[1]?.split('.')[0]?.trim()\n\n\t\t\t\t\t\t                  if (!typeName) {\n\t\t\t\t\t\t\t                  throw new Error('Type requested in comment, but not specified  - Format {type: TTest}')\n\t\t\t\t\t\t                  }\n\n\t\t\t\t\t\t                  return [...types, {\n\t\t\t\t\t\t\t                  column_name: column.column_name,\n\t\t\t\t\t\t\t                  type_name: typeName\n\t\t\t\t\t\t                  }]\n\t\t\t\t\t                  }\n\t\t\t\t                  }\n\t\t\t                  }\n\t\t\t                  return types\n\t\t                  }, [])\n\n\t\tenums.map(enumItem => enumItem.enum_name)\n\t\t     .reduce<string[]>((results, enumItem) => {\n\t\t\t\t     return results.some(res => res === enumItem) ? results : [...results, ReplaceAll('[]', '', enumItem)]\n\t\t\t     },\n\t\t\t     types.reduce<string[]>((results, typ) => {\n\t\t\t\t     const possibleEnum = ReplaceAll(']', '', typ.type_name.split('[')[1] ?? '')\n\t\t\t\t     if (possibleEnum.startsWith('E')) {\n\t\t\t\t\t     if (!results.some(res => res === possibleEnum)) {\n\t\t\t\t\t\t     return [...results, possibleEnum]\n\t\t\t\t\t     }\n\t\t\t\t     }\n\t\t\t\t     return results\n\t\t\t     }, []))\n\t\t     .reduce<string[]>((results, enumItem) => results.some(result => result === enumItem) ? results : [...results, enumItem], [])\n\t\t     .sort(SortCompare)\n\t\t     .forEach(enumItem => {\n\t\t\t     text += `import ${(this.importWithTypes &&\n\t\t\t\t     !this.columns.some(column => ReplaceAll(' ', '', column.column_comment ?? '').toLowerCase().includes(`{enum:${enumItem.toLowerCase()}`) &&\n\t\t\t\t\t     (ReplaceAll(' ', '', column.column_comment ?? '').toLowerCase().includes(`{enum:${enumItem.toLowerCase()}.`) ||\n\t\t\t\t\t\t     (!!column.column_default &&\n\t\t\t\t\t\t\t     !(column.column_default ?? '').toString().includes('{}') &&\n\t\t\t\t\t\t\t     (column.column_default ?? '').toString().toLowerCase() !== 'null')))) ?\n\t\t\t\t     'type ' : ''}{${AddSpaceImport(enumItem)}} from ${AddQuote(`../Enums/${enumItem}`)}${TS_EOL}`\n\t\t     })\n\n\t\tinterfaces.reduce<TInterfaceBuild[]>((results, interfaceItem) => results.some(result => result.interface_name === interfaceItem.interface_name && (!!result.otherImportItem || !interfaceItem.otherImportItem)) ? results : [...results.filter(result => result.interface_name !== interfaceItem.interface_name), interfaceItem], [])\n\t\t          .sort((a, b) => SortCompare(a.interface_name, b.interface_name))\n\t\t          .forEach(interfaceItem => {\n\t\t\t          text += `import ${this.importWithTypes ? 'type ' : ''}{${AddSpaceImport([interfaceItem.interface_name, (!interfaceItem.otherImportItem || interfaceItem?.otherImportItem?.toLowerCase() === 'null') ? '' : `, ${interfaceItem.otherImportItem}`])}} from ${AddQuote(`../Interfaces/${interfaceItem.interface_name}`)}${TS_EOL}`\n\t\t          })\n\n\t\ttypes.reduce<TTypeBuild[]>((results, typeItem) => {\n\t\t\tconst newName = typeItem.type_name.split('[')[0]\n\t\t\treturn (!newName || results.some(result => result.type_name === newName)) ?\n\t\t\t\tresults :\n\t\t\t\t[...results.filter(result => result.type_name !== newName), {...typeItem, type_name: newName}]\n\t\t}, [])\n\t\t     .sort((a, b) => SortCompare(a.type_name, b.type_name))\n\t\t     .forEach(typeItem => {\n\t\t\t     text += `import ${this.importWithTypes ? 'type ' : ''}{${AddSpaceImport(typeItem.type_name)}} from ${AddQuote(`../Types/${typeItem.type_name}`)}${TS_EOL}`\n\t\t     })\n\n\t\tconst enumReferences = enums\n\t\t\t.filter(enumItem => {\n\t\t\t\tif (enums.filter(eFilter => eFilter.enum_name === enumItem.enum_name).length !== 1) return false\n\n\t\t\t\tif (!this.columns.some(col => (col.column_comment?.toLowerCase())?.includes('{type') &&\n\t\t\t\t\t(col.column_comment?.toLowerCase())?.includes(`[${enumItem.enum_name.toLowerCase()}]`))) return false\n\n\t\t\t\treturn true\n\t\t\t})\n\t\t\t.sort((a, b) => SortCompare(a.enum_name, b.enum_name))\n\n\t\ttext += TS_EOL\n\n\t\tif (this.description) {\n\t\t\ttext += `/** ${this.description} */${TS_EOL}`\n\t\t}\n\n\t\ttext += `export interface I${this.name}`\n\t\tif (enumReferences.length) {\n\t\t\ttext += `<${enumReferences.map(er => `T${er.enum_name} extends ${er.enum_name} = ${er.enum_name}`).join(', ')}>`\n\t\t}\n\t\tif (this.inherits.length > 0) {\n\t\t\ttext += ` extends I${this.inherits.join(', I')}`\n\t\t}\n\t\ttext += ` {` + TS_EOL\n\n\t\tfunction getTSType(pgColumn: PGColumn, eReferences?: typeof enumReferences): string {\n\t\t\tlet tsType = ReplaceAll('[]', '', enums.find(enumItem => enumItem.column_name === pgColumn.column_name)?.enum_name ??\n\t\t\t\tinterfaces.find(interfaceItem => interfaceItem.column_name === pgColumn.column_name)?.interface_name ??\n\t\t\t\ttypes.find(typeItem => typeItem.column_name === pgColumn.column_name)?.type_name ??\n\t\t\t\tpgColumn.jsType()).trim()\n\n\t\t\tif (eReferences?.length) {\n\t\t\t\tif (eReferences.some(er => er.enum_name === tsType)) {\n\t\t\t\t\ttsType = `T${tsType}`\n\t\t\t\t} else {\n\t\t\t\t\tconst bracketValue = (StringGetSets(tsType, '[', ']') ?? [])[0]\n\t\t\t\t\tif (bracketValue && eReferences.some(er => er.enum_name === bracketValue)) {\n\t\t\t\t\t\ttsType = tsType.replace('[', '[T')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// const er = eReferences?.find(er => er.enum_name === )\n\n\n\t\t\tif (pgColumn.array_dimensions.length > 0) {\n\t\t\t\ttsType += `[${pgColumn.array_dimensions.map(() => '').join('],[')}]`\n\t\t\t} else if (pgColumn.isArray()) {\n\t\t\t\ttsType += '[]'\n\t\t\t}\n\t\t\tif (IsOn(pgColumn.is_nullable ?? 'YES')) {\n\t\t\t\ttsType += ' | null'\n\t\t\t}\n\n\t\t\treturn tsType\n\t\t}\n\n\t\tfor (const pgColumn of this.columns) {\n\t\t\t// if (!!pgColumn.column_comment || !!pgColumn.generatedAlwaysAs) {\n\n\t\t\tif (!!PGTable.CleanComment(pgColumn.column_comment)) {\n\t\t\t\ttext += `\\t/** `\n\t\t\t\ttext += `${PGTable.CleanComment(pgColumn.column_comment)} `\n\t\t\t\ttext += `*/${TS_EOL}`\n\t\t\t}\n\t\t\t// if (!!pgColumn.generatedAlwaysAs) {\n\t\t\t// \ttext += `GENERATED AS: ${PGTable.CleanComment(pgColumn.generatedAlwaysAs)} `\n\t\t\t// }\n\t\t\t// }\n\t\t\ttext += '\\t'\n\t\t\ttext += pgColumn.column_name\n\t\t\ttext += ': '\n\t\t\ttext += getTSType(pgColumn, enumReferences)\n\t\t\ttext += TS_EOL\n\t\t}\n\t\ttext += '}' + TS_EOL\n\t\ttext += TS_EOL\n\t\ttext += `export const initial_${this.name}: I${this.name} = {` + TS_EOL\n\t\tlet addComma = false\n\t\tif (this.inherits.length > 0) {\n\t\t\ttext += `\\t...initial_${this.inherits.join(`,${TS_EOL}\\t...initial_`)},${TS_EOL}`\n\t\t}\n\t\tfor (const pgColumn of this.columns) {\n\t\t\tif (addComma) {\n\t\t\t\ttext += ',' + TS_EOL\n\t\t\t}\n\t\t\ttext += '\\t'\n\t\t\ttext += pgColumn.column_name\n\t\t\ttext += ': '\n\t\t\tconst itemDefault = enums.find(enumItem => enumItem.column_name === pgColumn.column_name)?.default_value ?? interfaces.find(interfaceItem => interfaceItem.column_name === pgColumn.column_name)?.default_value\n\n\t\t\t// if (pgColumn.column_name === 'inspect_roles') {\n\t\t\t// \tconsole.log('Column', pgColumn)\n\t\t\t// \tconsole.log('ItemDefault', itemDefault)\n\t\t\t// \tconsole.log('Arry Len', pgColumn.array_dimensions.length)\n\t\t\t// }\n\n\t\t\tif (!!itemDefault) {\n\t\t\t\t// console.log('HERE', enums.find(enumItem => enumItem.column_name === pgColumn.column_name))\n\t\t\t\t// console.log('THERE', pgColumn)\n\t\t\t\tif (itemDefault.endsWith('.') && IsOn(pgColumn.is_nullable) && !pgColumn.column_default) {\n\t\t\t\t\ttext += 'null'\n\t\t\t\t} else {\n\t\t\t\t\ttext += itemDefault\n\t\t\t\t}\n\t\t\t} else if (pgColumn.isArray()) {\n\t\t\t\tif (IsOn(pgColumn.is_nullable)) {\n\t\t\t\t\ttext += 'null'\n\t\t\t\t} else {\n\t\t\t\t\ttext += `[${pgColumn.array_dimensions.map(() => '').join('],[')}]`\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!pgColumn.blobType()) {\n\t\t\t\t\tif (IsOn(pgColumn.is_identity) && pgColumn.isAutoIncrement) {\n\t\t\t\t\t\ttext += '0'\n\t\t\t\t\t} else if (pgColumn.booleanType()) {\n\t\t\t\t\t\tif (IsOn(pgColumn.is_nullable)) {\n\t\t\t\t\t\t\ttext += 'null'\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttext += IsOn(pgColumn.column_default) ? 'true' : 'false'\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (\n\t\t\t\t\t\t!!pgColumn.column_default ||\n\t\t\t\t\t\t(typeof pgColumn.udt_name !== 'string' && !!pgColumn.udt_name.defaultValue)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (pgColumn.dateType()) {\n\t\t\t\t\t\t\ttext += '\\'\\''\n\t\t\t\t\t\t} else if (pgColumn.jsonType()) {\n\t\t\t\t\t\t\tif (CoalesceFalsey(pgColumn.column_default ?? '', '{}').toString().includes('{}')) {\n\t\t\t\t\t\t\t\ttext += '{}'\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttext += (CoalesceFalsey(pgColumn.column_default, '{}') ?? '{}').toString().substring(1, (pgColumn.column_default ?? '').toString().indexOf('::') - 1)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttext += ` as ${getTSType(pgColumn)}`\n\t\t\t\t\t\t} else if (pgColumn.integerFloatType() || pgColumn.dateType()) {\n\t\t\t\t\t\t\ttext += pgColumn.column_default\n\t\t\t\t\t\t} else if (typeof pgColumn.udt_name !== 'string') {\n\t\t\t\t\t\t\ttext +=\n\t\t\t\t\t\t\t\t'\\'' + (pgColumn.column_default ?? pgColumn.udt_name.defaultValue ?? '') + '\\' as ' + pgColumn.jsType()\n\t\t\t\t\t\t} else if (!!pgColumn.column_default && pgColumn.column_default.toString().includes('::')) {\n\t\t\t\t\t\t\tif (pgColumn.udt_name.startsWith('e_')) {\n\t\t\t\t\t\t\t\tconst colDefault = pgColumn.column_default.toString()\n\t\t\t\t\t\t\t\ttext += PGEnum.TypeName(pgColumn.udt_name)\n\t\t\t\t\t\t\t\ttext += '.'\n\t\t\t\t\t\t\t\ttext += colDefault.substring(1, 1 + colDefault.indexOf('::') - 2)\n\t\t\t\t\t\t\t\t// text += ' as '\n\t\t\t\t\t\t\t\t// text += PGEnum.TypeName(pgColumn.udt_name)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttext += '\\'' + (pgColumn.column_default ?? '').toString().substring(1, (pgColumn.column_default ?? '').toString().indexOf('::') - 1) + '\\''\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttext += '\\'' + (pgColumn.column_default ?? '') + '\\''\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (IsOn(pgColumn.is_nullable)) {\n\t\t\t\t\t\ttext += 'null'\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (pgColumn.booleanType()) {\n\t\t\t\t\t\t\ttext += 'true'\n\t\t\t\t\t\t} else if (pgColumn.integerFloatType()) {\n\t\t\t\t\t\t\ttext += '0'\n\t\t\t\t\t\t} else if (pgColumn.dateType()) {\n\t\t\t\t\t\t\ttext += '\\'\\''\n\t\t\t\t\t\t} else if (pgColumn.jsonType()) {\n\t\t\t\t\t\t\ttext += `{} as ${getTSType(pgColumn)}`\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttext += '\\'\\''\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttext += '\\'\\''\n\t\t\t\t}\n\t\t\t}\n\t\t\taddComma = true\n\t\t}\n\t\ttext += TS_EOL + '}' + TS_EOL\n\n\t\tif (options?.includeConstraint) {\n\t\t\tconst constraint: TObjectConstraint = {}\n\n\t\t\tfor (const pgColumn of this.columns) {\n\t\t\t\tconst fieldConstraint: TObjectFieldConstraint = {}\n\n\t\t\t\tif (pgColumn.booleanType()) {\n\t\t\t\t\tfieldConstraint.type = 'boolean'\n\t\t\t\t\tif (pgColumn.column_default && !pgColumn.isArray()) {\n\t\t\t\t\t\tfieldConstraint.default = IsOn(pgColumn.column_default)\n\t\t\t\t\t}\n\t\t\t\t} else if (pgColumn.integerFloatType()) {\n\t\t\t\t\tfieldConstraint.type = 'number'\n\t\t\t\t\tif (pgColumn.numeric_precision) {\n\t\t\t\t\t\tfieldConstraint.length = CleanNumber(pgColumn.numeric_precision)\n\t\t\t\t\t}\n\t\t\t\t\tif (pgColumn.column_default && !pgColumn.isArray()) {\n\t\t\t\t\t\tfieldConstraint.default = CleanNumber(pgColumn.column_default)\n\t\t\t\t\t}\n\t\t\t\t} else if (pgColumn.jsonType()) {\n\t\t\t\t\tfieldConstraint.type = 'object'\n\t\t\t\t} else if (pgColumn.dateOnlyType()) {\n\t\t\t\t\tfieldConstraint.type = 'date'\n\t\t\t\t\tif (pgColumn.column_default && !pgColumn.isArray()) {\n\t\t\t\t\t\tfieldConstraint.default = 'now'\n\t\t\t\t\t}\n\t\t\t\t} else if (pgColumn.dateTimeOnlyType()) {\n\t\t\t\t\tfieldConstraint.type = 'datetime'\n\t\t\t\t\tif (pgColumn.column_default && !pgColumn.isArray()) {\n\t\t\t\t\t\tfieldConstraint.default = 'now'\n\t\t\t\t\t}\n\t\t\t\t} else if (pgColumn.timeOnlyType()) {\n\t\t\t\t\tfieldConstraint.type = 'time'\n\t\t\t\t\tif (pgColumn.column_default && !pgColumn.isArray()) {\n\t\t\t\t\t\tfieldConstraint.default = 'now'\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfieldConstraint.type = 'string'\n\t\t\t\t\tif (pgColumn.character_maximum_length) {\n\t\t\t\t\t\tfieldConstraint.length = pgColumn.character_maximum_length\n\t\t\t\t\t}\n\t\t\t\t\tif (pgColumn.column_default && !pgColumn.isArray()) {\n\t\t\t\t\t\tfieldConstraint.default = ''\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfieldConstraint.nullable = IsOn(pgColumn.is_nullable)\n\n\t\t\t\tif (pgColumn.isArray()) {\n\t\t\t\t\tfieldConstraint.isArray = true\n\t\t\t\t\tif (!fieldConstraint.nullable) {\n\t\t\t\t\t\tfieldConstraint.default = []\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if (pgColumn.column_name === 'sysuser_ids' || pgColumn.column_name === 'freshxpert_sysuser_id')\n\t\t\t\t// \tconsole.log(this.name, pgColumn)\n\n\t\t\t\tconstraint[pgColumn.column_name] = fieldConstraint\n\t\t\t}\n\n\t\t\tlet stringified = JSON.stringify(constraint, undefined, options?.tabsForObjects ? \"\\t\" : 4)\n\n\t\t\tif (options?.noConstraintKeyQuotes) {\n\t\t\t\tstringified = stringified.replace(/\\\"([^(\\\")\"]+)\\\":/g, '$1:')\n\t\t\t}\n\n\t\t\tif (options?.singleQuote) {\n\t\t\t\tstringified = ReplaceAll('\"', '\\'', stringified)\n\t\t\t}\n\n\t\t\ttext += TS_EOL + `export const Constraint_${this.name}: TObjectConstraint<I${this.name}> = ${stringified}` + TS_EOL\n\t\t}\n\n\t\treturn text\n\t}\n\n\t/*export class Cprogress_report_test extends _CTable<Iprogress_report_test> {\n\tpublic readonly table: TTables\n\n\tconstructor(responseContext: ResponseContext, initialValues?: Partial<Iprogress_report_test>) {\n\t\tsuper(responseContext, initialValues, {...initial_progress_report_test})\n\n\t\tthis.table = 'progress_report_test'\n\t}\n}*/\n\n\tpublic static TSTables(tables: string[]): string {\n\t\tlet text = `export type TTables =`\n\t\ttext += TS_EOL\n\t\ttext += '\\t'\n\t\ttext += tables\n\t\t\t.filter(table => !!table)\n\t\t\t.sort((a, b) => SortCompare(a, b))\n\t\t\t.map(table => `'${table}'`)\n\t\t\t.join(TS_EOL + '\\t| ')\n\t\ttext += TS_EOL\n\n\t\treturn text\n\t}\n\n\t/**\n\t * Generates the text for a class that manages the table itself.  Must inherit from a local _CTable base class.\n\t *\n\t * @param relativePaths\n\t */\n\tpublic tsTextTable(relativePaths?: ICTableRelativePaths): string {\n\t\tconst usePaths: Required<ICTableRelativePaths> = {\n\t\t\tinitials: RemoveEnding('/', relativePaths?.initials ?? '@Common/Tables', true),\n\t\t\ttTables: RemoveEnding('/', relativePaths?.tTables ?? '../Database', true),\n\t\t\tresponseContext: RemoveEnding('/', relativePaths?.responseContext ?? '../MiddleWare/ResponseContext', true),\n\t\t\tresponseContextName: relativePaths?.responseContextName ?? 'responseContext',\n\t\t\tresponseContextClass: relativePaths?.responseContextClass ?? 'ResponseContext',\n\t\t\tincludeConstraint: !!relativePaths?.includeConstraint,\n\t\t\tsingleQuote: false,\n\t\t\tspaceInImports: false,\n\t\t\tnoConstraintKeyQuotes: false,\n\t\t\ttabsForObjects: false\n\t\t}\n\n\t\tlet text = this.tableHeaderText('Table Class for', 'MODIFICATIONS WILL NOT BE OVERWRITTEN')\n\t\tif (this.importWithTypes) {\n\t\t\ttext += `import {initial_${this.name}${usePaths.includeConstraint ? `, Constraint_${this.name}` : ''}} from '${usePaths.initials}/I${this.name}'` + TS_EOL\n\t\t\ttext += `import type {I${this.name}} from '${usePaths.initials}/I${this.name}'` + TS_EOL\n\t\t} else {\n\t\t\ttext += `import {initial_${this.name}, I${this.name}} from '${usePaths.initials}/I${this.name}'` + TS_EOL\n\t\t}\n\t\ttext += `import ${this.importWithTypes ? 'type ' : ''}{TTables} from '${usePaths.tTables}/TTables'` + TS_EOL\n\t\ttext += `import {_CTable} from './_CTable'` + TS_EOL\n\t\ttext += `import ${this.importWithTypes ? 'type ' : ''}{${usePaths.responseContextClass}} from '${usePaths.responseContext}'` + TS_EOL\n\t\tfor (const inherit of this.inherits) {\n\t\t\ttext += `import {_C${inherit}} from \"./_C${inherit}\"` + TS_EOL\n\t\t}\n\t\ttext += TS_EOL\n\t\tif (this.description) {\n\t\t\ttext += `/** ${this.description} */${TS_EOL}`\n\t\t}\n\t\ttext += `export class C${this.name} extends _CTable<I${this.name}>`\n\t\tif (this.inherits.length > 0) {\n\t\t\ttext += `, C${this.inherits.join(', C')}`\n\t\t}\n\t\ttext += ` {` + TS_EOL\n\t\ttext += `\\tpublic readonly table: TTables` + TS_EOL\n\t\ttext += TS_EOL\n\t\ttext += `\\tconstructor(${usePaths.responseContextName}: ${usePaths.responseContextClass}) {` + TS_EOL\n\t\ttext += `\\t\\tsuper(${usePaths.responseContextName}, {...initial_${this.name}})` + TS_EOL\n\t\ttext += TS_EOL\n\t\tif (usePaths.includeConstraint) {\n\t\t\ttext += `\\t\\tthis.constraint = Constraint_${this.name}` + TS_EOL\n\t\t}\n\t\ttext += `\\t\\tthis.table = '${this.name}'` + TS_EOL\n\t\ttext += `\\t}` + TS_EOL\n\t\ttext += `}` + TS_EOL\n\n\t\treturn text\n\t}\n\n\tpublic tsTextTableUpdateDescription(currentText: string | null | undefined): string | null {\n\t\tif (!currentText) return null\n\t\tconst currentTextLines = currentText.toString().split(TS_EOL)\n\n\t\tlet classIdx = currentTextLines.findIndex(line => line.startsWith('export class C'))\n\t\tif (classIdx > 0) {\n\t\t\tif (currentTextLines[classIdx - 1]?.startsWith('/** ')) {\n\t\t\t\tcurrentTextLines.splice(classIdx - 1, 1)\n\t\t\t\tif (this.description) {\n\t\t\t\t\tcurrentTextLines.splice(classIdx - 1, 0, `/** ${this.description} */`)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.description) {\n\t\t\t\t\tcurrentTextLines.splice(classIdx, 0, `/** ${this.description} */`)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn currentTextLines.join(TS_EOL)\n\t}\n\n\tpublic ddlPrimaryKey(): string | null {\n\t\tlet found = false\n\n\t\tlet ddl = `PRIMARY KEY (\"`\n\n\t\tfor (const column of this.columns) {\n\t\t\tif (IsOn(column.is_identity)) {\n\t\t\t\tif (found) {\n\t\t\t\t\tddl += `\",\"`\n\t\t\t\t}\n\t\t\t\tddl += column.column_name\n\t\t\t\tfound = true\n\t\t\t}\n\t\t}\n\n\t\tif (found) {\n\t\t\tddl += `\")`\n\n\t\t\treturn ddl\n\t\t}\n\n\t\treturn null\n\t}\n\n\tpublic ddlCreateTableText(createForeignKeys: boolean, createIndexes: boolean, dropFirst = true): string {\n\t\tlet ddl = ''\n\n\t\t/** @noinspection SqlResolve */\n\t\tif (dropFirst) {\n\t\t\tddl += `DROP TABLE IF EXISTS ${this.name} CASCADE;` + TS_EOL\n\t\t}\n\t\tddl += `CREATE TABLE ${this.name}\n\t\t        (` + TS_EOL\n\n\t\tlet prevColumn: PGColumn | null = null\n\t\tfor (const pgColumn of this.columns) {\n\t\t\tif (prevColumn !== null) {\n\t\t\t\tddl += ',' + TS_EOL\n\t\t\t}\n\n\t\t\tddl += '\\t' + pgColumn.ddlDefinition()\n\n\t\t\tprevColumn = pgColumn\n\t\t}\n\t\tconst pk = this.ddlPrimaryKey()\n\t\tif (!!pk) {\n\t\t\tddl += ',' + TS_EOL + '\\t' + pk\n\t\t}\n\n\t\tif (!!this.check) {\n\t\t\tconst checkItems = (typeof this.check === 'string' ? [this.check] : this.check).filter((item) => !!item)\n\n\t\t\tfor (const checkItem of checkItems) {\n\t\t\t\tddl += `,${TS_EOL}\\tCHECK (${checkItem})`\n\t\t\t}\n\t\t}\n\n\t\tddl += TS_EOL\n\t\tddl += ')'\n\n\t\tif (this.inherits.length > 0) {\n\t\t\tddl += TS_EOL + `INHERITS (${this.inherits.join(',')})`\n\t\t}\n\n\t\tddl += ';'\n\n\t\tif (createIndexes) {\n\t\t\tddl += this.ddlCreateIndexes()\n\t\t}\n\n\t\tif (createForeignKeys) {\n\t\t\tddl += this.ddlCreateForeignKeysText()\n\t\t}\n\n\t\tfor (const pgColumn of this.columns.filter(col => !!col.column_comment)) {\n\t\t\tddl += TS_EOL + `COMMENT ON COLUMN ${this.name}.${pgColumn.column_name} IS '${PGTable.CleanComment(pgColumn.column_comment, false)}';`\n\t\t}\n\n\t\treturn ddl\n\t}\n\n\tpublic ddlCreateIndexes(): string {\n\t\tlet ddl = ''\n\n\t\tfor (const index of this.indexes) {\n\t\t\tddl += TS_EOL + index.ddlDefinition(this)\n\t\t}\n\n\t\treturn ddl\n\t}\n\n\tpublic ddlCreateForeignKeysText(): string {\n\t\tlet ddl = ''\n\n\t\tfor (const foreignKey of this.foreignKeys) {\n\t\t\tddl += foreignKey.ddlConstraintDefinition(this) + TS_EOL\n\t\t}\n\n\t\treturn ddl\n\t}\n\n\tpublic static CleanComment(comment: string, stripBrackets = true): string {\n\t\tif (!comment) {\n\t\t\treturn comment\n\t\t}\n\n\t\t// noinspection RegExpRedundantEscape\n\t\treturn stripBrackets ? comment.replace(/[\\n\\r]/g, ' ').replace(/\\{(.+?)\\}/g, '').trim() : comment.replace(/[\\n\\r]/g, ' ').trim()\n\t}\n\n\tpublic fixedWidthMap<T>(options?: Partial<IFixedWidthMapOptions>): IFixedWidthMap<T>[] {\n\t\tconst useOptions: IFixedWidthMapOptions = {...initialFixedWidthMapOptions, ...options}\n\n\t\tlet currentPosition = useOptions.startPosition\n\t\tlet validColumn = !useOptions.startColumnName\n\n\t\tlet fixedWidthMaps: IFixedWidthMap<T>[] = []\n\n\t\tfor (const column of this.columns) {\n\t\t\tif (useOptions.stopBeforeColumnName && column.column_name.toLowerCase() === useOptions.stopBeforeColumnName.toLowerCase()) {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif (!validColumn) {\n\t\t\t\tif (column.column_name.toLowerCase() === useOptions.startColumnName) {\n\t\t\t\t\tvalidColumn = true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (validColumn) {\n\t\t\t\tconst colLength = column.character_maximum_length ?? 0\n\t\t\t\tif (!colLength) {\n\t\t\t\t\tconsole.warn('Could not determine length for FixedWidthMap', column.column_name, column.udt_name)\n\t\t\t\t}\n\t\t\t\tfixedWidthMaps.push({\n\t\t\t\t\tcolumn_name: column.column_name as any,\n\t\t\t\t\tstartPosition: currentPosition,\n\t\t\t\t\tpositionWidth: colLength\n\t\t\t\t})\n\t\t\t\tcurrentPosition += colLength\n\t\t\t}\n\n\t\t\tif (useOptions.lastColumnName && column.column_name.toLowerCase() === useOptions.lastColumnName.toLowerCase()) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\treturn fixedWidthMaps\n\t}\n}\n","import {ReplaceAll} from '@empowerfresh/intelliwake'\n\n/**\n * `PGParams` is a class responsible for managing and substituting placeholders in PostgreSQL queries.\n *\n * When \"add\"ing values, the add() function returns the SQL position, while maintaining an internal array of `values` that then is used as the values of the query, matching the positions injected into the SQL.\n *\n * @remarks\n * This class provides methods for adding values and replacing placeholders in SQL queries. It supports standard and 'LIKE' values for SQL,\n * and also has a provision for nullable fields. It uses the format `$<position>` for placeholders.\n *\n * @example\n * const params = new PGParams()\n * console.log(await PGSQL.FetchOne(connection, `SELECT * FROM employee where id = ${params.add(5)}`, params.values))\n *\n * @public\n */\nexport class PGParams {\n\tlastPosition: number\n\tvalues: any[]\n\n\tconstructor() {\n\t\tthis.lastPosition = 0\n\t\tthis.values = []\n\t}\n\n\t/**\n\t * Resets the state of the component so that it can be cleared and used for another SQL statement.\n\t *\n\t * @remarks\n\t * Call this method when you want to reset\n\t * the values stored in the component to their initial state.\n\t *\n\t * @public\n\t */\n\tpublic reset() {\n\t\tthis.lastPosition = 0\n\t\tthis.values = []\n\t}\n\n\t/**\n\t * Adds a new value, returning the position of the value (like $1, $2, etc.) and appending the value to the 'values' array.\n\t *\n\t * @param value - The value to add to the `values` array.\n\t * @returns A string representing the new position of the added value in the format `$<position>`.\n\t *\n\t * @remarks\n\t * This method will increment the `lastPosition` property and then push the new value to the `values` array.\n\t * It will then return a string representation of the new position of that value.\n\t *\n\t * @example\n\t * const params = new PGParams()\n\t * console.log(await PGSQL.FetchOne(connection, `SELECT * FROM employee where id = ${params.add(5)}`, params.values))\n\t *\n\t * @public\n\t */\n\tpublic add(value: any): string {\n\t\tthis.lastPosition++\n\n\t\tthis.values.push(value)\n\n\t\treturn `$${this.lastPosition}`\n\t}\n\n\t/**\n\t * Adds a new LIKE value by prefix and suffixing the string with %'s, returning the position of the value (like $1, $2, etc.) and appending the value to the 'values' array.\n\t *\n\t * @param value - The value to add to the `values` array with the format '%<value>%'.\n\t * @returns A string representing the new position of the added value in the format `$<position>`.\n\t *\n\t * @remarks\n\t * This method will increment the `lastPosition` property and then push the new value to the `values` array.\n\t * It will then return a string representation of the new position of that value.\n\t *\n\t * @example\n\t * const params = new PGParams()\n\t * console.log(await PGSQL.FetchMany(connection, `SELECT * FROM employee where name ILIKE ${params.addLike(5)}`, params.values))\n\t *\n\t * @public\n\t */\n\tpublic addLike(value: string): string {\n\t\treturn this.add(`%${value}%`)\n\t}\n\n\t/**\n\t * Adds a new value, and if not null returns the position of the value (like $1, $2, etc.) and appending the value to the 'values' array, otherwise changes the SQL to be \"<field>\" IS NULL.\n\t *\n\t * @param field - The name of the field to check.\n\t * @param value - The value to add to the `values` array.\n\t * @returns Either '<field> IS NULL', or '<field> = <position>'.\n\t *\n\t * @remarks\n\t * If not null, this method will increment the `lastPosition` property and then push the new value to the `values` array.\n\t * It will then return a string representation of the new position of that value.\n\t *\n\t * @example\n\t * const params = new PGParams()\n\t * console.log(await PGSQL.FetchMany(connection, `SELECT * FROM employee where ${params.addEqualNullable('salary', null)}`, params.values))\n\t *\n\t * @public\n\t */\n\tpublic addEqualNullable(field: string, value: any): string {\n\t\tif (value === null || value === undefined) {\n\t\t\treturn `${field} IS NULL`\n\t\t} else {\n\t\t\treturn `${field} = ${this.add(value)}`\n\t\t}\n\t}\n\n\t/**\n\t * Replaces placeholders in the given SQL string with actual values from the `values` array.\n\t *\n\t * @param sql - The SQL string with placeholders in the format `$<position>`.\n\t * @returns The SQL string with actual values replacing corresponding placeholders.\n\t *\n\t * @remarks\n\t * This method will take an SQL string, look for placeholder expressions in the format `$<position>`,\n\t * and replace these placeholders with the corresponding values from the `values` array.\n\t * If the value is a string it will be surrounded with quotes.\n\t * The positions are counted from the end of the `values` array to the beginning.\n\t * Please notice that the counter starts from 1, thus the replacement of `$1` corresponds to the last value pushed to the array.\n\t *\n\t * @example\n\t * ```typescript\n\t * replaceSQLWithValues(\"SELECT * FROM users WHERE name = $1 AND age = $2\")\n\t * // Assume $1 corresponds to 'John' and $2 corresponds to 30\n\t * // Returns: \"SELECT * FROM users WHERE name = 'John' AND age = 30\"\n\t * ```\n\t *\n\t * @public\n\t */\n\tpublic replaceSQLWithValues(sql: string): string {\n\t\tlet returnSQL = sql\n\n\t\tfor (let i = this.values.length; i > 0; i--) {\n\t\t\treturnSQL = ReplaceAll(`$${i}`, typeof this.values[i - 1] === 'string' ? `'${this.values[i - 1]}'` : this.values[i - 1], returnSQL)\n\t\t}\n\n\t\treturn returnSQL\n\t}\n}\n","// noinspection SqlNoDataSourceInspection\n\nimport {\n\tCleanNumber,\n\tCleanNumberNull,\n\tDateFormat,\n\tESTTodayDateTimeLabel,\n\tIPaginatorRequest,\n\tIPaginatorResponse,\n\tIsOn,\n\tISortColumn,\n\tIsWholeNumber,\n\tReplaceAll,\n\tToDigits\n} from '@empowerfresh/intelliwake'\nimport {PGTable} from './PGTable'\nimport {PGColumn} from './PGColumn'\nimport {PGParams} from './PGParams'\nimport {PGEnum} from './PGEnum'\nimport {PGIndex} from './PGIndex'\nimport {PGForeignKey} from './PGForeignKey'\nimport type {QueryResult, PoolClient, QueryResultRow, Pool, Client} from 'pg'\nimport pkg from 'pg';\nconst {Client: pkgClient, Pool: pkgPool} = pkg;\n\n// import QueryStream from 'pg-query-stream'\n\n/**\n * `transact` function executes a database transaction using a provided function and returns a promise.\n * The function encapsulates the pattern of acquiring a client from the connection pool, starting a transaction,\n * performing work, committing the transaction, and finally releasing the client back to the pool.\n *\n * @param {function} fn - Async function representing transactional operation. From the client pool, this function receives a PostgreSQL client (PoolClient), and returns a promise.\n *\n * @returns {Promise<TResult>} - A promise that when resolved returns the result of the transaction operation.\n *\n * @remarks\n * - Transactions in PostgreSQL are ACID compliant. If the function `fn` throws an error, changes in that transaction will be rolled back.\n * - Handle any Promise rejections for error handling.\n *\n * @example\n *\n *  transact(async client => {\n *      const users = await client.query('SELECT * FROM users');\n *      return users.rows;\n *  })\n *  .then(users => console.log('Users:', users))\n *  .catch(err => console.error('An error occurred:', err));\n *\n */\ndeclare function transact<TResult>(\n\tfn: (client: PoolClient) => Promise<TResult>\n): Promise<TResult>;\n\n/**\n * `transact` function executes a Promise-returning function within a database transaction and triggers a callback function upon completion.\n *\n * @param {function} fn - An asynchronous function to be run within the transaction. Receives a database client (PoolClient) as argument and returns a Promise.\n * @param {function} cb - Callback function triggered after the transaction completes. Accepts two arguments: an 'error' (null if not present) and an optional transaction 'result'.\n *\n * @returns {void} - This function does not have a return value.\n *\n * @remarks\n * - Transaction function `fn` should ensure database operations are correctly formulated and handle client related errors.\n * - Callback function `cb` must handle error and result scenarios appropriately, providing meaningful feedback to users.\n *\n * @example\n *\n *  transact(\n *    async client => {\n *      const res = await client.query('SELECT * FROM users');\n *      return res.rows;\n *    },\n *    (error, result) => {\n *      if (error) {\n *        console.log('Transaction failed:', error);\n *      } else {\n *        console.log('Transaction successful. Result:', result);\n *      }\n *    }\n *  );\n *\n */\ndeclare function transact<TResult>(\n\tfn: (client: PoolClient) => Promise<TResult>,\n\tcb: (error: Error | null, result?: TResult) => void\n): void;\n\n/**\n * `TConnection` represents a flexible type declaration for a database connection object with PostgreSQL.\n * This includes standard PostgreSQL connections (Pool, PoolClient, Client), as well as custom connection objects\n * with added properties. It is designed to represent PostgreSQL connection objects in all possible configurations.\n *\n * @typedef {Pool | PoolClient | Client | CustomConnection} TConnection\n *\n * @property {boolean=} inTransaction - Optional. If present, indicates whether a transaction is currently active.\n *\n * @returns {TConnection | Promise<TConnection>} Directly returns a `TConnection` object, or if it's obtained asynchronously, a Promise of it.\n *\n * @example\n *\n *   // Using Pool\n *   const poolConnection : TConnection = new Pool(config);\n *\n *   // Using PoolClient\n *   const clientConnection : TConnection = pool.client();\n *\n *   // Using Client\n *   const simpleClient : TConnection = new Client(config);\n *\n *   // Using custom object with additional properties\n *   const customConnection : TConnection =\n *     {\n *       pool: new Pool(),\n *       Client: new Client(),\n *       customProperty: { query: anyFunction, pool: anyPool }\n *     };\n *\n * @remarks\n * - Connect functionality should be properly configured on the connection object.\n * - Transaction scope is managed by `inTransaction` property, if present, and should be handled appropriately.\n */\nexport type TConnection = (Pool | PoolClient | Client | {\n\tpool: Pool;\n\tClient: Client;\n\tquery: Pool['query'];\n\tconnect: Pool['connect'];\n\ttransact: typeof transact;\n} & Record<string, {\n\tpool: Pool;\n\tClient: Client;\n\tquery: Pool['query'];\n\tconnect: Pool['connect'];\n\ttransact: typeof transact;\n}>) & { inTransaction?: boolean } | Promise<(Pool | PoolClient | Client | {\n\tpool: Pool;\n\tClient: Client;\n\tquery: Pool['query'];\n\tconnect: Pool['connect'];\n\ttransact: typeof transact;\n} & Record<string, {\n\tpool: Pool;\n\tClient: Client;\n\tquery: Pool['query'];\n\tconnect: Pool['connect'];\n\ttransact: typeof transact;\n}>) & { inTransaction?: boolean }>\n\n\nexport namespace PGSQL {\n\t/**\n\t * `IOffsetAndCount` interface defines an object structure for pagination purposes in requests. It includes 'offset' and 'countPerPage' properties.\n\t *\n\t * @interface IOffsetAndCount\n\t * @property {number} offset - The starting index from which data should be fetched.\n\t * @property {number} countPerPage - The maximum number of data instances to fetch.\n\t *\n\t * @remarks\n\t * - The `offset` value is usually a multiple of `countPerPage` and represents a page number when divided by `countPerPage`.\n\t *\n\t */\n\texport interface IOffsetAndCount {\n\t\toffset: number\n\t\tcountPerPage: number\n\t}\n\n\n\texport const IgnoreDBMSAlert = '/*NO_DBMS_ALERT*/'\n\n\t/**\n\t * `SetDBMSAlert` function manipulates the 'DB_MS_ALERT' environment variable.\n\t *\n\t * @param {number} [milliseconds] - The new value for 'DB_MS_ALERT' as the alert threshold in milliseconds.\n\t * If unspecified or falsy, 'DB_MS_ALERT' is removed from the environment variables.\n\t *\n\t * @remarks\n\t * - 'DB_MS_ALERT' environment variable is typically used to set a performance alert threshold in MS for database transactions.\n\t * - If the transaction time exceeds this value, an alert could potentially be triggered.\n\t *\n\t * @example\n\t *\n\t *  // Set DB_MS_ALERT to 3000ms\n\t *  SetDBMSAlert(3000);\n\t *\n\t *  // Delete DB_MS_ALERT from environment variables\n\t *  SetDBMSAlert();\n\t *\n\t */\n\texport const SetDBMSAlert = (milliseconds?: number) => {\n\t\tif (!milliseconds) {\n\t\t\tdelete process.env.DB_MS_ALERT\n\t\t} else {\n\t\t\tprocess.env.DB_MS_ALERT = milliseconds.toString()\n\t\t}\n\t}\n\n\texport type TQueryResults<T extends QueryResultRow> = QueryResult<T> // { rows?: Array<T>; fields?: FieldDef[]; rowCount?: number }\n\n\t/**\n\t * `query` function executes an SQL query using a given database connection.\n\t *\n\t * @template T extends QueryResultRow\n\t * @param {TConnection} connection - Contains details necessary to connect to the database.\n\t * @param {string} sql - The SQL statement to execute.\n\t * @param {any} [values] - Optional. Values for SQL parametrization.\n\t * @returns {Promise<TQueryResults<T>>} - Returns a promise that resolves with the query results.\n\t *\n\t * @remarks\n\t * - The promise is logged and then re-thrown in the event of an error.\n\t * - If 'DB_MS_ALERT' is set in the environment variables, long running queries will be logged.\n\t *\n\t * @example\n\t *  // Execute a SELECT query\n\t *  query(dbConnection, \"SELECT * FROM users WHERE age > $1\", [21])\n\t *      .then(res => console.log(res))\n\t *      .catch(err => console.log(err));\n\t */\n\texport const query = async <T extends QueryResultRow>(connection: TConnection, sql: string, values?: any): Promise<TQueryResults<T>> => {\n\t\tconst start = Date.now()\n\n\t\tconst connectionResolved = await Promise.resolve(connection)\n\n\t\treturn connectionResolved.query(sql, values)\n\t\t                         .then(response => {\n\t\t\t                         const alert = CleanNumberNull(process.env.DB_MS_ALERT)\n\t\t\t                         if (alert && !sql.includes(IgnoreDBMSAlert)) {\n\t\t\t\t                         const ms = Date.now() - start\n\t\t\t\t                         if (ms > alert) {\n\t\t\t\t\t                         console.log('----- Long SQL Query', ToDigits(ms), 'ms')\n\t\t\t\t\t                         console.log(sql)\n\t\t\t\t\t                         console.log(values)\n\t\t\t\t                         }\n\t\t\t                         }\n\t\t\t                         return response\n\t\t                         })\n\t\t                         .catch(err => {\n\t\t\t                         console.log('------------ SQL Query')\n\t\t\t                         console.log(DateFormat('LocalDateTime', 'now', 'America/New_York'))\n\t\t\t                         console.log(err.message)\n\t\t\t                         console.log(\"Error Code:\", err.code || 'No code')\n\t\t\t                         console.log(\"Error Detail:\", err.detail || 'No detail')\n\t\t\t                         console.log(\"Error Position:\", err.position || 'No position')\n\t\t\t                         console.log(\"Error Stack:\", err.stack || 'No stack trace')\n\t\t\t                         console.log(sql)\n\t\t\t                         console.log(values)\n\t\t\t                         throw err\n\t\t                         })\n\t}\n\t// {\n\t// \ttry {\n\t// \t\tif (!process.env.DB_MS_ALERT) {\n\t// \t\t\treturn connection.query(sql, values)\n\t// \t\t} else {\n\t// \t\t\tconst start = Date.now()\n\t// \t\t\tconst response = await connection.query(sql, values)\n\t// \t\t\tconst ms = Date.now() - start\n\t// \t\t\tif (ms > CleanNumber(process.env.DB_MS_ALERT)) {\n\t// \t\t\t\tconsole.log('----- Long SQL Query', ToDigits(ms), 'ms')\n\t// \t\t\t\tconsole.log(sql)\n\t// \t\t\t\tconsole.log(values)\n\t// \t\t\t}\n\t// \t\t\treturn response\n\t// \t\t}\n\t// \t} catch (err) {\n\t// \t\tconsole.log('------------ SQL Query')\n\t// \t\tconsole.log(DateFormat('LocalDateTime', 'now', 'America/New_York'))\n\t// \t\tconsole.log(err.message)\n\t// \t\tconsole.log(sql)\n\t// \t\tconsole.log(values)\n\t// \t\tthrow err\n\t// \t}\n\t//\n\t// \t// return await new Promise((resolve, reject) => {\n\t// \t// \t// const stackTrace = new Error().stack\n\t// \t// \tconst res = await connection.query(sql, values)\n\t// \t// \tconnection\n\t// \t// \t\t.query(sql, values)\n\t// \t// \t\t.then(res => {\n\t// \t// \t\t\tresolve({rows: res.rows, fields: res.fields, rowCount: res.rowCount})\n\t// \t// \t\t})\n\t// \t// \t\t.catch(err => {\n\t// \t// \t\t\t// console.log('------------ SQL')\n\t// \t// \t\t\t// console.log(sql)\n\t// \t// \t\t\t// console.log(values)\n\t// \t// \t\t\t// console.log(err)\n\t// \t// \t\t\t// console.log(stackTrace)\n\t// \t// \t\t\t// throw 'SQL Error'\n\t// \t// \t\t\treject(`${err.message}\\n${sql}\\n${JSON.stringify(values ?? {})}`)\n\t// \t// \t\t})\n\t// \t// })\n\t// }\n\n\n\t/**\n\t * `timeout` function returns a Promise that resolves after the specified duration in milliseconds.\n\t *\n\t * @function timeout\n\t * @param {number} ms - Delay in milliseconds before Promise resolves.\n\t * @returns {Promise<void>} - Promise that resolves after 'ms' milliseconds.\n\t *\n\t * @remarks\n\t * - Useful for creating artificial delay in promise chains or async functions.\n\t * - Be mindful of adding delays as they can slow down application execution.\n\t *\n\t * @example\n\t * // Delay execution for 2 seconds\n\t * timeout(2000).then(() => console.log(\"2 seconds have passed\"));\n\t *\n\t * // Can be used with async/await as well\n\t * await timeout(2000);\n\t * console.log(\"2 seconds have passed\");\n\t */\n\texport const timeout = async (ms: number) => {\n\t\treturn new Promise(resolve => {\n\t\t\tsetTimeout(resolve, ms)\n\t\t})\n\t}\n\n\n\t/**\n\t * `TableRowCount` asynchronously retrieves the count of rows in a specific database table.\n\t *\n\t * @param {TConnection} connection - Object containing DB connection details.\n\t * @param {string} table - The name of the target database table.\n\t * @param {string} [schema] - Optional. The name of the schema where the table resides.\n\t * @returns {Promise<number>} - Returns a promise that resolves with number of rows in the table.\n\t *\n\t * @remarks\n\t * - Make sure that the provided connection object is valid and authorized to read the specified table.\n\t *\n\t * @example\n\t *  // Fetch row count from the 'users' table in default schema\n\t *  TableRowCount(dbConnection, 'users')\n\t *      .then(count => console.log('Number of users: ', count))\n\t *      .catch(err => console.log(err));\n\t *\n\t *  // Fetch row count from the 'orders' table in 'sales' schema\n\t *  TableRowCount(dbConnection, 'orders', 'sales')\n\t *      .then(count => console.log('Number of orders: ', count))\n\t *      .catch(err => console.log(err));\n\t *\n\t */\n\texport const TableRowCount = async (connection: TConnection, table: string, schema?: string): Promise<number> => {\n\t\tconst data = await query(connection, `SELECT COUNT(*) AS count\n\t\t                                      FROM ${(!!schema ? `${schema}.` : '') + table}`, undefined)\n\n\t\treturn (((data.rows ?? [])[0] ?? {}) as any)['count'] ?? 0\n\t}\n\n\t/**\n\t * `CurrentSchema` function defaults to string 'public' if no schema name provided.\n\t *\n\t * @function CurrentSchema\n\t * @param {string} [schema] - Optional. Name of the database schema.\n\t * @returns {string} - The provided schema name, or 'public' if no schema is given.\n\t *\n\t * @example\n\t * // Returns: 'public'\n\t * let activeSchema = CurrentSchema();\n\t * console.log(\"Active schema is:\", activeSchema);\n\t *\n\t * // Returns: 'users'\n\t * activeSchema = CurrentSchema('users');\n\t * console.log(\"Active schema is:\", activeSchema);\n\t */\n\texport const CurrentSchema = (schema?: string) => schema ?? 'public'\n\n\n\t/**\n\t * `CurrentSchema` function returns database schema name, defaults to 'public' if none provided.\n\t *\n\t * @param {TConnection} connection - The connection object to the database. All SQL queries will be executed over this connection.\n\t * @param {string} table - The name of the table for which the existence check is performed.\n\t * @param {string} [schema] - Optional. Name of the database schema.\n\t * @returns {string} - Provided schema name or 'public' if no schema is given.\n\t *\n\t * @remarks\n\t * - This function is handy when you want to ensure a schema name is available.\n\t *\n\t * @example\n\t * // Returns: 'public'\n\t * console.log(CurrentSchema());\n\t *\n\t * // Returns: 'users'\n\t * console.log(CurrentSchema('users'));\n\t *\n\t */\n\texport const TableExists = async (connection: TConnection, table: string, schema?: string): Promise<boolean> => {\n\t\tconst sql = `SELECT COUNT(*) AS count\n\t\t             FROM information_schema.tables\n\t\t             WHERE table_schema = '${CurrentSchema(schema)}'\n\t\t\t           AND table_name = '${table}'`\n\n\t\tconst data = await query(connection, sql, undefined)\n\n\t\treturn ((((data.rows ?? [])[0] ?? {}) as any)['count'] ?? 0) > 0\n\t}\n\n\t/**\n\t * `TableColumnExists` function checks if a specific column exists in a database table.\n\t *\n\t * @param {TConnection} connection - Database connection details.\n\t * @param {string} table - The target table name.\n\t * @param {string} column - The target column name.\n\t * @param {string} [schema] - Optional. The schema where the table resides.\n\t * @returns {Promise<boolean>} - Returns a promise that resolves with a boolean. 'true' if column exists, 'false' otherwise.\n\t *\n\t * @example\n\t *  // Check if 'email' column exists in 'users' table located in default schema\n\t *  TableColumnExists(dbConnection, 'users', 'email')\n\t *      .then(exists => console.log(\"'email' column in 'users' table exists: \", exists))\n\t *      .catch(err => console.log(err));\n\t *\n\t *  // Check if 'price' column exists in 'products' table located in 'sales' schema\n\t *  TableColumnExists(dbConnection, 'products', 'price', 'sales')\n\t *      .then(exists => console.log(\"'price' column in 'sales.products' table exists: \", exists))\n\t *      .catch(err => console.log(err));\n\t */\n\texport const TableColumnExists = async (connection: TConnection, table: string, column: string, schema?: string): Promise<boolean> => {\n\t\tconst sql = `SELECT COUNT(*) AS count\n\t\t             FROM information_schema.COLUMNS\n\t\t             WHERE table_schema = '${CurrentSchema(schema)}'\n\t\t\t           AND table_name = '${table}'\n\t\t\t           AND column_name = '${column}'`\n\t\tconst data = await query(connection, sql, undefined)\n\t\treturn ((((data.rows ?? [])[0] ?? {}) as any)['count'] ?? 0) > 0\n\t}\n\n\t/**\n\t * `TriggerExists` function checks the existence of a specific trigger in the database schema.\n\t *\n\t * @param {TConnection} connection - Object holding DB connection details.\n\t * @param {string} trigger - Name of the trigger.\n\t * @param {string} [schema] - Optional. The name of the schema where the trigger resides.\n\t * @returns {Promise<boolean>} - Promise that resolves with boolean indication of trigger's presence.\n\t *\n\t * @example\n\t * // Check existence of 'user_audit' trigger in the default schema\n\t * TriggerExists(dbConnection, 'user_audit')\n\t *      .then(exists => console.log(\"Trigger 'user_audit' exists: \", exists))\n\t *      .catch(err => console.log(err));\n\t *\n\t * // Check existence of 'sales_audit' trigger in the 'sales' schema\n\t * TriggerExists(dbConnection, 'sales_audit', 'sales')\n\t *     .then(exists => console.log(\"Trigger 'sales.sales_audit' exists: \", exists))\n\t *     .catch(err => console.log(err));\n\t */\n\texport const TriggerExists = async (connection: TConnection, trigger: string, schema?: string): Promise<boolean> => {\n\t\tconst sql = `SELECT COUNT(*) AS count\n\t\t             FROM information_schema.triggers\n\t\t             WHERE trigger_schema = '${CurrentSchema(schema)}'\n\t\t\t           AND trigger_name = '${trigger}'`\n\t\tconst data = await query(connection, sql, undefined)\n\t\treturn ((((data.rows ?? [])[0] ?? {}) as any)['count'] ?? 0) > 0\n\t}\n\n\t/**\n\t * `TableResetIncrement` function resets the auto-increment value of a specific column in a table.\n\t *\n\t * @param {TConnection} connection - Database connection details.\n\t * @param {string} table - The table to reset auto-increment.\n\t * @param {string} column - The column where auto-increment needs to be reset.\n\t * @param {number} [toID] - Optional. The value to reset auto-increment to. If not provided, sets to max usage.\n\t * @returns {Promise<void>} - Returns a promise which resolves when operation is complete.\n\t *\n\t * @example\n\t * // Reset auto-increment of \"id\" column in \"users\" table to highest used value\n\t * TableResetIncrement(dbConnection, 'users', 'id')\n\t *    .then(() => console.log(\"'users.id' increment reset to max used value.\"))\n\t *    .catch(err => console.log(err));\n\t *\n\t * // Reset auto-increment of \"id\" column in \"products\" table to 1000\n\t * TableResetIncrement(dbConnection, 'products', 'id', 1000)\n\t *    .then(() => console.log(\"'products.id' increment reset to 1000.\"))\n\t *    .catch(err => console.log(err));\n\t */\n\texport const TableResetIncrement = async (connection: TConnection, table: string, column: string, toID?: number) => {\n\t\tif (!!toID) {\n\t\t\treturn PGSQL.Execute(\n\t\t\t\tconnection,\n\t\t\t\t`SELECT setval(pg_get_serial_sequence('${table}', '${column}'), ${toID});\n\t\t\t`\n\t\t\t)\n\t\t} else {\n\t\t\treturn PGSQL.Execute(\n\t\t\t\tconnection,\n\t\t\t\t`SELECT SETVAL(PG_GET_SERIAL_SEQUENCE('${table}', '${column}'), MAX(${column}))\n\t\t\t\t FROM ${table};\n\t\t\t\t`\n\t\t\t)\n\t\t}\n\t}\n\n\t/**\n\t * `ConstraintExists` function verifies the existence of a particular constraint.\n\t *\n\t * @param {TConnection} connection - Holds database connection details.\n\t * @param {string} constraint - The name of the constraint to check.\n\t * @param {string} [schema] - Optional. The name of the schema where constraint resides.\n\t * @returns {Promise<boolean>} - Promise that resolves to boolean indicating the existence of constraint.\n\t *\n\t * @example\n\t * // Verify the existence of constraint 'fk_user' in the default schema\n\t * ConstraintExists(dbConnection, 'fk_user')\n\t *    .then(exists => console.log(\"'fk_user' exists: \", exists))\n\t *    .catch(err => console.log(err));\n\t *\n\t * // Verify the existence of constraint 'fk_order' in the 'sales' schema\n\t * ConstraintExists(dbConnection, 'fk_order', 'sales')\n\t *    .then(exists => console.log(\"'sales.fk_order' exists: \", exists))\n\t *    .catch(err => console.log(err));\n\t */\n\texport const ConstraintExists = async (connection: TConnection, constraint: string, schema?: string): Promise<boolean> => {\n\t\tconst sql = `\n\t\t\tSELECT COUNT(*) AS count\n\t\t\tFROM information_schema.table_constraints\n\t\t\tWHERE constraint_schema = '${CurrentSchema(schema)}'\n\t\t\t  AND constraint_name = '${constraint}'`\n\t\tconst data = await query(connection, sql, undefined)\n\t\treturn ((((data.rows ?? [])[0] ?? {}) as any)['count'] ?? 0) > 0\n\t}\n\n\n\t/**\n\t * Interface representing constraints for a table.\n\t *\n\t * @interface IConstraints\n\t */\n\texport interface IConstraints {\n\t\ttable_name: string\n\t\tconstraint_name: string\n\t}\n\n\t/**\n\t * `FKConstraints` function fetches foreign key constraints from a particular schema in a database.\n\t *\n\t * @param {TConnection} connection - Database connection details.\n\t * @param {string} [schema] - Optional. The schema to fetch constraints from.\n\t * @returns {Promise<IConstraints[]>} - Promise resolving to an array of foreign key constraints.\n\t *\n\t * @example\n\t * // Fetch foreign key constraints from the default schema\n\t * FKConstraints(dbConnection)\n\t *    .then(constraints => console.log(\"FK Constraints in default schema:\", constraints))\n\t *    .catch(err => console.log(err));\n\t *\n\t * // Fetch foreign key constraints from the 'sales' schema\n\t * FKConstraints(dbConnection, 'sales')\n\t *    .then(constraints => console.log(\"FK Constraints in 'sales' schema:\", constraints))\n\t *    .catch(err => console.log(err));\n\t */\n\texport const FKConstraints = async (connection: TConnection, schema?: string): Promise<IConstraints[]> => {\n\t\tconst sql = `\n\t\t\tSELECT table_name, constraint_name\n\t\t\tFROM information_schema.table_constraints\n\t\t\tWHERE constraint_schema = '${CurrentSchema(schema)}'\n\t\t\t  AND constraint_type = 'FOREIGN KEY'`\n\n\t\treturn PGSQL.FetchMany<IConstraints>(connection, sql)\n\t}\n\n\t/**\n\t * `Functions` function fetches a list of function names from a specific schema in a database.\n\t *\n\t * @param {TConnection} connection - Database connection details.\n\t * @param {string} [schema] - Optional. The schema to fetch functions from.\n\t * @returns {Promise<string[]>} - Promise resolving to an array of function names.\n\t *\n\t * @example\n\t * // Fetch function names from the default schema\n\t * Functions(dbConnection)\n\t *    .then(functions => console.log(\"Functions in default schema:\", functions))\n\t *    .catch(err => console.log(err));\n\t *\n\t * // Fetch function names from the 'users' schema\n\t * Functions(dbConnection, 'users')\n\t *    .then(functions => console.log(\"Functions in 'users' schema:\", functions))\n\t *    .catch(err => console.log(err));\n\t */\n\texport const Functions = async (connection: TConnection, schema?: string): Promise<string[]> => {\n\t\tconst sql = `\n\t\t\tSELECT routines.routine_name\n\t\t\tFROM information_schema.routines\n\t\t\tWHERE routines.specific_schema = '${CurrentSchema(schema)}'\n\t\t\t  AND routine_type = 'FUNCTION'\n\t\t\tORDER BY routines.routine_name`\n\n\t\treturn (await PGSQL.FetchArray<string>(connection, sql)).filter(func => func.startsWith('func_'))\n\t}\n\n\t/**\n\t * `IndexExists` function verifies the existence of a specific index in a particular table.\n\t *\n\t * @param {TConnection} connection - Database connection details.\n\t * @param {string} tablename - Name of the table to inspect.\n\t * @param {string} indexName - Name of the index to verify.\n\t * @param {string} [schema] - Optional. The schema where the table resides.\n\t * @returns {Promise<boolean>} - Promise resolving to boolean, `true` if index exists, else `false`.\n\t *\n\t * @example\n\t * // Check if 'idx_name' exists in the 'users' table of default schema\n\t * IndexExists(dbConnection, 'users', 'idx_name')\n\t *    .then(exists => console.log(\"Index 'idx_name' in 'users': \", exists))\n\t *    .catch(err => console.log(err));\n\t *\n\t * // Check if 'idx_userId' exists in the 'orders' table of 'sales' schema\n\t * IndexExists(dbConnection, 'orders', 'idx_userId', 'sales')\n\t *    .then(exists => console.log(\"Index 'idx_userId' in 'sales.orders': \", exists))\n\t *    .catch(err => console.log(err));\n\t */\n\texport const IndexExists = async (\n\t\tconnection: TConnection,\n\t\ttablename: string,\n\t\tindexName: string, schema?: string\n\t): Promise<boolean> => {\n\t\tconst sql = `SELECT COUNT(*) AS count\n\t\t             FROM pg_indexes\n\t\t             WHERE schemaname = '${CurrentSchema(schema)}'\n\t\t\t           AND tablename = '${tablename}'\n\t\t\t           AND indexname = '${indexName}'`\n\t\tconst data = await query(connection, sql, undefined)\n\t\treturn ((((data.rows ?? [])[0] ?? {}) as any)['count'] ?? 0) > 0\n\t}\n\n\t/**\n\t * `GetByID` function retrieves a row from a specific table based on row ID.\n\t *\n\t * @template T - The type of the row to retrieve.\n\t * @param {TConnection} connection - Holds database connection details.\n\t * @param {string} table - The table to fetch the row from.\n\t * @param {number | null} id - The ID of the row to retrieve, null to return null.\n\t * @returns {Promise<T | null>} - Promise that resolves to the retrieved row, or null if not found.\n\t *\n\t * @example\n\t * // Get a user with ID 5 from the 'users' table\n\t * GetByID(dbConnection, 'users', 5)\n\t *    .then(user => console.log(\"User with ID 5:\", user))\n\t *    .catch(err => console.log(err));\n\t *\n\t * // Attempt to get a user with null ID (returns null)\n\t * GetByID(dbConnection, 'users', null)\n\t *    .then(user => console.log(\"User with null ID:\", user)) // Will log \"User with null ID: null\"\n\t *    .catch(err => console.log(err));\n\t */\n\texport const GetByID = async <T extends QueryResultRow>(connection: TConnection, table: string, id: number | null): Promise<T | null> => {\n\t\tif (!id) {\n\t\t\treturn Promise.resolve(null)\n\t\t} else {\n\t\t\t// noinspection SqlResolve\n\t\t\tconst sql = `SELECT *\n\t\t\t             FROM ${table}\n\t\t\t             WHERE id = $1`\n\t\t\tconst data = await query<T>(connection, sql, [id])\n\n\t\t\treturn !!(data.rows ?? [])[0] ? {...(data.rows ?? [])[0]} : null\n\t\t}\n\t}\n\n\t/**\n\t * `GetCountSQL` function executes a SQL query and returns the count.\n\t *\n\t * @param {TConnection} connection - Database connection details.\n\t * @param {string} sql - The SQL query to execute (\"SELECT COUNT(*) ...\").\n\t * @param {any} [values] - Optional. Values for SQL query parameters.\n\t * @returns {Promise<number>} - Promise resolving to the count as a number.\n\t *\n\t * @example\n\t * // Get count of users from 'users' table\n\t * const sql = \"SELECT COUNT(*) FROM users\";\n\t * GetCountSQL(dbConnection, sql)\n\t *    .then(count => console.log(\"Number of users:\", count))\n\t *    .catch(err => console.log(err));\n\t *\n\t * // Get count of users older than 30 from 'users' table\n\t * const sqlWithParams = \"SELECT COUNT(*) FROM users WHERE age > $1\";\n\t * const values = [30];\n\t * GetCountSQL(dbConnection, sqlWithParams, values)\n\t *    .then(count => console.log(\"Number of users older than 30:\", count))\n\t *    .catch(err => console.log(err));\n\t */\n\texport const GetCountSQL = async (connection: TConnection, sql: string, values?: any): Promise<number> => {\n\t\tconst data = await query(connection, sql, values)\n\n\t\treturn CleanNumber((((data.rows ?? [])[0] ?? {}) as any)['count'] ?? (((data.rows ?? [])[0] ?? {}) as any)[0], 0)\n\t\t// return isNaN(value) ? 0 : parseInt(value)\n\t}\n\n\t/**\n\t * `FetchOne` function fetches a single row from the database using a SQL query and parameter values.\n\t *\n\t * @template T - The type of the row to retrieve.\n\t * @param {TConnection} connection - Holds database connection details.\n\t * @param {string} sql - The SQL query to execute.\n\t * @param {any} [values] - Optional. Values for sql query parameters.\n\t * @returns {Promise<T | null>} - Promise resolving to fetched row or null if no row is found.\n\t *\n\t * @example\n\t * // Fetch a user who is exactly age 30 from 'users' table\n\t * const sql = \"SELECT * FROM users WHERE age = $1 LIMIT 1\";\n\t * const values = [30];\n\t * FetchOne(dbConnection, sql, values)\n\t *    .then(user => console.log(\"User of age 30:\", user))\n\t *    .catch(err => console.log(err));\n\t *\n\t * // Fetch first user from 'users' table\n\t * const sqlFirstUser = \"SELECT * FROM users LIMIT 1\";\n\t * FetchOne(dbConnection, sqlFirstUser)\n\t *    .then(user => console.log(\"First user: \", user))\n\t *    .catch(err => console.log(err));\n\t */\n\texport const FetchOne = async <T extends QueryResultRow>(connection: TConnection, sql: string, values?: any): Promise<T | null> => {\n\t\t// noinspection SqlResolve\n\t\tconst data = await query<T>(connection, sql, values)\n\t\treturn !!(data.rows ?? [])[0] ? {...(data.rows ?? [])[0]} : null\n\t}\n\n\t/**\n\t * `FetchOneValue` function fetches the first value from the result set of a database query.\n\t *\n\t * @template T - The type of the value to retrieve.\n\t * @param {TConnection} connection - Holds database connection details.\n\t * @param {string} sql - The SQL query to execute.\n\t * @param {any} [values] - Optional. Values for SQL query parameters.\n\t * @returns {Promise<T | null>} - Promise resolving to the first fetched value or null if none is found.\n\t *\n\t * @example\n\t * // Fetch the age of first user from 'users' table\n\t * const sqlCommand = \"SELECT age FROM users LIMIT 1\";\n\t * FetchOneValue(dbConnection, sqlCommand)\n\t *    .then(age => console.log(\"Age of first user: \", age))\n\t *    .catch(err => console.log(err));\n\t *\n\t * // Fetch the name of a user who is ID 5 in 'users' table\n\t * const sqlWithParams = \"SELECT name FROM users WHERE id = $1\";\n\t * const paramValues = [5];\n\t * FetchOneValue(dbConnection, sqlWithParams, paramValues)\n\t *    .then(name => console.log(\"Name of user with ID 5: \", name))\n\t *    .catch(err => console.log(err));\n\t */\n\texport const FetchOneValue = async <T>(connection: TConnection, sql: string, values?: any): Promise<T | null> => {\n\t\treturn (Object.values((await FetchOne<any>(connection, sql, values)) ?? {}) as any)[0] ?? null\n\t}\n\n\t/**\n\t * `FetchMany` function executes SQL query and fetches an array of rows from the database.\n\t *\n\t * @template T - The type of the rows to retrieve.\n\t * @param {TConnection} connection - Holds database connection details.\n\t * @param {string} sql - The SQL query to execute.\n\t * @param {any} [values] - Optional. Values for SQL query parameters.\n\t * @returns {Promise<Array<T>>} - Promise resolving to an array of rows or empty array if none is found.\n\t *\n\t * @example\n\t * // Fetch all users from 'users' table\n\t * const allUsersSql = \"SELECT * FROM users\";\n\t * FetchMany(dbConnection, allUsersSql)\n\t *    .then(users => console.log(\"All users: \", users))\n\t *    .catch(err => console.log(err));\n\t *\n\t * // Fetch users older than 30 from 'users' table\n\t * const sqlWithParams = \"SELECT * FROM users WHERE age > $1\";\n\t * const paramValues = [30];\n\t * FetchMany(dbConnection, sqlWithParams, paramValues)\n\t *    .then(users => console.log(\"Users older than 30: \", users))\n\t *    .catch(err => console.log(err));\n\t */\n\texport const FetchMany = async <T extends QueryResultRow>(connection: TConnection, sql: string, values?: any): Promise<Array<T>> => {\n\t\t// noinspection SqlResolve\n\t\tconst data = await query<T>(connection, sql, values)\n\t\treturn data.rows ?? []\n\t}\n\n\t/**\n\t * `FetchArray` function fetches data from the database and transforms into an array.\n\t *\n\t * @template T - The type of the values to retrieve.\n\t * @param {TConnection} connection - Holds database connection details.\n\t * @param {string} sql - The SQL query to execute.\n\t * @param {any} [values] - Optional. Values for SQL query parameters.\n\t * @returns {Promise<Array<T>>} - Promise resolving to an array of values.\n\t *\n\t * @example\n\t * // Fetch array of user names from 'users' table\n\t * const usernameSql = \"SELECT username FROM users\";\n\t * FetchArray(dbConnection, usernameSql)\n\t *    .then(names => console.log(\"Usernames: \", names))\n\t *    .catch(err => console.log(err));\n\t *\n\t * // Fetch array of names of users above age 30\n\t * const sqlWithParams = \"SELECT name FROM users WHERE age > $1\";\n\t * const paramValues = [30];\n\t * FetchArray(dbConnection, sqlWithParams, paramValues)\n\t *    .then(names => console.log(\"Names of users older than 30: \", names))\n\t *    .catch(err => console.log(err));\n\t */\n\texport const FetchArray = async <T>(connection: TConnection, sql: string, values?: any): Promise<Array<T>> => {\n\t\tconst data = await query(connection, sql, values)\n\t\treturn (data.rows ?? []).map((row: any) => (row as any)[Object.keys(row as any)[0]] as T)\n\t}\n\n\t/**\n\t * The `FetchExists` function checks if certain entities exist in the database by running a \"SELECT 1 FROM...\" SQL query.\n\t *\n\t * @param {TConnection} connection - Holds database connection details.\n\t * @param {string} sql - The SQL query to execute. Should follow the \"SELECT 1 FROM ...\" pattern.\n\t * @param {any} [values] - Optional. Values for SQL query parameters.\n\t * @returns {Promise<boolean>} - Promise resolving to boolean indicating if entities satisfying the SQL query exist.\n\t *\n\t * @example\n\t * // Check if 'users' table exists\n\t * const sqlTableExists = \"SELECT 1 FROM information_schema.tables WHERE table_name = $1\";\n\t * FetchExists(dbConnection, sqlTableExists, [\"users\"])\n\t *    .then(exists => console.log(\"'users' table exists: \", exists))\n\t *    .catch(err => console.log(err));\n\t *\n\t * //Check if a specific user exists\n\t * const sqlUserExists = \"SELECT 1 FROM users WHERE username = $1\";\n\t * FetchExists(dbConnection, sqlUserExists, [\"johndoe\"])\n\t *    .then(exists => console.log(\"User 'johndoe' exists: \", exists))\n\t *    .catch(err => console.log(err));\n\t */\n\texport const FetchExists = async (connection: TConnection, sql: string, values?: any): Promise<boolean> => {\n\t\t// noinspection SqlResolve\n\t\tconst data = await query<{\n\t\t\tdoes_exist: boolean\n\t\t}>(connection, `SELECT EXISTS (${sql}) as does_exist`, values)\n\t\treturn !!(data.rows ?? [])[0]?.does_exist\n\t}\n\n\t/**\n\t * The `InsertAndGetReturning` function inserts a new row into a database table and returns the inserted row.\n\t *\n\t * @param {TConnection} connection - Holds database connection details.\n\t * @param {string} table - The name of the table to perform the insertion.\n\t * @param {any} values - The row data to insert into the table.\n\t * @returns {Promise<any | null>} - Promise resolving to inserted row data or null if an error occurs.\n\t *\n\t * @example\n\t * // Insert a new user into 'users' table\n\t * const user = { username: 'johndoe', age: 30 };\n\t * InsertAndGetReturning(dbConnection, \"users\", user)\n\t *    .then(newUser => console.log(\"New user inserted: \", newUser))\n\t *    .catch(err => console.log(err));\n\t */\n\texport const InsertAndGetReturning = async (\n\t\tconnection: TConnection,\n\t\ttable: string,\n\t\tvalues: any\n\t): Promise<any | null> => {\n\t\tlet newValues = {...values}\n\t\tif (!newValues.id) {\n\t\t\tdelete newValues.id\n\t\t\t// delete newValues.added_date;\n\t\t\t// delete newValues.modified_date;\n\t\t}\n\n\t\tlet params = new PGParams()\n\n\t\tconst sql = `\n\t\t\tINSERT INTO ${table}\n\t\t\t\t(\"${Object.keys(newValues).join('\",\"')}\")\n\t\t\tVALUES (${Object.values(newValues)\n\t\t\t                .map(value => params.add(value))\n\t\t\t                .join(',')})\n\t\t\tRETURNING *`\n\n\t\tconst results = await query(connection, sql, params.values)\n\n\t\t// if (!((results.rows as any[]) ?? [])[0]) console.error('Error inserting', sql, results)\n\n\t\treturn ((results.rows as any[]) ?? [])[0]\n\t}\n\n\t/**\n\t * The `InsertAndGetID` function inserts a new row into a database table and returns the generated ID.\n\t *\n\t * @param {TConnection} connection - Holds database connection details.\n\t * @param {string} table - The name of the table to perform the insertion.\n\t * @param {object} values - The row data to insert.\n\t * @returns {Promise<number>} - Promise resolving to generated ID of the inserted row.\n\t * @throws {Error} - Throws an error if the ID could not be loaded.\n\t *\n\t * @example\n\t * // Insert a new user into 'users' table and get the ID\n\t * const user = {username: 'johndoe', age: 30};\n\t * InsertAndGetID(dbConnection, \"users\", user)\n\t *    .then(id => console.log(\"New user ID: \", id))\n\t *    .catch(err => console.log(err));\n\t */\n\texport const InsertAndGetID = async (\n\t\tconnection: TConnection,\n\t\ttable: string,\n\t\tvalues: any\n\t): Promise<number> => {\n\t\tlet newValues = {...values}\n\t\tif (!newValues.id) {\n\t\t\tdelete newValues.id\n\t\t\t// delete newValues.added_date;\n\t\t\t// delete newValues.modified_date;\n\t\t}\n\n\t\tlet params = new PGParams()\n\n\t\tconst sql = `\n\t\t\tINSERT INTO ${table}\n\t\t\t\t(\"${Object.keys(newValues).join('\",\"')}\")\n\t\t\tVALUES (${Object.values(newValues)\n\t\t\t                .map(value => params.add(value))\n\t\t\t                .join(',')})\n\t\t\tRETURNING id`\n\n\t\tconst results = await query(connection, sql, params.values)\n\n\t\tconst id = (results.rows as any)[0]?.id\n\n\t\tif (!id) throw new Error('Could not load ID')\n\n\t\treturn id\n\t}\n\n\t/**\n\t * The `InsertBulk` function inserts multiple rows of data into a database table.\n\t *\n\t * @param {TConnection} connection - Holds database connection details.\n\t * @param {string} table - The name of the table to perform the insert operation.\n\t * @param {any} values - An array of row data objects to be inserted into the table.\n\t * @returns {Promise<void>} - Promise resolving when the data has been inserted.\n\t * @throws {Error} - Throws an error if an insertion error occurs.\n\t *\n\t * @example\n\t * // Insert multiple users into 'users' table\n\t * const users = [{username: 'johndoe', age: 30}, {username: 'janedoe', age: 25}];\n\t * InsertBulk(dbConnection, \"users\", users)\n\t *    .then(() => console.log(\"Users inserted successfully\"))\n\t *    .catch(err => console.log(err));\n\t */\n\texport const InsertBulk = async (connection: TConnection, table: string, values: any): Promise<void> => {\n\t\tlet params = new PGParams()\n\n\t\tconst sql = `\n\t\t\tINSERT INTO ${table}\n\t\t\t\t(\"${Object.keys(values).join('\",\"')}\")\n\t\t\tVALUES (${Object.values(values)\n\t\t\t                .map(value => params.add(value))\n\t\t\t                .join(',')})`\n\n\t\tawait query(connection, sql, params.values)\n\t}\n\n\t/**\n\t * The `UpdateAndGetReturning` function updates a row in a database table with provided values and returns the updated row.\n\t *\n\t * @param {TConnection} connection - Holds database connection details.\n\t * @param {string} table - The name of the table to perform the update operation.\n\t * @param {object} whereValues - The conditions for selecting the row to update.\n\t * @param {object} updateValues - The new values to update the selected row with.\n\t * @returns {Promise<any | null>} - Promise resolving to the updated row data or null if no row was updated.\n\t *\n\t * @example\n\t * // Update a user in 'users' table\n\t * const whereValues = {username: 'johndoe'};\n\t * const updateValues = {age: 31};\n\t * UpdateAndGetReturning(dbConnection, \"users\", whereValues, updateValues)\n\t *    .then(updatedUser => console.log(\"Updated user: \", updatedUser))\n\t *    .catch(err => console.log(err));\n\t */\n\texport const UpdateAndGetReturning = async (\n\t\tconnection: TConnection,\n\t\ttable: string,\n\t\twhereValues: any,\n\t\tupdateValues: any\n\t): Promise<any | null> => {\n\t\tlet params = new PGParams()\n\n\t\t// noinspection SqlResolve\n\t\tconst sql = `UPDATE ${table}\n\t\t             SET ${BuildSetComponents(updateValues, params)}\n\t\t             WHERE ${BuildWhereComponents(\n\t\t\t             whereValues,\n\t\t\t             params\n\t\t             )}\n\t\t             RETURNING *`\n\t\tconst data = await query(connection, sql, params.values)\n\t\t// @ts-ignore\n\t\t// if (!data.rows[0]) console.error('Error updating', sql, data)\n\t\t// @ts-ignore\n\t\treturn data.rows[0]\n\t}\n\n\t/**\n\t * Constructs a WHERE clause for a PostgreSQL query based on the given 'whereValues' object. Also adds the required parameters to the 'params' object for parameterized queries.\n\t *\n\t * @param {Object} whereValues - An object representing the values used in the WHERE clause. Each property in the object represents a column and its corresponding value. For example, { column1: 'value1', column2: 'value2' } would translate to \"WHERE column1='value1' AND column2='value2'\" in SQL.\n\t * @param {PGParams} params - The PostgreSQL parameters object for parameterized queries. This helps to prevent SQL injection by securely inserting the 'whereValues' into the SQL query string.\n\t * @returns {string} The complete WHERE clause as a string, ready to be appended to a SQL query.\n\t * @remarks\n\t * Each key-value pair in the 'whereValues' object will create a condition string in the format of 'key=value'. If a value is explicitly set to 'undefined' or 'null', the condition string will instead be 'key IS NULL'.\n\t *\n\t * All condition strings generated are then joined with an ' AND ' delimiter to form the complete WHERE clause.\n\t * @example\n\t * // Create a WHERE clause\n\t * const whereValues = {name: 'John', age: null};\n\t * const params = new PGParams();\n\t * const whereClause = BuildWhereComponents(whereValues, params);\n\t * console.log(whereClause);\n\t * // Output: \"name\"=$1 AND \"age\" IS NULL\n\t */\n\texport const BuildWhereComponents = (whereValues: any, params: PGParams): string =>\n\t\tObject.keys(whereValues)\n\t\t      .map(key => (whereValues[key] === undefined || whereValues[key] === null) ? `\"${key}\" IS NULL` : `\"${key}\"=${params.add(whereValues[key])}`)\n\t\t      .join(' AND ')\n\n\t/**\n\t * Constructs a SET clause for a SQL  query based on the given 'setValues' object.\n\t * Also populates the 'params' object with values for parameterized queries.\n\t *\n\t * @param {Object} setValues - An object representing the new values to use in the SET clause. Each key-value pair represents a column and its respective new value. For example, { column1: 'new value1', column2: 'new value2' } translates to 'SET \"column1\" = $1, \"column2\" = $2' in a SQL query.\n\t * @param {PGParams} params - An instance of the PGParams class that represents the parameters to be used in a PostgreSQL query. The values from 'setValues' are added to this object for use in parameterized queries as a security measure to prevent SQL injections.\n\t * @returns {string} A string representing the SET clause in an SQL update query, excluding the 'SET' keyword itself. For instance, if 'setValues' is { column1: 'new value1', column2: 'new value2' }, the returning string would be: '\"column1\" = $1, \"column2\" = $2'.\n\t * @remarks\n\t * \tThis function iterates over each key-value pair in the 'setValues' object,\n\t * \tcreating an array of strings in the format '\"key\" = $n',\n\t * \twhere 'key' is the column name and 'n' is the index at which the value is stored in 'params'.\n\t *\n\t * \tIt then joins these strings with commas to form a SET clause that can be used in a SQL update query.\n\t * \t@example\n\t * // Create a SET clause\n\t * const setValues = {name: 'John', age: 30};\n\t * const params = new PGParams();\n\t * const setClause = BuildSetComponents(setValues, params);\n\t * console.log(setClause);\n\t * // Output: \"name\"=$1,\"age\"=$2\n\t */\n\texport const BuildSetComponents = (setValues: any, params: PGParams): string =>\n\t\tObject.keys(setValues)\n\t\t      .map(key => `\"${key}\"=${params.add(setValues[key])}`)\n\t\t      .join(',')\n\n\t/**\n\t * Saves data to a specific database table. It performs either an INSERT or an UPDATE operation based on the presence of an 'id' property in the 'values' object.\n\t *\n\t * @param {TConnection} connection - The connection object to the database. All SQL queries will be executed over this connection.\n\t * @param {string} table - The name of the table to save the data into.\n\t * @param {object} values - A key-value object of the data to be saved. Each key represents a column in the table and the value is the data to be saved in that column. The 'id' property, if present, is used to identify the record to update.\n\t *\n\t *\n\t * @returns {Promise<any | null>} - A Promise that is resolved with the object that was saved. Returns null if no record was saved. Be aware that this function can return any type, so consider the structure of your table and handle the return value accordingly.\n\t *\n\t * @remarks\n\t * If 'values' has an 'id' property, the function performs an UPDATE operation on the record with this 'id'.\n\t * If 'values' does not have an 'id' property, the method does an INSERT operation.\n\t *\n\t * @example\n\t * // Save (insert or update) a user in 'users' table\n\t * const user = {id: 1, username: 'johndoe', age: 30};\n\t * Save(dbConnection, \"users\", user)\n\t *    .then(savedUser => console.log(\"Saved user: \", savedUser))\n\t *    .catch(err => console.log(err));\n\t */\n\texport const Save = async (connection: TConnection, table: string, values: any): Promise<any | null> => {\n\t\tif (!values.id) {\n\t\t\treturn InsertAndGetReturning(connection, table, values)\n\t\t} else {\n\t\t\tlet whereValues = {id: values.id}\n\n\t\t\treturn UpdateAndGetReturning(connection, table, whereValues, values)\n\t\t}\n\t}\n\n\t/**\n\t * Executes a DELETE SQL operation on a specified table in the connected database.\n\t *\n\t * @param {TConnection} connection - The connection instance pointing to the active database. This connection is where the SQL DELETE operation will be executed.\n\t * @param {string} table - The name of the table in the database from which to delete data. By SQL syntax, this should be the exact name of the table, case sensitive.\n\t *\n\t * @param {object} whereValues - An object consisting of key-value pairs that define the conditional deletion. Each key-value pair represents a column-name-value pair in the WHERE clause of the SQL DELETE statement. For example, {first_name: 'John', last_name: 'Doe'} would translate to \"WHERE first_name = 'John' AND last_name = 'Doe'\" in SQL language.\n\t *\n\t * @returns {Promise<void>} A Promise representing the completion of the DELETE operation. No value gets returned upon completion (as per the void result type), but if a technical problem occurs during the deletion, the Promise will be rejected with the error that caused the failure.\n\t * @example\n\t *\n\t * const tableName = 'customers';\n\t * const conditions = { email: 'johndoe@gmail.com' };\n\t * await Delete(dbConnection, tableName, conditions);\n\t *\n\t * This would delete the customer entry whose email is 'johndoe@gmail.com' from the 'customers' table.\n\t */\n\texport const Delete = async (connection: TConnection, table: string, whereValues: any): Promise<void> => {\n\t\tlet params = new PGParams()\n\n\t\t// noinspection SqlResolve\n\t\tconst sql = `DELETE\n\t\t             FROM ${table}\n\t\t             WHERE ${BuildWhereComponents(whereValues, params)}`\n\t\tawait query(connection, sql, params.values)\n\t}\n\n\t/**\n\t * ExecuteRaw function is used to execute a raw SQL query on a given database connection.\n\t *\n\t * @param {TConnection} connection - The connection object representing the database connection.\n\t * @param {string} sql - The raw SQL query to be executed.\n\t * @returns {Promise<any>} - Returns a Promise that resolves with the result of the `Execute(connection, sql)` function.\n\t * @throws {Error} - If the query execution encounters any error.\n\t * @remarks\n\t * This function `ExecuteRaw(connection, sql)` sends an SQL query string to the `Execute` function, which is then executed against the database.\n\t * The `ExecuteRaw` function returns the full response object from the SQL query execution.\n\t * Always ensure that the SQL query string is properly formatted and safe to prevent possible SQL injection attacks.\n\t *\n\t * @example\n\t *\n\t * const sqlQuery = 'UPDATE Books SET title = \"Updated Title\" WHERE id = 1';\n\t *\n\t * ExecuteRaw(dbConnection, sqlQuery)\n\t *    .then(() => console.log('Update operation completed successfully!'))\n\t *    .catch((error) => console.error('An Error occurred while executing the query:', error));\n\t *\n\t */\n\texport const ExecuteRaw = async (connection: TConnection, sql: string) => Execute(connection, sql)\n\n\t/**\n\t * Executes a SQL query using the provided database connection.\n\t *\n\t * @remarks\n\t * This function `Execute(connection, sql, values)` executes an SQL query `sql`\n\t * on a provided database connection object `connection`. An array of `values`\n\t * is an optional parameter that can be used for parameter binding in the SQL query.\n\t *\n\t * The function asynchronously returns the result of the SQL query execution\n\t * wrapped in a Promise. The structure of the returned object depends on the\n\t * executed SQL command.\n\t *\n\t * A runtime environment variable `DB_MS_ALERT` is used to set a threshold (in milliseconds)\n\t * for query execution time. If the query execution time exceeds this threshold,\n\t * the query details are logged in the console.\n\t *\n\t * @example\n\t *\n\t * const sql = 'UPDATE users SET name = $1 WHERE id = $2';\n\t * const values = ['John', 1];\n\t *\n\t * Execute(dbConnection, sql, values)\n\t *   .then(res => console.log('Update successful', res))\n\t *   .catch(e => console.error('Error:', e.message));\n\t *\n\t *\n\t * @param {TConnection} connection - The connection to the database on which\n\t * the SQL query will be executed.\n\t * @param {string} sql - The SQL query to execute. Can contain placeholders\n\t * for parameter binding if `values` is provided.\n\t * @param {any} [values] - Optional array of values to bind to the placeholders\n\t * in the SQL query.\n\t * @returns {Promise<any>} A Promise that resolves with the response from\n\t * the database based on the executed SQL query.\n\t *\n\t * @throws {Error} If an error occurs during the execution of the SQL query,\n\t * an error is thrown with the message from the caught error.\n\t */\n\texport const Execute = async (connection: TConnection, sql: string, values?: any) => {\n\t\tconst connectionResolved = await Promise.resolve(connection)\n\t\ttry {\n\t\t\tif (!process.env.DB_MS_ALERT) {\n\t\t\t\treturn await connectionResolved.query(sql, values)\n\t\t\t} else {\n\t\t\t\tconst start = Date.now()\n\t\t\t\tconst response = await connectionResolved.query(sql, values)\n\t\t\t\tconst ms = Date.now() - start\n\t\t\t\tif (ms > CleanNumber(process.env.DB_MS_ALERT)) {\n\t\t\t\t\tconsole.log('----- Long SQL Query', ms / 1000, 's', ESTTodayDateTimeLabel())\n\t\t\t\t\tconsole.log(sql)\n\t\t\t\t\tconsole.log(values)\n\t\t\t\t}\n\t\t\t\treturn response\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconsole.log('------------ SQL Execute', ESTTodayDateTimeLabel())\n\t\t\tconsole.log(err.message)\n\t\t\tconsole.log(\"Error Code:\", err.code || 'No code')\n\t\t\tconsole.log(\"Error Detail:\", err.detail || 'No detail')\n\t\t\tconsole.log(\"Error Position:\", err.position || 'No position')\n\t\t\tconsole.log(\"Error Stack:\", err.stack || 'No stack trace')\n\t\t\tconsole.log(sql)\n\t\t\tconsole.log(values)\n\t\t\tthrow new Error(err.message)\n\t\t}\n\t}\n\n\t/**\n\t * Executes an SQL query against a given database connection. Unlike the `Execute` function, this does not log anything to the console.\n\t *\n\t * @remarks\n\t * The `ExecuteNoConsole` function takes in an SQL statement along with an\n\t * optional array of values for placeholder substitution (parameter binding) within\n\t * the SQL query, and executes the SQL command against the provided database\n\t * connection.\n\t *\n\t *\n\t * @example\n\t *\n\t * const userId = 1;\n\t * const nameUpdated = \"John Doe\";\n\t *\n\t * const query = 'UPDATE users SET name = $1 WHERE id = $2';\n\t * const values = [nameUpdated, userId];\n\t *\n\t * await ExecuteNoConsole(dbConnection, query, values);\n\t * console.log(`User with id ${userId} was successfully updated.`);\n\t *\n\t * @param {TConnection} connection - The database connection to execute the query.\n\t * @param {string} sql - The SQL query string to execute.\n\t * @param {any} [values] - Optional: Array of values to be used in the query.\n\t * @returns {Promise<any>} A Promise that resolves with the executed query result.\n\t */\n\texport const ExecuteNoConsole = async (connection: TConnection, sql: string, values?: any) => {\n\t\tconst connectionResolved = await Promise.resolve(connection)\n\t\treturn await connectionResolved.query(sql, values)\n\t}\n\n\n\t/**\n\t * Executes a function within a database transaction.\n\t *\n\t * @template T The expected return type of the transaction function.\n\t *\n\t * @param {TConnection} connection - The connection object to be used for the transaction\n\t * @param {(Client | Poolclient) => Promise<T>} func The function to execute within the transaction, which should return a Promise.\n\t *\n\t * @returns {Promise<T>} Returns a Promise that resolves with the result of the transaction function or\n\t * rejects with an error if an error occurred during the transaction.\n\t *\n\t * @remarks\n\t * The function initiates a transaction by utilizing two internal database commands: 'START TRANSACTION' and\n\t * 'SET CONSTRAINTS ALL DEFERRED'. If the transaction succeeds, it is finalized with 'COMMIT'.\n\t * In the event of an error, the transaction is rolled back using 'ROLLBACK', and an Error is thrown.\n\t * After the transaction is complete, if the Pool is in use, it is released automatically.\n\t * If Client or PoolClient then it must be release manually outside the function.\n\t *\n\t * @example\n\t *\n\t *   const result = await Transaction<number>(dbConnection, (transactionClient) => {\n\t *     //...some database operations that return a Promise\n\t *   });\n\t *\n\t * @throws If an invalid connection object is provided or if an error occurs during the transaction\n\t */\n\texport const Transaction = async <T>(connection: TConnection, func: (transactionClient: Client | PoolClient) => Promise<T>) => {\n\t\tconst connectionResolved = await connection\n\n\t\tlet is_Custom_Client = true\n\t\tlet transactionClient: Client | PoolClient\n\t\tif (connectionResolved instanceof pkgPool) {\n\t\t\tis_Custom_Client = false\n\t\t\ttransactionClient = await connectionResolved.connect()\n\t\t} else if (connectionResolved instanceof pkgClient) {\n\t\t\ttransactionClient = connectionResolved\n\t\t} else if ('Client' in connectionResolved) {\n\t\t\ttransactionClient = connectionResolved.Client\n\t\t} else {\n\t\t\tthrow new Error('Invalid connection')\n\t\t}\n\n\t\tif (connectionResolved.inTransaction) return await func(transactionClient)\n\n\t\tconnectionResolved.inTransaction = true\n\n\t\tawait Execute(transactionClient, 'START TRANSACTION')\n\t\tawait Execute(transactionClient, 'SET CONSTRAINTS ALL DEFERRED')\n\n\t\ttry {\n\t\t\tconst response = await func(transactionClient)\n\t\t\tawait Execute(transactionClient, 'COMMIT')\n\t\t\treturn response\n\t\t} catch (err) {\n\t\t\tawait Execute(transactionClient, 'ROLLBACK')\n\t\t\tthrow new Error(err)\n\t\t} finally {\n\t\t\tconnectionResolved.inTransaction = false\n\t\t\tif ('release' in transactionClient && typeof transactionClient.release === 'function' && !is_Custom_Client) {\n\t\t\t\ttransactionClient.release()\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Truncates all tables in a database, optionally excluding specified tables, and optionally cascading the truncation.\n\t *\n\t * @template TConnection Type of database connection.\n\t *\n\t * @param {TConnection} connection The database connection to use for truncation.\n\t * @param {string[]} [exceptions=[]] An array of table names to exclude from truncation.\n\t * @param {boolean} [includeCascade=false] If true, cascading truncation will be used.\n\t *\n\t * @returns {Promise<boolean>} Returns a Promise that resolves with true if truncation succeeds or\n\t * false if an error occurs during truncation.\n\t *\n\t *\n\t * @remarks\n\t * This function starts a transaction and sets all constraints to deferred. Then it goes through\n\t * each table in the database, and if the table is not in the exceptions list, it truncates the table.\n\t * If the `includeCascade` option is true, it also cascades the truncation. If any part of the operation fails,\n\t * it rolls back the transaction and returns false. If all operations succeed, it commits the transaction and returns true.\n\t *\n\t * @example\n\t *\n\t *   // Truncate all tables, except the `users` and `accounts` tables, with cascading.\n\t *   await TruncateAllTables(dbConnection, ['users', 'accounts'], true);\n\t *\n\t *\n\t * @throws This function does not throw errors. Instead, it catches errors and rolls back the transaction,\n\t * returning false to indicate the error.\n\t */\n\texport const TruncateAllTables = async (connection: TConnection, exceptions: string[] = [], includeCascade = false) => {\n\t\tlet tables = await TablesArray(connection)\n\n\t\tawait Execute(connection, 'START TRANSACTION')\n\t\tawait Execute(connection, 'SET CONSTRAINTS ALL DEFERRED')\n\n\t\ttry {\n\t\t\tfor (const table of tables) {\n\t\t\t\tif (!exceptions.includes(table)) {\n\t\t\t\t\tawait Execute(connection, `TRUNCATE TABLE ${table} RESTART IDENTITY` + (includeCascade ? ' CASCADE' : ''), undefined)\n\t\t\t\t}\n\t\t\t}\n\t\t\tawait Execute(connection, 'COMMIT')\n\t\t} catch (err) {\n\t\t\tawait Execute(connection, 'ROLLBACK')\n\t\t\treturn false\n\t\t}\n\n\t\treturn true\n\t}\n\n\t/**\n\t * The `TruncateTables` method is used to wipe all the records from the specified tables in the connected database, while leaving the table schema (columns, data types, constraints, etc.) intact.\n\t *\n\t * @param {TConnection} connection - An object representing the active database connection. This connection is used to perform the truncation operations on the specified tables.\n\t *\n\t * @param {string[]} tables - An array of string values representing the names of the tables to be truncated. The method will iterate over this array and execute the TRUNCATE SQL statement on each table.\n\t *\n\t * @param {boolean} [includeCascade=false] - An optional boolean value indicating whether the CASCADE option should be included in the truncation operation. By including CASCADE option, the rows from the referenced tables will also be removed if a foreign key relationship exists. If not provided, the parameter defaults to false.\n\t *\n\t * @returns {Promise<void>} - A Promise object that resolves when the truncation operation on all specified tables is successfully completed. No value is provided when the Promise resolves, but the resolution of the Promise indicates the successful execution of the operation.\n\t *\n\t * @throws {Error} - Throws an Error object if any exceptions occur during the truncation process. This might be due to issues like invalid connection, permission errors, non-existent table names, etc.\n\t *\n\t * @example\n\t *  const tablesToTruncate = ['table1', 'table2'];\n\t *  const cascade = true;\n\t *\n\t *  try {\n\t *    await TruncateTables(dbConnection, tablesToTruncate, cascade);\n\t *    console.log(`All tables [${tablesToTruncate.join(', ')}] have been successfully truncated.`);\n\t *  } catch (error) {\n\t *    console.error(`An error occurred while attempting to truncate tables: ${error}`);\n\t *  }\n\t *\n\t * @remarks\n\t * Be cautious about the use of CASCADE, because it removes the rows from referenced tables. Make sure to keep backups, if needed, before executing this operation.\n\t * Also remember that TRUNCATE operations cannot be performed if the table is referenced by a FOREIGN KEY, unless CASCADE is provided.\n\t */\n\texport const TruncateTables = async (connection: TConnection, tables: string[], includeCascade = false) => {\n\t\tfor (const table of tables) {\n\t\t\tawait Execute(connection, `TRUNCATE TABLE ${table} RESTART IDENTITY` + (includeCascade ? ' CASCADE' : ''))\n\t\t}\n\t}\n\n\t/**\n\t * The `TablesArray` method is an async function that fetches an array containing the names of all tables from a particular database schema using the provided database connection.\n\t *\n\t * @param {TConnection} connection - An instance of the database connection. It acts as an interface with the database, making it possible to fetch the table names directly.\n\t *\n\t * @param {string} [schema] - An optional parameter indicating the name of the schema from which table names are to be retrieved. If not provided, the function defaults to the current schema in use.\n\t *\n\t * @returns {Promise<string[]>} - A Promise that resolves with an array of strings, where each string is the name of a base table present in the specified schema.\n\t *\n\t * @example\n\t *  // Fetch table names from the 'public' schema\n\t *  const tables = await TablesArray(dbConnection, 'public');\n\t *  console.log(tables);  // Outputs: [ 'table1', 'table2', 'table3' ]\n\t *\n\t *  // Fetch table names from the currently set schema\n\t *  const tables = await TablesArray(dbConnection);\n\t *  console.log(tables);  // Outputs: [ 'table4', 'table5', 'table6' ]\n\t *\n\t * @remarks\n\t * The function uses the 'information_schema.tables' view to fetch the table names. This view contains one row for each table in the database. Note that only 'BASE TABLE' types are considered, excluding views.\n\t *\n\t */\n\texport const TablesArray = async (connection: TConnection, schema?: string): Promise<string[]> => {\n\t\treturn FetchArray<string>(\n\t\t\tconnection,\n\t\t\t`\n\t\t\t\tSELECT table_name\n\t\t\t\tFROM information_schema.tables\n\t\t\t\tWHERE table_schema = '${CurrentSchema(schema)}'\n\t\t\t\t  AND table_type = 'BASE TABLE'`\n\t\t)\n\t}\n\n\t/**\n\t * The `ViewsArray` method fetches an array of names of all the views found in a particular schema in the database. It uses the provided database connection to perform this task.\n\t *\n\t * @async\n\t * @param {TConnection} connection - An instance of the database connection. It establishes an interface with the database, enabling the procedure to fetch the view names.\n\t *\n\t * @param {string} [schema] - An optional parameter designating the schema from which to retrieve view names. If it is not provided, the function uses the currently active database schema.\n\t *\n\t * @returns {Promise<string[]>} - A Promise that resolves to an array of strings. Each string is the name of a view in the specified schema. The function will only consider 'VIEW' types, keeping table names out of the result.\n\t *\n\t * @example\n\t *  const connection = new Connection();\n\t *  // Fetch view names from the 'public' schema\n\t *  const views = await ViewsArray(dbConnection, 'public');\n\t *  console.log(views);  // Outputs: [ 'view1', 'view2', 'view3' ]\n\t *\n\t *  // Fetch view names from the currently set schema\n\t *  const views = await ViewsArray(dbConnection);\n\t *  console.log(views);  // Outputs: [ 'view4', 'view5', 'view6' ]\n\t *\n\t * @remarks\n\t * The function uses the 'information_schema.tables' table to extract the names of the views. This table contains one row for each table and view that exist in the database. Although the name suggests 'tables', this information schema view contains information about both tables and views in the database.\n\t * Also, note that system and temporary views may not appear, depending on the user's privilege level on the database.\n\t *\n\t */\n\texport const ViewsArray = async (connection: TConnection, schema?: string): Promise<string[]> => {\n\t\treturn await FetchArray<string>(\n\t\t\tconnection,\n\t\t\t`\n\t\t\t\tSELECT table_name\n\t\t\t\tFROM information_schema.tables\n\t\t\t\tWHERE table_schema = '${CurrentSchema(schema)}'\n\t\t\t\t  AND table_type = 'VIEW'`\n\t\t)\n\t}\n\n\t/**\n\t * The `ViewsMatArray` method is an async function that fetches an array of the names of all materialized views from a specific schema within a PostgreSQL database, using the provided database connection.\n\t *\n\t * @param {TConnection} connection - An instance of the database connection. It establishes an interface with the database, enabling the procedure to fetch the materialized view names.\n\t *\n\t * @param {string} [schema] - An optional parameter that represents the schema from which to retrieve the materialized view names. If it is not provided, the current schema set in your PostgreSQL connection will be used.\n\t *\n\t * @returns {Promise<string[]>} - A Promise that resolves to an array of strings, where each string is the name of a materialized view in the specified schema.\n\t *\n\t * @example\n\t *  const connection = new Connection();\n\t *  // Fetch materialized view names from the 'public' schema\n\t *  const matViews = await ViewsMatArray(dbConnection, 'public');\n\t *  console.log(matViews);  // Outputs: [ 'matView1', 'matView2', 'matView3' ]\n\t *\n\t *  // Fetch materialized view names from the currently set schema\n\t *  const matViews = await ViewsMatArray(dbConnection);\n\t *  console.log(matViews);  // Outputs: [ 'matView4', 'matView5', 'matView6' ]\n\t *\n\t * @remarks\n\t * This function queries the 'pg_matviews' system catalog table, which contains one row for each materialized view in the PostgreSQL database. It extracts only the names (`matviewname`) of the materialized views (`WHERE schemaname = '<schema>'`). Please note that the visibility of these materialized views in the catalog table depends on the user's access permission levels in the PostgreSQL database.\n\t */\n\texport const ViewsMatArray = async (connection: TConnection, schema?: string): Promise<string[]> => {\n\t\treturn await FetchArray<string>(\n\t\t\tconnection,\n\t\t\t`\n\t\t\t\tSELECT matviewname\n\t\t\t\tFROM pg_matviews\n\t\t\t\tWHERE schemaname = '${CurrentSchema(schema)}'`\n\t\t)\n\t}\n\n\t/**\n\t * The `TypesArray` method is an async function that fetches an array of names of all enumeration (enum) types from PostgreSQL database.\n\t * Enum is a user-defined data type in PostgreSQL, which consists of static, ordered set of values.\n\t *\n\t * @async\n\t * @param {TConnection} connection - An instance of the database connection. It establishes an interface with the database, enabling the procedure to fetch the enum type names.\n\t *\n\t * @returns {Promise<string[]>} - A Promise that resolves to an array of strings, where each string is the name of an enum type.\n\t *\n\t * @example\n\t *  // Fetch enum type names from the database\n\t *  const types = await TypesArray(dbConnection);\n\t *  console.log(types);  // Outputs: [ 'enum_type1', 'enum_type2', 'enum_type3' ]\n\n\t * @remarks\n\t * The function queries the 'pg_type' system catalog table, which contains one row for each data type in the PostgreSQL database. It extracts the names (`typname`) of those whose category (`typcategory`) is 'E', which stands for enums.\n\t * Please note, the visibility of these enumeration types depend on the user's access privilege level on the PostgreSQL database.\n\t * So for example, only superusers can see some restricted types.\n\t */\n\texport const TypesArray = async (connection: TConnection): Promise<string[]> => {\n\t\treturn await FetchArray<string>(\n\t\t\tconnection,\n\t\t\t`\n\t\t\t\tSELECT typname\n\t\t\t\tFROM pg_type\n\t\t\t\tWHERE typcategory = 'E'\n\t\t\t\tORDER BY typname`\n\t\t)\n\t}\n\n\t/**\n\t * The `FunctionsArray` function fetches an array of PostgreSQL function names from the given database connection matching specific condition. This function specifically finds all functions that start with 'func_'.\n\t *\n\t * @param {TConnection} connection - A database connection object. This allows interaction with the PostgreSQL database.\n\t *\n\t * @param {string} [schema] - (Optional) The name of the schema to look for functions in. If not provided, the function will default to the current schema.\n\t *\n\t * @returns {Promise<string[]>} - A Promise which resolves to an array of strings. Each string is the name of a function found within the specified or default schema starting with 'func_'.\n\t *\n\t * @example\n\t * const schema = 'public';\n\t * // Fetch and log function names from the target schema\n\t * const functions = await FunctionsArray(dbConnection, schema);\n\t * console.log(functions); // Outputs: ['func_example', 'func_hello_world', ...]\n\t *\n\t * @remarks\n\t * The function constructs a SQL string that queries the 'pg_proc' system catalog table, which contains data about functions in the PostgreSQL system.\n\t * Specifically, it joins the 'pg_proc' and 'pg_namespace' tables to relate functions to their respective schemas by the namespace OIDs,\n\t * and then limits the results to those functions whose name begins with 'func_'.\n\t * The function name check is case-insensitive ('ILIKE' is used).\n\t */\n\texport const FunctionsArray = async (connection: TConnection, schema?: string): Promise<string[]> => {\n\t\treturn await FetchArray<string>(\n\t\t\tconnection,\n\t\t\t`\n\t\t\t\tSELECT f.proname\n\t\t\t\tFROM pg_catalog.pg_proc f\n\t\t\t\t\t     INNER JOIN pg_catalog.pg_namespace n ON (f.pronamespace = n.oid)\n\t\t\t\tWHERE n.nspname = '${CurrentSchema(schema)}'\n\t\t\t\t  AND f.proname ILIKE 'func_%'`\n\t\t)\n\t}\n\n\t/**\n\t * The `FunctionsOIDArray` method is an async function that fetches an array of PostgreSQL function Object Identifiers (OIDs) in a given database connection that follow a specific pattern in their names. This function specifically finds OIDs of all functions that start with 'func_'.\n\t *\n\t * @param {TConnection} connection - A database connection object representing the interface to interact with the PostgreSQL database.\n\t *\n\t * @param {string} [schema] - (Optional) The name of the schema within which to look for functions. If not provided, the default schema of the database will be used.\n\t *\n\t * @returns {Promise<any[]>} - A Promise that when resolves, returns an array of OIDs. Each OID corresponds to a function found within the specified or default schema and starts with 'func_'.\n\t *\n\t * @example\n\t * const schema = 'public';\n\t * // Fetch function OIDs and log them\n\t * const functionOids = await FunctionsOIDArray(dbConnection, schema);\n\t * console.log(functionOids); // Outputs: [<oid_value1>, <oid_value2>, ...]\n\t *\n\t * @remarks\n\t * The SQL query constructed in this function targets the `pg_proc` system catalog table, which contains data about functions in the PostgreSQL system. The query also joins 'pg_proc' and 'pg_namespace' tables to link functions to their respective schema via the namespace OIDs (pronamespace), and filters results to functions starting with 'func_' (case-insensitive due to the use of 'ILIKE').\n\t *\n\t * Please note that, OID changes with every new function and isnt a reliable way to reference objects if functions are regularly added or dropped. In recent PostgreSQL versions, OIDs are not included as a default, unless specifically stated during table creation.\n\t */\n\texport const FunctionsOIDArray = async (connection: TConnection, schema?: string): Promise<any[]> => {\n\t\treturn await FetchArray<any>(\n\t\t\tconnection,\n\t\t\t`\n\t\t\t\tSELECT f.oid\n\t\t\t\tFROM pg_catalog.pg_proc f\n\t\t\t\t\t     INNER JOIN pg_catalog.pg_namespace n ON (f.pronamespace = n.oid)\n\t\t\t\tWHERE n.nspname = '${CurrentSchema(schema)}'\n\t\t\t\t  AND f.proname ILIKE 'func_%'`\n\t\t)\n\t}\n\n\t/**\n\t * The `ExtensionsArray` function is a utility function that fetches the names of all loaded PostgreSQL extensions installed on the PostgreSQL database, excluding the 'plpgsql' extension.\n\t *\n\t * @param {TConnection} connection - A connection object that interfaces with the PostgreSQL database. It is used to execute the SQL query against the database.\n\t *\n\t * @returns {Promise<string[]>} - The function returns a Promise that resolves to an array of strings. Each string is the name of a loaded extension on the PostgreSQL database (excluding 'plpgsql').\n\t *\n\t * @example\n\t * // Fetch and log extension names\n\t * const extensions = await ExtensionsArray(dbConnection);\n\t * console.log(extensions); // Outputs: ['hstore', 'postgis', ...]\n\t *\n\t * @remarks\n\t * This function works by querying the `pg_extension` system catalog table in the PostgreSQL database, which contains data about installed extensions. The SQL query specifically selects the 'extname' field (which holds the name of the extension) from this table, and it excludes 'plpgsql' in the WHERE clause.\n\t */\n\texport const ExtensionsArray = async (connection: TConnection): Promise<string[]> => {\n\t\treturn await FetchArray<string>(\n\t\t\tconnection,\n\t\t\t`\n\t\t\t\tSELECT extname\n\t\t\t\tFROM pg_extension\n\t\t\t\tWHERE extname != 'plpgsql'`\n\t\t)\n\t}\n\n\t/**\n\t * The `TableData` function fetches the metadata for a specific table from the PostgreSQL database. This function retrieves detailed information about the given table's schema like table_catalog, table_type, self_referencing_column_name etc.\n\t *\n\t * @param {TConnection} connection - A connection object that interfaces with your PostgreSQL database. This is used to execute the SQL query against the database.\n\t *\n\t * @param {string} table - The name of the table for which data needs to be fetched.\n\t *\n\t * @param {string} [schema] - (Optional) The schema in which the table is defined. If not provided, the default schema set will be used.\n\t *\n\t * @returns {Promise<any>} - The function returns a Promise that gets resolved with the fetched table data. The data includes the table's detailed metadata.\n\t *\n\t * @example\n\t * const tableName = 'example';\n\t * const schemaName = 'public';\n\t * // Fetch metadata of 'example' table from 'public' schema\n\t * const tableData = await TableData(dbConnection, tableName, schemaName);\n\t * console.log(tableData);\n\t *\n\t * @remarks\n\t * The function uses a SQL query to select all data from the 'information_schema.tables' catalog table that matches the provided input criteria including table name, table type (BASE TABLE indicates that the table is a standard, heap-organized table), and schema name.\n\t */\n\texport const TableData = async (connection: TConnection, table: string, schema?: string): Promise<any> => {\n\t\treturn FetchOne<any>(\n\t\t\tconnection,\n\t\t\t`\n\t\t\t\tSELECT *\n\t\t\t\tFROM information_schema.tables\n\t\t\t\tWHERE table_schema = '${CurrentSchema(schema)}'\n\t\t\t\t  AND table_type = 'BASE TABLE'\n\t\t\t\t  AND table_name = $1`,\n\t\t\t[table]\n\t\t)\n\t}\n\n\t/**\n\t * The `TableColumnsData` function fetches the metadata for all the columns of a specified table from the PostgreSQL database. This function retrieves details about all columns in the provided table, such as data type, character length, whether null-able, and much more.\n\t *\n\t * @param {TConnection} connection - A connection object encompassing the details required to connect to your PostgreSQL database. It is utilized to execute the SQL query against your database.\n\t *\n\t * @param {string} table - The name of the table on which column information needs to be fetched.\n\t *\n\t * @param {string} [schema] - (Optional) The schema in which the desired table resides. If omitted, the default schema is used.\n\t *\n\t * @returns {Promise<any[]>} - The function returns a Promise that is resolved with an array of objects, each representing a column in the specified table.\n\t *\n\t * @example\n\t * const tableName = 'users';\n\t * const schemaName = 'public';\n\t * // Fetch and log column metadata of 'users' table from 'public' schema\n\t * const columnData = await TableColumnsData(dbConnection, tableName, schemaName);\n\t * console.log(columnData);\n\t *\n\t * @remarks\n\t * This function fires a SQL query that selects all entries from the 'information_schema.columns' catalog for the specified table and schema. It sorts the results by 'ordinal_position' to ensure they are in the order they are defined in the table.\n\t */\n\texport const TableColumnsData = async (connection: TConnection, table: string, schema?: string): Promise<any[]> => {\n\t\treturn FetchMany<any>(\n\t\t\tconnection,\n\t\t\t`\n\t\t\t\tSELECT *\n\t\t\t\tFROM information_schema.columns\n\t\t\t\tWHERE table_schema = '${CurrentSchema(schema)}'\n\t\t\t\t  AND table_name = $1\n\t\t\t\tORDER BY ordinal_position`,\n\t\t\t[table]\n\t\t)\n\t}\n\n\t/**\n\t * The `TableFKsData` function fetches the metadata of all foreign keys in a specific table from the PostgreSQL database. This function retrieves comprehensive information about these relationships for the specified table, including all columns involved in the foreign key constraint, the target (primary) table and columns, and whether the foreign key constraint is enforced.\n\t *\n\t * @param {TConnection} connection - A connection object used to connect to your PostgreSQL database. This is utilized to execute the SQL query against your database.\n\t *\n\t * @param {string} table - The name of the table for which foreign key information needs to be fetched.\n\t *\n\t * @param {string} [schema] - (Optional) The schema in which the desired table resides. If omitted, the function uses the default schema.\n\t *\n\t * @returns {Promise<any[]>} The function returns a Promise that is resolved with an array of objects, each representing a foreign key constraint in the specified table.\n\t *\n\t * @example\n\t * const tableName = 'orders';\n\t * const schemaName = 'public';\n\t * // Fetch and log foreign key information of 'orders' table from 'public' schema\n\t * const fkData = await TableFKsData(dbConnection, tableName, schemaName);\n\t * console.log(fkData);\n\t *\n\t * @remarks\n\t * The function performs a SQL query that retrieves data from multiple system catalog tables and views (`information_schema.table_constraints`, `information_schema.key_column_usage`, `information_schema.constraint_column_usage`) since foreign key metadata resides across these. Constraints are filtered by table name, constraint type (FOREIGN KEY), and optionally schema. The results are then grouped by the target schema, constraint name, and table name.\n\t */\n\texport const TableFKsData = async (connection: TConnection, table: string, schema?: string): Promise<any[]> => {\n\t\treturn FetchMany<any>(\n\t\t\tconnection,\n\t\t\t`\n\t\t\t\tSELECT tc.table_schema,\n\t\t\t\t       tc.constraint_name,\n\t\t\t\t       tc.table_name,\n\t\t\t\t       MAX(tc.enforced),\n\t\t\t\t       JSON_AGG(kcu.column_name) AS \"columnNames\",\n\t\t\t\t       MAX(ccu.table_schema)     AS foreign_table_schema,\n\t\t\t\t       MAX(ccu.table_name)       AS \"primaryTable\",\n\t\t\t\t       JSON_AGG(ccu.column_name) AS \"primaryColumns\"\n\t\t\t\tFROM information_schema.table_constraints AS tc\n\t\t\t\t\t     JOIN information_schema.key_column_usage AS kcu\n\t\t\t\t\t          ON tc.constraint_name = kcu.constraint_name\n\t\t\t\t\t\t          AND tc.table_schema = kcu.table_schema\n\t\t\t\t\t     JOIN information_schema.constraint_column_usage AS ccu\n\t\t\t\t\t          ON ccu.constraint_name = tc.constraint_name\n\t\t\t\t\t\t          AND ccu.table_schema = tc.table_schema\n\t\t\t\tWHERE tc.table_schema = '${CurrentSchema(schema)}'\n\t\t\t\t  AND tc.constraint_type = 'FOREIGN KEY'\n\t\t\t\t  AND tc.table_name = $1\n\t\t\t\tGROUP BY tc.table_schema,\n\t\t\t\t         tc.constraint_name,\n\t\t\t\t         tc.table_name`,\n\t\t\t[table]\n\t\t)\n\t}\n\n\t/**\n\t * The `TableIndexesData` function retrieves the metadata for all indexes associated with a specific table in the PostgreSQL database. This function fetches the index details like index name, index creation command, and the methods used to store and retrieve data, from the `pg_indexes` system catalog view.\n\t *\n\t *\n\t * @param {TConnection} connection - A connection object to establish a connection with the PostgreSQL database. This object is used to execute the SQL query over the database.\n\t *\n\t * @param {string} table - The name of the table from which index data needs to be fetched.\n\t *\n\t * @param {string=} schema - (Optional) The schema where the specified table is located. If not provided, the function uses the default schema.\n\t *\n\t * @returns {Promise<any[]>} - The function returns a Promise that is resolved with an array of objects. Each object represents an index associated with the specified table in your database.\n\t *\n\t * @example\n\t * const tableName = '_users';\n\t * const schemaName = 'public';\n\t * // Fetch and log index data of '_users' table from 'public' schema\n\t * const indexData = await TableIndexesData(dbConnection, tableName, schemaName);\n\t * console.log(indexData);\n\t *\n\t * @remarks\n\t * This function runs a SQL query that selects all entries from the 'pg_indexes' catalog view that correspond to the specified table and optional schema. The query specifically excludes primary key indexes that are not composite (do not include multiple columns). It uses the ILIKE operator to perform a case-insensitive search on the 'indexname' and 'indexdef' columns, to filter out such indexes.\n\t */\n\texport const TableIndexesData = async (connection: TConnection, table: string, schema?: string): Promise<any[]> => {\n\t\treturn FetchMany<any>(\n\t\t\tconnection,\n\t\t\t`\n\t\t\t\tSELECT *\n\t\t\t\tFROM pg_indexes\n\t\t\t\tWHERE schemaname = '${CurrentSchema(schema)}'\n\t\t\t\t  AND tablename = $1\n\t\t\t\t  AND (indexname NOT ILIKE '%_pkey'\n\t\t\t\t\tOR indexdef ILIKE '%(%,%)%')`,\n\t\t\t[table]\n\t\t)\n\t}\n\n\t/**\n\t * The `ViewData` function retrieves the SQL command that was used to create a specific view in the PostgreSQL database. This function fetches the SQL definition (the `SELECT` statement) of a specified view from the database using the `pg_get_viewdef` system function.\n\t *\n\t * @param {TConnection} connection - A connection object for connecting to the PostgreSQL database. It is used to execute the SQL query on the database.\n\t *\n\t * @param {string} view - The name of the view whose definition needs to be fetched.\n\t *\n\t * @returns {Promise<string | null>} - The function returns a Promise that gets resolved with a string representing the SQL definition of the view. If the view is not found, it returns null.\n\t *\n\t * @example\n\t * const viewName = 'user_summary';\n\t * // Fetch and log the definition of view 'user_summary'\n\t * const viewDefinition = await ViewData(dbConnection, viewName);\n\t * console.log(viewDefinition);\n\t *\n\t * @remarks\n\t * This function executes a SQL query using the `pg_get_viewdef` system function, which returns the query string that was used to create the view. If the view does not exist in the database, the function will return null. Be aware that this function doesn't verify whether the provided view name exists or not. Make sure the view name exists before using this function to avoid unexpected null values.\n\t */\n\texport const ViewData = async (connection: TConnection, view: string): Promise<string | null> => {\n\t\treturn (\n\t\t\t(\n\t\t\t\tawait FetchOne<any>(\n\t\t\t\t\tconnection,\n\t\t\t\t\t`\n          select pg_get_viewdef($1, true) as viewd`,\n\t\t\t\t\t[view]\n\t\t\t\t)\n\t\t\t)?.viewd ?? null\n\t\t)\n\t}\n\n\t/**\n\t * The ViewsMatData function retrieves the SQL code used to define a Materialized View in a PostgreSQL database. This function fetches the SQL definition (effectively the `SELECT` statement) of the specified Materialized View.\n\t *\n\t * @param {TConnection} connection - A Connection object representing the active connection to the PostgreSQL database. It's used to execute the SQL statement.\n\t *\n\t * @param {string} viewMat - The name of the Materialized View whose SQL definition is to be fetched.\n\t *\n\t * @returns {Promise<any>} - Returns a Promise that resolves with a string if the definition is found, representing the SQL query that defines the Materialized View. If not found, it resolves with null.\n\t *\n\t * @example\n\t * // Specify materialized view name\n\t * const materializedViewName = 'materialized_view_summary';\n\t * // Fetch and log the definition of materialized view\n\t * const definition = await ViewsMatData(dbConnection, materializedViewName);\n\t * console.log(definition);\n\t *\n\t * @remarks\n\t * This function constructs and executes a SQL query using the 'pg_get_viewdef' system function, which returns the original SQL code used to create the Materialized View. It will return null if the Materialized View with the specified name doesn't exist, making it important to ensure that the Materialized View name is correct. Also note that while regular Views can be updated with some restrictions, Materialized Views are read-only.\n\t */\n\texport const ViewsMatData = async (connection: TConnection, viewMat: string): Promise<any> => {\n\t\treturn (\n\t\t\t(\n\t\t\t\tawait FetchOne<any>(\n\t\t\t\t\tconnection,\n\t\t\t\t\t`\n          select pg_get_viewdef($1, true) as viewd`,\n\t\t\t\t\t[viewMat]\n\t\t\t\t)\n\t\t\t)?.viewd ?? null\n\t\t)\n\t}\n\n\t/**\n\t * The FunctionData function retrieves the definition of a specific PostgreSQL function from the database. It leverages PostgreSQL's system function `pg_get_functiondef` which helps to fetch the SQL definition of a function available in the database.\n\t *\n\t * @param {TConnection} connection - A Connection object representing the active connection to the PostgreSQL database. It's used to execute the SQL statement to fetch the function's definition.\n\t *\n\t * @param {string} func - The name of the function whose SQL definition is to be fetched.  Ensure the name provided matches exactly with the function name in the database.\n\t *\n\t * @returns {Promise<any>} - Returns a Promise that resolves with a string if the definition is found, representing the SQL query that defines the function. If not found, the promise will resolve with null.\n\t *\n\t * @example\n\t * // Specify function name\n\t * const functionName = 'my_function';\n\t * // Fetch and log the definition of the function\n\t * const definition = await FunctionData(dbConnection, functionName);\n\t * console.log(definition);\n\t *\n\t * @remarks\n\t * Make sure the function's name provided is correct, because PostgreSQL is case-sensitive. If the function does not exist, or the wrong name is provided, the promise will resolve with null. It's also noteworthy that this function only fetches the SQL definition, it does not provide details on the function's use or invocation.\n\t */\n\texport const FunctionData = async (connection: TConnection, func: string): Promise<any> => {\n\t\treturn (\n\t\t\t(\n\t\t\t\tawait FetchOne<any>(\n\t\t\t\t\tconnection,\n\t\t\t\t\t`\n          select pg_get_functiondef($1) as viewd`,\n\t\t\t\t\t[func]\n\t\t\t\t)\n\t\t\t)?.viewd ?? null\n\t\t)\n\t}\n\n\t/**\n\t * The TypeData function asynchronously retrieves all elements of a specified PostgreSQL ENUM type\n\t * and returns them as an array of string values.\n\t *\n\t * @async\n\t *\n\t * @param {TConnection} connection - The Connection object representing the active connection to the PostgreSQL\n\t * database. It's used to execute the SQL statement and fetch the ENUM values.\n\t *\n\t * @param {string} type - The name of the ENUM type whose values are to be fetched. Make sure the ENUM type exists\n\t * in the database, and the name matches exactly.\n\t *\n\t * @returns {Promise<string[]>} - Returns a Promise that resolves with an array of strings, each string representing a\n\t * value of the specified ENUM type.\n\t *\n\t * @example\n\t * // Specify ENUM type\n\t * const typeName = 'color';\n\t * // Fetch, log the array of ENUM values\n\t * const enumValues = await TypeData(dbConnection, typeName);\n\t * console.log(enumValues);\n\t *\n\t * @remarks\n\t * Be sure to provide an existing ENUM type name; any spelling mistakes or nonexistent ENUM types will result in\n\t * an error. The ENUM type name is case-sensitive, so make sure to match the case when providing the `type` value.\n\t * This function doesn't check for the ENUM type's existence before making the query, so ensure the ENUM type exists\n\t * to prevent unnecessary errors.\n\t */\n\texport const TypeData = async (connection: TConnection, type: string): Promise<string[]> => {\n\t\treturn FetchArray<string>(\n\t\t\tconnection,\n\t\t\t`\n                SELECT unnest(enum_range(NULL::${type}))`\n\t\t)\n\t}\n\n\t/**\n\t * The `SortColumnSort` function generates an SQL ORDER BY clause according to the provided sorting preferences\n\t * encapsulated in a given sort column object.\n\t *\n\t * The function takes a sort column object which specifies how sorting should take place, including primary\n\t * and secondary sort columns, sort orders and null handling instructions. It then generates and returns\n\t * the corresponding SQL ORDER BY clause which can then be added to SQL queries to perform the desired sorting.\n\t *\n\t * @param {Object} sortColumn - An object representing sort column data. This object should include properties\n\t * like `primarySort`, `primaryAscending`, `primaryEmptyToBottom`, `secondarySort`, `secondaryAscending`,\n\t * and `secondaryEmptyToBottom`.\n\t *\n\t * @returns {string} The generated SQL ORDER BY clause, which can be directly added to an SQL query.\n\t *\n\t * @example\n\t * //Define the sort column preference object\n\t * const sortColumn = {\n\t *   primarySort: \"lastName\",\n\t *   primaryAscending: true,\n\t *   primaryEmptyToBottom: 'string',\n\t *   secondarySort: \"firstName\",\n\t *   secondaryAscending: false,\n\t *   secondaryEmptyToBottom: 'string'\n\t * };\n\t *\n\t * // Generate the SQL sorting clause\n\t * const orderClause = SortColumnSort(sortColumn);\n\t *\n\t * console.log(orderClause);\n\t * // Outputs: \"ORDER BY NULLIF(lastName, '') NULLS LAST, firstName DESC NULLS LAST\"\n\t *\n\t * @remarks\n\t * The `sortColumn` object's properties (`primarySort`, `secondarySort`, etc.) should match the actual\n\t * column names in the database table that you intend to use the generated SQL ORDER BY clause with.\n\t * If not, it could lead to SQL error due to nonexistent columns. The generated SQL clause does not include\n\t * any input sanitization or SQL injection protection. Thus, make sure to use safe values for sorting preferences.\n\t */\n\texport const SortColumnSort = <T = Record<string, any>>(sortColumn: ISortColumn<T>): string => {\n\t\tlet sort = ''\n\n\t\tif (!!sortColumn.primarySort) {\n\t\t\tsort += 'ORDER BY '\n\t\t\tif (!sortColumn.primaryAscending) {\n\t\t\t\tsort += `${AltColumn(sortColumn.primarySort)} DESC`\n\t\t\t} else {\n\t\t\t\tswitch (sortColumn.primaryEmptyToBottom) {\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tsort += `NULLIF(${sortColumn.primarySort as any}, '')`\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase 'number':\n\t\t\t\t\t\tsort += `NULLIF(${sortColumn.primarySort as any}, 0)`\n\t\t\t\t\t\tbreak\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// null, so do not empty to bottom\n\t\t\t\t\t\tsort += `${AltColumn(sortColumn.primarySort)}`\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!!sortColumn.primaryEmptyToBottom) sort += ' NULLS LAST'\n\n\t\t\tif (!!sortColumn.secondarySort) {\n\t\t\t\tsort += ', '\n\t\t\t\tif (!sortColumn.secondaryAscending) {\n\t\t\t\t\tsort += `${AltColumn(sortColumn.secondarySort)} DESC`\n\t\t\t\t} else {\n\t\t\t\t\tswitch (sortColumn.secondaryEmptyToBottom) {\n\t\t\t\t\t\tcase 'string':\n\t\t\t\t\t\t\tsort += `NULLIF(${sortColumn.secondarySort as any}, '')`\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tcase 'number':\n\t\t\t\t\t\t\tsort += `NULLIF(${sortColumn.secondarySort as any}, 0)`\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// null, so do not empty to bottom\n\t\t\t\t\t\t\tsort += `${AltColumn(sortColumn.secondarySort)}`\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!!sortColumn.secondaryEmptyToBottom) sort += ' NULLS LAST'\n\t\t\t}\n\t\t}\n\n\t\treturn sort\n\t}\n\n\t/**\n\t * PaginatorOrderBy is a utility function to generate the SQL order clause based on the paginated request.\n\t *\n\t * @param {IPaginatorRequest} paginatorRequest - The incoming `IPaginatorRequest` containing the page number (req.page),\n\t *              the number of records per page (req.countPerPage),\n\t *              a potential search query (req.search),\n\t *              the sorting details (req.sortColumns),\n\t *              active status (req.active),\n\t *              and the filters (req.filterValues).\n\t *\n\t * The function specifically uses the 'sortColumns' property from the `IPaginatorRequest` to generate the SQL \"ORDER BY\" clause.\n\t * Other properties in the `IPaginatorRequest` interface:\n\t * - 'page' current page.\n\t * - 'countPerPage' determines the number of items to show per page.\n\t * - 'search' tells the server how to sort the data.\n\t * - 'active' tells the server whether to find active, inactive or all items\n\t * - 'filterValues' Other filter data (of type T) to pass to the structure to limit result sets (e.g. customer_id = 1 for all items that match customer 1)\n\t *\n\t * @returns A SQL clause as a string.\n\t *\n\t * @example\n\t *   const paginatorRequest = {\n\t *     page: 1,\n\t *     countPerPage: 20,\n\t *     search: \"John Doe\",\n\t *     sortColumns: {\n\t *       primarySort: \"lastName\",\n\t *       primaryAscending: true,\n\t *       primaryEmptyToBottom: 'string',\n\t *       secondarySort: \"firstName\",\n\t *       secondaryAscending: false,\n\t *       secondaryEmptyToBottom: 'string'\n\t *     },\n\t *     active: true,\n\t *     filterValues: {\n\t *       department: 'HR',\n\t *       location: 'New York'\n\t *     }\n\t *   };\n\t *\n\t *   const orderClause = PaginatorOrderBy(paginatorRequest);\n\t *\n\t *   console.log(orderClause); // Outputs: \"ORDER BY NULLIF(lastName, '') NULLS LAST, firstName DESC NULLS LAST\"\n\t */\n\texport const PaginatorOrderBy = (paginatorRequest: IPaginatorRequest): string => SortColumnSort(paginatorRequest.sortColumns)\n\n\t/**\n\t * The `LimitOffset` function is used to generate a LIMIT and OFFSET clause\n\t * as part of a SQL query, which aids in paginating through large datasets.\n\t * It helps in fetching a specific portion of the results.\n\t *\n\t * @param {number} limit - Specifies the maximum count of records the SQL query should return.\n\t *                         This should ideally be the count of records one would like to display per page.\n\t *\n\t * @param {number} offset - Determines the number of retrieved records to skip before starting to return records.\n\t *                          This should typically be calculated as (pageNumber - 1) * limit.\n\t *\n\t * @returns {string} Returns a string representing the LIMIT and OFFSET clause in a SQL query, structured as 'LIMIT {limit} OFFSET {offset}'.\n\t *\n\t * @remarks\n\t * This function is crucial when handling large datasets - ensuring that the entire dataset does not need to be loaded into memory at once.\n\t * It can significantly improve the performance of your application by retrieving only a portion of the records at a time.\n\t *\n\t * @example\n\t * Example usage when creating a paged query:\n\t *\n\t * const recordsPerPage = 20;  // Number of records per page\n\t * const currentPage = 3;  // Current page number\n\t * const offset = (currentPage - 1) * recordsPerPage;  // Number of records to skip\n\t *\n\t * const limitOffsetClause = LimitOffset(recordsPerPage, offset);\n\t * console.log(limitOffsetClause);  // Outputs: \"LIMIT 20 OFFSET 40\"\n\t *\n\t */\n\texport const LimitOffset = (limit: number, offset: number): string => ` LIMIT ${limit} OFFSET ${offset} `\n\n\t/**\n\t * `PaginatorLimitOffset` is a utility function that generates a SQL LIMIT and OFFSET clause from the supplied paginator response object.\n\t * This function is pivotal for implementing pagination in SQL databases as it controls the quantity of records returned\n\t * by a SQL query and determines the initial point in the dataset.\n\t *\n\t * @param {IPaginatorResponse} paginatorResponse - An object encapsulating details of the pagination.\n\t * `page` The actual page returned, which may be different from the page requested if fewer pages exist than the page that was requested.\n\t * `pageCount`, The total number of pages there would be based on the count of rows found.\n\t * `rowCount`, The total number of rows found.\n\t * `countPerPage`, How many rows make up a page.\n\t * `currentOffset`, More used by the database, but this would be the offset (e.g. 51 on the second page of a set that had CountPerPage = 50 and RowCount > 50).\n\t * Lastly, it includes `rows`, an array that holds the actual data belonging to the current page.\n\t *\n\t * @returns {string} - Yields a string with the assembled LIMIT and OFFSET clause ready to be used in SQL queries.\n\t * The standard format is `'LIMIT ' + limit + ' OFFSET ' + offset`.\n\t *\n\t * @remarks\n\t * Pagination is of utmost importance when dealing with voluminous datasets. It assists in efficiently managing memory by loading\n\t * only specified partitions of data. It bolsters performance and user experience by displaying a finite set of records at a given instance.\n\t *\n\t * @example\n\t * // Suppose the paginatorResponse object is as follows:\n\t * const paginatorResponse: IPaginatorResponse = {\n\t *    page: 3,\n\t *    pageCount: 20,\n\t *    rowCount: 500,\n\t *    countPerPage: 25,\n\t *    currentOffset: 50,\n\t *    rows: [ ... ] // An array of actual data\n\t * };\n\t *\n\t * // Invoking the function with the paginatorResponse would look like this:\n\t * const limitOffsetClause = PaginatorLimitOffset(paginatorResponse);\n\t *\n\t * // The function will return the corresponding SQL LIMIT and OFFSET clause:\n\t * console.log(limitOffsetClause); // Outputs: \"LIMIT 25 OFFSET 50\"\n\t */\n\texport const PaginatorLimitOffset = (paginatorResponse: IPaginatorResponse): string => LimitOffset(paginatorResponse.countPerPage, paginatorResponse.currentOffset)\n\n\t/**\n\t * The `AltColumn` function serves the purpose of providing an alternate representation for a specific column in a dataset.\n\t * Its utility comes into play when there is a need to process or view the data in a different format.\n\t *\n\t * When provided with the column 'appointment_date', it concatenates 'appointment_date' with 'appointment_time' spaced apart.\n\t * In scenarios where the input column isn't 'appointment_date', it returns the column as is.\n\t *\n\t * @param {any} column - A variable representing the column value that needs to be checked and possibly reformatted.\n\t *                        Although `any` type is used, it is generally expected to be a string representing column name in a dataset.\n\t *\n\t * @returns {string} - A string representing the alternated column value. If the input was 'appointment_date', the returned\n\t *                     value becomes a SQL expression that concatenates 'appointment_date' and 'appointment_time'. If not,\n\t *                     the input column value is returned untouched.\n\t *\n\t * @remarks - This function is SQL-oriented and useful for modifying SQL queries at runtime. It's specifically geared towards\n\t *            restructuring date and time data into a unified format, which can assist in clearer presentation and efficient querying.\n\t *\n\t * @example\n\t *  // If the column is 'appointment_date', the function returns a concatenated version of date and time.\n\t *  const column1 = AltColumn('appointment_date');  // Returns: \"concat_ws(' ', appointment_date, appointment_time)\"\n\t *\n\t *  // For any other column, it returns the input as is.\n\t *  const column2 = AltColumn('other_column'); // Returns: \"other_column\"\n\t */\n\tconst AltColumn = (column: any): string => {\n\t\tif (column === 'appointment_date') {\n\t\t\treturn `concat_ws(' ', appointment_date, appointment_time)`\n\t\t} else {\n\t\t\treturn column\n\t\t}\n\t}\n\n\n\t/**\n\t * The `CalcOffsetFromPage` function calculates the offset (the starting point) from the first record on a specific page.\n\t * Each page starts with an offset and ends with an offset plus the page size.\n\t *\n\t * @param {number} page - The current page number, with the first page being 1.\n\t * @param {number} pageSize - Specifies the number of records that each page can contain.\n\t * @param {number} totalRecords - Total number of records across all pages, effectively marking the length of the book.\n\t * @returns {number} Returns the offset from the first record on the specific page, giving us the starting point to read from on our current page.\n\t *\n\t * @remarks - You would use this function timing to calculate the starting point in a paginated dataset. For example, it can set the OFFSET value in a SQL query.\n\t *\n\t * @example\n\t *  // If you are on the third page, and there are 10 records on each page, and total number of records is 1000.\n\t *  const offset = CalcOffsetFromPage(3, 10, 1000);  // Returns: 20, indicating that the reading on page three starts at the 21st record.\n\t *\n\t *  // If the page number or page size is not valid (less than 1), it defaults to the first page.\n\t *  const offsetErr = CalcOffsetFromPage(0, -5, 1000); // Returns: 0, indicating that the reading starts at the beginning.\n\t *\n\t *  // If there are no records, the function also defaults to the first page.\n\t *  const offsetNone = CalcOffsetFromPage(5, 10, 0); // Returns: 0, there are no records, thus the count starts and stays at 0.\n\t */\n\texport const CalcOffsetFromPage = (page: number, pageSize: number, totalRecords: number): number => {\n\t\tif (CleanNumber(totalRecords) > 0) {\n\t\t\tconst pages = CalcPageCount(pageSize, totalRecords)\n\n\t\t\tif (CleanNumber(page) < 1) {\n\t\t\t\tpage = 1\n\t\t\t}\n\t\t\tif (CleanNumber(page) > CleanNumber(pages)) {\n\t\t\t\tpage = pages\n\t\t\t}\n\n\t\t\treturn (CleanNumber(page) - 1) * CleanNumber(pageSize)\n\t\t} else {\n\t\t\t// noinspection JSUnusedAssignment\n\t\t\tpage = 1\n\n\t\t\treturn 0\n\t\t}\n\t}\n\n\n\t/**\n\t * The `CalcPageCount` function computes the total number of pages required to\n\t * display all records, given a number of records to be displayed per page and a total count of records.\n\t *\n\t * This function comes into play when dealing with paginated data structures where the data has to be partitioned into pages of a specific size.\n\t *\n\t * @param {number} pageSize - Specifies the number of records that each page is intended to hold.\n\t * @param {number} totalRecords - Denotes the overall quantity of records to be paginated.\n\t * @returns {number} - Gives us the necessary total number of pages that can carry all the records.\n\t *                     If total records is zero or less, returns 0 as there are no pages to display.\n\t *\n\t * @remarks - The function doesn't just divide totalRecords by pageSize due to how integer division works. Adding (pageSize - 1)\n\t *            to the numerator before division ensures that any leftover records that would have formed part of an additional page\n\t *            aren't lost. This function can be key in setting up navigation for paginated views or setting LIMITs in SQL queries.\n\t *\n\t * @example\n\t *  // If there are 100 records with 10 records per page, the function will return 10 pages.\n\t *  const pages = CalcPageCount(10, 100);  // Returns: 10\n\t *\n\t *  // If there are 102 records with 10 records per page, the function will return 11 pages (2 records on the last page).\n\t *  const pagesWithLeftover = CalcPageCount(10, 102); // Returns: 11\n\t *\n\t *  // If the total records is 0 or less, the function will return 0 pages.\n\t *  const noRecords = CalcPageCount(10, 0); // Returns: 0\n\t */\n\texport const CalcPageCount = (pageSize: number, totalRecords: number): number => {\n\t\tif (CleanNumber(totalRecords) > 0) {\n\t\t\treturn Math.floor((CleanNumber(totalRecords) + (CleanNumber(pageSize) - 1)) / CleanNumber(pageSize))\n\t\t} else {\n\t\t\treturn 0\n\t\t}\n\t}\n\n\t/**\n\t * The `ResetIDs` function resets the ID sequences of all tables in the connected PostgreSQL database.\n\t * In database systems, an ID sequence generates unique incremental numbers for record identification,\n\t * the `ResetIDs` function ensures all sequences start from their initial value.\n\t *\n\t * This function comes in handy in scenarios where the database is being rebuilt, and there's a need to\n\t * reset all auto-increment fields to start afresh, or when the ID sequence is off track due to manual\n\t * insertion or deletion of records.\n\t *\n\t * @param {TConnection} connection - A PostgreSQL database connection object.\n\t * @returns {Promise<void>} - A Promise that signifies successful completion when the ID sequence has been\n\t * reset for all applicable tables in the PostgreSQL database.\n\t *\n\t * @remarks\n\t * - This function should only be used cautiously, especially in production environments, due to the\n\t * potential of ID conflicts in active databases.\n\t * - This function works only with tables having a column named 'id' as it is often used as primary key\n\t * in PostgreSQL databases.\n\t *\n\t * @example\n\t * //Reset IDs in all tables of the connected database\n\t * ResetIDs(dbConnection).then(() => {\n\t *    console.log('ID sequences for all tables have been reset');\n\t * }).catch((error) => {\n\t *    console.log('An error occurred: ', error);\n\t * });\n\t */\n\texport const ResetIDs = async (connection: TConnection) => {\n\t\tlet tables = await PGSQL.TablesArray(connection)\n\n\t\tfor (const table of tables) {\n\t\t\tif (await TableColumnExists(connection, table, 'id')) {\n\t\t\t\tawait TableResetIncrement(connection, table, 'id')\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * `GetTypes()` is a function that retrieves a list of PostgreSQL enum types from the provided database connection.\n\t *\n\t * @param {TConnection} connection - This parameter is a PostgreSQL database connection object.\n\t *\n\t * @returns {Promise<PGEnum[]>} - After successful execution of the function,\n\t * a Promise is returned which resolves to an array of PGEnum objects.\n\t * Each PGEnum object represents a unique enumerated type in the PostgreSQL database,\n\t * containing information such as its name and corresponding values.\n\t *\n\t * @remarks\n\t * - Use this function only when you need to retrieve PostgreSQL enumerated types. Unnecessary calls can increase load on your database.\n\t *\n\t * @example\n\t * // get enum types\n\t * GetTypes(dbConnection)\n\t *    .then(enums => {\n\t *        console.log('The retrieved PostgreSQL enum types are: ', enums);\n\t *    })\n\t *    .catch(err => {\n\t *        console.error('An error occurred when retrieving PostgreSQL enum types: ', err);\n\t *    });\n\t *\n\t */\n\texport const GetTypes = async (connection: TConnection): Promise<PGEnum[]> => {\n\t\tconst enumItems = await TypesArray(connection)\n\n\t\tlet enums: PGEnum[] = []\n\n\t\tfor (const enumItem of enumItems) {\n\t\t\tenums.push(\n\t\t\t\tnew PGEnum({\n\t\t\t\t\tenumName: enumItem,\n\t\t\t\t\tvalues: await TypeData(connection, enumItem),\n\t\t\t\t\tdefaultValue: undefined\n\t\t\t\t} as any)\n\t\t\t)\n\t\t}\n\n\t\treturn enums\n\t}\n\n\t/**\n\t * The `TableComments` function fetches any comments associated with a specified table in a PostgreSQL database.\n\t *\n\t * @param {TConnection} connection - The parameter represents a PostgreSQL database connection.\n\t * @param {string}  table - This parameter takes in the name of the table as a string from which comments are to be retrieved.\n\t * @param {string}  schema - This optional parameter takes the name of the schema that the table belongs to. If your database\n\t *        uses schemas to organize tables, you should provide this parameter. If not provided it assumes the default schema.\n\t *\n\t * @returns {Promise<string | null>} - After successful execution, the function returns a Promise\n\t *        that resolves to a string containing the comment associated with the table or null, if there is no such comment available.\n\t *\n\t * @remarks\n\t * - The returned Promise should be handled to catch and deal with any potential errors.\n\t *\n\t * @example\n\t * // get comments of the specified table\n\t * TableComments(dbConnection, 'myTable', 'mySchema')\n\t *    .then(comment => {\n\t *       console.log('The retrieved table comment is: ', comment);\n\t *    })\n\t *    .catch(err => {\n\t *       console.error('An error occurred when retrieving table comment: ', err);\n\t *    });\n\t */\n\texport const TableComments = async (connection: TConnection, table: string, schema?: string): Promise<string | null> => {\n\t\treturn PGSQL.FetchOneValue<string | null>(connection, `\n\t\t\tSELECT obj_description('${!schema ? '' : `${schema}.`}${table}'::regclass, 'pg_class')`)\n\t}\n\n\t/**\n\t * `TableColumnComments` fetches the comments associated with each column of a specified table in a PostgreSQL database.\n\t *\n\t * @param {TConnection} connection - PostgreSQL database connection object.\n\t * @param {string} table - Name of the table for which column comments are to be retrieved.\n\t * @param {string} [schema] - Name of the schema, optional. If not specified, defaults to the current schema.\n\t *\n\t * @returns {Promise<Array<{ column_name: string, column_comment: string | null }>>} -\n\t *          Returns a promise that, when resolves, contains an array of objects where\n\t *          each object represents a column and its corresponding comment.\n\t *\n\t * @remarks\n\t * - Ensure the database connection is valid and connected before invoking.\n\t * - Verify that the table and the schema (if given) exist in the database.\n\t *\n\t * @example\n\t *  TableColumnComments(dbConnection, 'users', 'mySchema')\n\t *    .then(columnComments => {\n\t *        console.log(columnComments)\n\t *    })\n\t *    .catch(err => {\n\t *        console.error(err)\n\t *    });\n\t *\n\t */\n\texport const TableColumnComments = async (connection: TConnection, table: string, schema?: string): Promise<{\n\t\tcolumn_name: string,\n\t\tcolumn_comment: string | null\n\t}[]> => {\n\t\treturn PGSQL.FetchMany<{ column_name: string, column_comment: string | null }>(connection, `\n\t\t\tSELECT cols.column_name,\n\t\t\t       (SELECT pg_catalog.COL_DESCRIPTION(c.oid, cols.ordinal_position::INT)\n\t\t\t        FROM pg_catalog.pg_class c\n\t\t\t        WHERE c.oid = (SELECT cols.table_name::REGCLASS::OID)\n\t\t\t\t      AND c.relname = cols.table_name) AS column_comment\n\n\t\t\tFROM information_schema.columns cols\n\t\t\tWHERE cols.table_schema = '${CurrentSchema(schema)}'\n\t\t\t  AND cols.table_name = '${table}'`)\n\t}\n\n\t/**\n\t * `GetPGTable` function asynchronously retrieves a detailed metadata of a PostgreSQL table.\n\t * This metadata includes table comments, column data with comments, foreign keys, indexes etc.\n\t *\n\t * @param {TConnection} connection - An established connection to a PostgreSQL database.\n\t * @param {string} table - Name of the PostgreSQL table.\n\t * @param {string} [schema] - Optional name of the schema. Defaults to current schema if not provided.\n\t *\n\t * @returns {Promise<PGTable>} - A Promise that upon resolution gives a PGTable object, representing table metadata.\n\t *\n\t * @remarks\n\t * - Ensure `connection` is valid and connected to the database.\n\t * - Verify existence of `table` and `schema` (if provided) in the database before invoking.\n\t * - Catch and handle any errors that might occur during asynchronous execution.\n\t *\n\t * @example\n\t * GetPGTable(dbConnection, 'users')\n\t *   .then(pgTableMetadata => {\n\t *       console.log(pgTableMetadata);\n\t *   })\n\t *   .catch(err => {\n\t *       console.error('Error occurred while fetching table metadata:', err);\n\t *   });\n\t *\n\t */\n\texport const GetPGTable = async (connection: TConnection, table: string, schema?: string): Promise<PGTable> => {\n\t\tconst pgTable = new PGTable()\n\n\t\tpgTable.name = table\n\t\tpgTable.description = await TableComments(connection, table, schema) ?? ''\n\n\t\tconst columnComments = await TableColumnComments(connection, table, schema)\n\n\t\tconst columns = await TableColumnsData(connection, table, schema)\n\t\tfor (const column of columns) {\n\t\t\tconst pgColumn = new PGColumn({\n\t\t\t\t...column,\n\t\t\t\tgeneratedAlwaysAs: column.generation_expression,\n\t\t\t\tisAutoIncrement: IsOn(column.identity_increment),\n\t\t\t\tudt_name: column.udt_name.toString().startsWith('_') ? column.udt_name.toString().substring(1) : column.udt_name,\n\t\t\t\tarray_dimensions: column.udt_name.toString().startsWith('_') ? [null] : [],\n\t\t\t\tcolumn_default: ((column.column_default ?? '').toString().startsWith('\\'NULL\\'') || (column.column_default ?? '').toString().startsWith('NULL::')) ? null : (column.column_default ?? '').toString().startsWith('\\'\\'::') ? '' : column.column_default,\n\t\t\t\tcolumn_comment: columnComments.find(col => col.column_name === column.column_name)?.column_comment ?? ''\n\t\t\t})\n\n\t\t\tpgTable.columns.push(pgColumn)\n\t\t}\n\n\t\tconst fks = await TableFKsData(connection, table)\n\t\tfor (const fk of fks) {\n\t\t\tconst pgForeignKey = new PGForeignKey({\n\t\t\t\tcolumnNames: (fk.columnNames as string[]).reduce<string[]>((results, columnName) => results.includes(columnName) ? results : [...results, columnName], []),\n\t\t\t\tprimaryTable: fk.primaryTable,\n\t\t\t\tprimaryColumns: (fk.primaryColumns as string[]).reduce<string[]>((results, primaryColumn) => results.includes(primaryColumn) ? results : [...results, primaryColumn], [])\n\t\t\t} as any)\n\n\t\t\tpgTable.foreignKeys.push(pgForeignKey)\n\t\t}\n\n\t\tconst indexes = await TableIndexesData(connection, table)\n\t\tfor (const index of indexes) {\n\t\t\tconst indexDef = index.indexdef as string\n\n\t\t\tconst wherePos = indexDef.toUpperCase().indexOf(' WHERE ')\n\n\t\t\tconst pgIndex = new PGIndex({\n\t\t\t\tcolumns: indexDef\n\t\t\t\t\t.substring(indexDef.indexOf('(') + 1, wherePos > 0 ? wherePos - 1 : indexDef.length - 1)\n\t\t\t\t\t.split(',')\n\t\t\t\t\t.map(idx => idx.trim())\n\t\t\t\t\t.filter(idx => !!idx),\n\t\t\t\tisUnique: indexDef.includes(' UNIQUE '),\n\t\t\t\twhereCondition: wherePos > 0 ? indexDef.substring(wherePos + 7).trim() : null\n\t\t\t})\n\n\t\t\tpgTable.indexes.push(pgIndex)\n\t\t}\n\n\t\treturn pgTable\n\t}\n\n\t/**\n\t * `CleanSQL` function sanitizes an SQL query by removing all semicolon (`;`) characters.\n\t * This can be useful to avoid SQL injection or execute complex queries containing multiple statements.\n\t *\n\t * @param {string} sql - Raw SQL string that needs to be sanitized.\n\t *\n\t * @returns {string} - The sanitized SQL string with all semicolons (`;`) removed.\n\t *\n\t * @remarks\n\t * - Consider the impact of removing semicolons on your SQL queries before using this function.\n\t *   This can potentially lead to unintended consequences if not used properly.\n\t *\n\t * @example\n\t *\n\t * const rawSQL = 'SELECT * FROM users; DROP TABLE users;'\n\t * const cleanSQL = CleanSQL(rawSQL);\n\t * console.log(cleanSQL); // Prints: 'SELECT * FROM users DROP TABLE users'\n\t *\n\t */\n\texport const CleanSQL = (sql: string): string => ReplaceAll(';', '', sql)\n}\n\n/**\n * Checks if a given value is a valid PostgreSQL integer.\n * @param value - The value to check.\n * @param unsigned - Optional flag to check for an unsigned integer. Default is false (signed).\n * @returns true if the value is a valid PostgreSQL integer, false otherwise.\n */\nexport function IsValidPostgresInteger(value: any, unsigned: boolean = false): boolean {\n\tif (!IsWholeNumber(value)) return false\n\tif (Array.isArray(value)) return false\n\n\tconst minSignedInt = -2147483648\n\tconst maxSignedInt = 2147483647\n\tconst maxUnsignedInt = 4294967295\n\n\tconst useValue = CleanNumberNull(value)\n\n\tif (typeof useValue !== 'number' || !Number.isInteger(useValue)) {\n\t\treturn false\n\t}\n\n\tif (unsigned) {\n\t\treturn useValue >= 0 && useValue <= maxUnsignedInt\n\t} else {\n\t\treturn useValue >= minSignedInt && useValue <= maxSignedInt\n\t}\n}\n","import type {TObjectConstraint, TObjectFromFormDataOptions} from '@empowerfresh/intelliwake'\nimport {\n\tCleanNumber,\n\tConstrainObject,\n\tObjectFromFormData,\n\tOmitProperty,\n\tOmitUndefined,\n\tPickProperty,\n\tReduceObjectToOtherKeys,\n\tToArray\n} from '@empowerfresh/intelliwake'\nimport {PGSQL, TConnection} from './PGSQL/PGSQL'\nimport {PGParams} from './PGSQL/PGParams'\n\nexport type TLoadOptions<RECORD extends Record<string, any>> = {\n\tsortPrimary?: keyof RECORD,\n\tascendingPrimary?: boolean,\n\tsortSecondary?: keyof RECORD,\n\tascendingSecondary?: boolean,\n\tignoreCustomerCheck?: boolean\n}\n\nexport abstract class CTableBase<RECORD extends Record<string, any>, TABLES extends string> {\n\tpublic record: RECORD\n\tpublic readonly recordDefault: RECORD\n\tpublic recordBaseline: RECORD\n\tpublic updateID: (keyof RECORD) | (keyof RECORD)[]\n\tpublic abstract readonly table: TABLES\n\tprotected nullIfFalsey: (keyof RECORD)[]\n\tprotected arrayFormDataItems: (keyof RECORD)[]\n\tprotected excludeColumnsSave: (keyof RECORD)[]\n\tprotected excludeColumnsInsert: (keyof RECORD)[]\n\tprotected excludeColumnsUpdate: (keyof RECORD)[]\n\tprotected constraint: TObjectConstraint<RECORD> | null = null\n\tpublic connection: TConnection\n\tpublic readerConnection: TConnection | null | undefined\n\n\tpublic defaultImportColumns: (keyof RECORD)[] | null = null\n\tpublic defaultImportExcludeColumns: (keyof RECORD)[] | null = null\n\n\tpublic ignoreCustomerCheck = false\n\n\tprotected constructor(connection: TConnection, defaultValues: RECORD, options?: {\n\t\tconstraint?: TObjectConstraint<RECORD> | null\n\t\tnullIfFalsey?: (keyof RECORD)[]\n\t\tarrayFormDataItems?: (keyof RECORD)[]\n\t\texcludeColumnsSave?: (keyof RECORD)[]\n\t\texcludeColumnsInsert?: (keyof RECORD)[]\n\t\texcludeColumnsUpdate?: (keyof RECORD)[]\n\t\tignoreCustomerCheck?: boolean\n\t\treaderConnection?: TConnection | null\n\t}) {\n\t\tthis.connection = connection\n\t\tthis.record = {...defaultValues}\n\t\tthis.recordBaseline = {...this.record}\n\t\tthis.recordDefault = {...defaultValues}\n\t\tthis.updateID = 'id' as keyof RECORD\n\n\t\tthis.constraint = options?.constraint ?? null\n\t\tthis.nullIfFalsey = options?.nullIfFalsey ?? []\n\t\tthis.arrayFormDataItems = options?.arrayFormDataItems ?? []\n\t\tthis.excludeColumnsSave = options?.excludeColumnsSave ?? []\n\t\tthis.excludeColumnsInsert = options?.excludeColumnsInsert ?? []\n\t\tthis.excludeColumnsUpdate = options?.excludeColumnsUpdate ?? []\n\t\tthis.ignoreCustomerCheck = !!options?.ignoreCustomerCheck\n\t\tthis.readerConnection = options?.readerConnection\n\t}\n\n\t/**\n\t * Applies the given constraint to the record, forcing it to conform to most database constraints\n\t *\n\t * @return {this} The current object, after applying the constraint to the record.\n\t */\n\tpublic constrainRecord(): this {\n\t\tif (this.constraint) {\n\t\t\tthis.record = ConstrainObject(this.record, this.constraint)\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Updates the record object with the provided values.\n\t *\n\t * @param {Partial<RECORD>} values - The partial values to update the record with.\n\t * @return {this} - Returns the instance of the object that called the method.\n\t */\n\tpublic setFromAny(values: Partial<RECORD>): this {\n\t\tthis.record = {...this.record, ...ReduceObjectToOtherKeys(values, this.recordDefault)}\n\t\treturn this.constrainRecord()\n\t}\n\n\t/**\n\t * Sets the values of the record object from the provided formData object.\n\t *\n\t * @param {FormData} formData - The FormData object containing the data to set on the record.\n\t * @param {TObjectFromFormDataOptions<RECORD>} [options] - Optional options for converting the data.\n\t * @returns {this} - Returns the current instance of the class.\n\t */\n\tpublic setFromFormData(formData: FormData, options?: TObjectFromFormDataOptions<RECORD>): this {\n\t\tthis.record = {...this.record, ...ObjectFromFormData(formData, options)}\n\n\t\treturn this.constrainRecord()\n\t}\n\n\t/**\n\t * Inserts a record into the database table.\n\t *\n\t * @returns {Promise<this>} A Promise that resolves to the current instance of the object.\n\t * @throws {Error} Throws an error if the object cannot be created for insertion.\n\t */\n\tpublic async insert(): Promise<this> {\n\t\tawait this.preInsert()\n\n\t\tthis.constrainRecord()\n\n\t\tawait this.convertToSave()\n\n\t\tconst obj = this.objectToInsert()\n\n\t\tif (obj) {\n\t\t\tconst results = await PGSQL.InsertAndGetReturning(this.connection, this.table, obj)\n\t\t\tif (results) {\n\t\t\t\tthis.setFromAny(results)\n\n\t\t\t\tawait this.convertAfterLoad()\n\n\t\t\t\tawait this.postInsert()\n\n\t\t\t\t// await this.reportEachBaselineChanged(async (column, fromValue, toValue) => await this.valueChanged('INSERT', column, fromValue, toValue))\n\n\t\t\t\tthis.setBaseline()\n\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(`Could not create object to insert ${this.table}`)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Updates the record in the database.\n\t *\n\t * @returns {Promise<this>} - A Promise that resolves to this object after the update is complete.\n\t * @throws {Error} - Throws an error if the object to update could not be created.\n\t */\n\tpublic async update(): Promise<this> {\n\t\tawait this.preUpdate()\n\n\t\tthis.constrainRecord()\n\n\t\tawait this.convertToSave()\n\n\t\tconst obj = this.objectToUpdate()\n\n\t\tif (obj) {\n\t\t\tconst results = await PGSQL.UpdateAndGetReturning(\n\t\t\t\tthis.connection,\n\t\t\t\tthis.table,\n\t\t\t\tToArray(this.updateID).reduce<any>((result, id) => {\n\t\t\t\t\tresult[id] = obj[id]\n\t\t\t\t\treturn result\n\t\t\t\t}, {}),\n\t\t\t\tOmitProperty(obj, 'id')\n\t\t\t)\n\t\t\tif (results) {\n\t\t\t\tthis.setFromAny(results)\n\n\t\t\t\tawait this.convertAfterLoad()\n\n\t\t\t\tawait this.postUpdate()\n\n\t\t\t\tthis.setBaseline()\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(`Could not create object to update ${this.table}`)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Checks if the record is saved.\n\t *\n\t * @returns {Promise<boolean>} A Promise that resolves to true if the record is saved, or false otherwise.\n\t */\n\tpublic async isSaved(): Promise<boolean> {\n\t\treturn (this.record as any).id > 0\n\t}\n\n\t/**\n\t * Saves the record with either an insert or update, as appropriate.\n\t *\n\t * @returns {Promise<this>} A promise that resolves to the current instance of the class after saving the record.\n\t * @throws {Error} If the record could not be saved.\n\t */\n\tpublic async save(): Promise<this> {\n\t\tawait this.preIDCheck()\n\t\tif (this.record) {\n\t\t\tif (await this.isSaved()) {\n\t\t\t\treturn this.update()\n\t\t\t} else {\n\t\t\t\treturn this.insert()\n\t\t\t}\n\t\t}\n\n\t\tthrow new Error('Could not save record')\n\t}\n\n\t/**\n\t * Deletes the record from the database table.\n\t *\n\t * @returns {Promise<this>} A Promise that resolves with the current instance after the deletion is successful.\n\t */\n\tpublic async delete(): Promise<this> {\n\t\tawait this.preDelete()\n\n\t\tawait PGSQL.Delete(this.connection, this.table, PickProperty(this.record, ...(ToArray(this.updateID) as any)))\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Loads a record by ID and sets changes.\n\t *\n\t * @param {Partial<RECORD>} values - The values to set for the record.\n\t * @param ignoreCustomerCheck\n\t * @returns {Promise<this>} - A promise that resolves with the current instance of the record.\n\t */\n\tpublic async loadByIDAndSetChanges(values: Partial<RECORD>, ignoreCustomerCheck = false): Promise<this> {\n\t\tconst id = (values as any)['id']\n\n\t\tif (id) {\n\t\t\tawait this.loadByID(id, ignoreCustomerCheck)\n\t\t}\n\n\t\tthis.setFromAny(values)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Loads a record by ID and sets it as the current record.  If invalid value, throws an error.\n\t *\n\t * @param {number | string | null | undefined} id - The ID of the record to load.\n\t *\n\t * @param ignoreCustomerCheck\n\t * @returns {Promise<this>} - A promise that resolves with the current instance of the method's class.\n\t *\n\t * @throws {Error} Throws an error if no ID is specified.\n\t * @throws {Error} Throws an error if the record is not found.\n\t */\n\tpublic async loadID(id: number | string | null | undefined, ignoreCustomerCheck = false): Promise<this> {\n\t\tif (!id) {\n\t\t\tthrow new Error('No ID specified')\n\t\t}\n\n\t\tthis.ignoreCustomerCheck = this.ignoreCustomerCheck || ignoreCustomerCheck\n\n\t\tconst record = await PGSQL.GetByID<RECORD>(this.readerConnection ?? this.connection, this.table, CleanNumber(id))\n\n\t\tif (!record) {\n\t\t\tthrow new Error(`Record not found ${this.table}`)\n\t\t}\n\n\t\tthis.record = (record as RECORD) ?? {...this.recordDefault}\n\n\t\tawait this.postSelect()\n\n\t\tthis.setBaseline()\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Load an item by its ID.  If no id exists, returns null.\n\t *\n\t * @param {number | string | null | undefined} id - The ID of the item to load.\n\t * @param ignoreCustomerCheck\n\t * @returns {Promise<this | null>} A Promise that resolves to the loaded item if successful, otherwise null.\n\t */\n\tpublic async loadByID(id: number | string | null | undefined, ignoreCustomerCheck = false): Promise<this | null> {\n\t\tif (!id) return null\n\n\t\ttry {\n\t\t\t// noinspection UnnecessaryLocalVariableJS\n\t\t\tconst item = await this.loadID(id, ignoreCustomerCheck)\n\t\t\treturn item\n\t\t} catch (err) {\n\t\t\treturn null\n\t\t}\n\t}\n\n\t/**\n\t * Reloads the current record by calling the loadByID method.\n\t *\n\t * @returns {Promise} A Promise that resolves after the record is reloaded.\n\t */\n\tpublic async reload() {\n\t\tif ((this.record as any).id) {\n\t\t\tawait this.loadByID((this.record as any).id)\n\t\t}\n\t}\n\n\t/**\n\t * Loads the values from the database based on the provided options.\n\t *\n\t * @param {Partial<RECORD>} values - The values used to filter the records.\n\t * @param {object} [options] - The options for sorting and filtering the records.\n\t * @param {keyof RECORD} [options.sortPrimary] - The primary field used for sorting the records.\n\t * @param {boolean} [options.ascendingPrimary=true] - Indicates whether to sort the records in ascending order based on the primary field. Defaults to true.\n\t * @param {keyof RECORD} [options.sortSecondary] - The secondary field used for sorting the records.\n\t * @param {boolean} [options.ascendingSecondary=true] - Indicates whether to sort the records in ascending order based on the secondary field. Defaults to true.\n\t * @param {boolean} [options.ignoreCustomerCheck=false] - Indicates whether to ignore customer check while fetching the records. Defaults to false.\n\t *\n\t * @returns {Promise<this>} - A Promise that resolves with the updated object.\n\t * @throws {Error} If the item could not be fetched from the database.\n\t */\n\tpublic async loadValues(\n\t\tvalues: Partial<RECORD>,\n\t\toptions?: {\n\t\t\tsortPrimary?: keyof RECORD,\n\t\t\tascendingPrimary?: boolean,\n\t\t\tsortSecondary?: keyof RECORD,\n\t\t\tascendingSecondary?: boolean,\n\t\t\tignoreCustomerCheck?: boolean\n\t\t}\n\t): Promise<this> {\n\t\tthis.ignoreCustomerCheck = this.ignoreCustomerCheck || !!options?.ignoreCustomerCheck\n\n\t\tconst params = new PGParams()\n\n\t\tlet where = ``\n\t\tif (Object.keys(values).length > 0) {\n\t\t\twhere = 'WHERE ' + PGSQL.BuildWhereComponents(values, params)\n\t\t}\n\n\t\tlet sort = ''\n\t\tif (options?.sortPrimary) {\n\t\t\tsort += ` ORDER BY ${PGSQL.CleanSQL(options.sortPrimary as string)} ${(options?.ascendingPrimary ?? true) ? 'ASC' : 'DESC'}`\n\t\t\tif (options?.sortSecondary) {\n\t\t\t\tsort += `, ${PGSQL.CleanSQL(options?.sortSecondary as string)} ${(options?.ascendingSecondary ?? true) ? 'ASC' : 'DESC'}`\n\t\t\t}\n\t\t}\n\n\t\tconst result = await PGSQL.FetchOne<RECORD>(\n\t\t\tthis.readerConnection ?? this.connection,\n\t\t\t`SELECT *\n\t\t\t FROM ${this.table} ${where}` + sort,\n\t\t\tparams.values\n\t\t)\n\n\t\tif (!result) {\n\t\t\tthrow new Error(`Could not fetch item ${this.table}`)\n\t\t} else {\n\t\t\tthis.record = result\n\t\t}\n\n\t\tawait this.postSelect()\n\n\t\tthis.setBaseline()\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Loads records by their matching values.\n\t *\n\t * @param {Partial<RECORD>} values - The values to match against the records.\n\t * @param {TLoadOptions<RECORD>} [options] - The options for loading the records.\n\t * @returns {Promise<this | null>} A Promise that resolves to this object or `null` if an error occurs.\n\t */\n\tpublic async loadByValues(\n\t\tvalues: Partial<RECORD>,\n\t\toptions?: TLoadOptions<RECORD>\n\t): Promise<this | null> {\n\t\ttry {\n\t\t\treturn await this.loadValues(values, options)\n\t\t} catch (err) {\n\t\t\treturn null\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the given values exist.\n\t *\n\t * @param {Partial<RECORD>} values - The values to check for existence.\n\t *\n\t * @param ignoreCustomerCheck\n\t * @return {Promise<boolean>} - A promise that resolves to a boolean value indicating if the values exist.\n\t */\n\tpublic async existsValues(\n\t\tvalues: Partial<RECORD>, ignoreCustomerCheck = false\n\t): Promise<boolean> {\n\t\ttry {\n\t\t\treturn !!(await this.loadValues(values, {ignoreCustomerCheck}))\n\t\t} catch (err) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t/**\n\t * Loads the specified values into the object or initializes it if no values are provided.\n\t *\n\t * @param {Partial<RECORD>} values - The values to load into the object.\n\t * @param {Object} [options] - The options for sorting the primary and secondary keys.\n\t * @param {keyof RECORD} [options.sortPrimary] - The primary key to sort by.\n\t * @param {boolean} [options.ascendingPrimary] - Specifies whether the primary key should be sorted in ascending order.\n\t * @param {keyof RECORD} [options.sortSecondary] - The secondary key to sort by.\n\t * @param {boolean} [options.ascendingSecondary] - Specifies whether the secondary key should be sorted in ascending order.\n\t *\n\t * @return {Promise<this>} - The object after loading the values or initializing it.\n\t */\n\tpublic async loadValuesOrInitial(\n\t\tvalues: Partial<RECORD>,\n\t\toptions?: {\n\t\t\tsortPrimary?: keyof RECORD,\n\t\t\tascendingPrimary?: boolean,\n\t\t\tsortSecondary?: keyof RECORD,\n\t\t\tascendingSecondary?: boolean,\n\t\t\tignoreCustomerCheck?: boolean\n\t\t}\n\t): Promise<this> {\n\t\ttry {\n\t\t\treturn await this.loadValues(values, options)\n\t\t} catch (err) {\n\t\t\treturn this\n\t\t}\n\t}\n\n\t/**\n\t * Loads the ID or initializes the object.\n\t *\n\t * @param {number | string | null | undefined} id - The ID to load or null/undefined to initialize the object.\n\t * @param ignoreCustomerCheck\n\t * @return {Promise<this>} - A promise that resolves to the current object.\n\t */\n\tpublic async loadIDOrInitial(\n\t\tid: number | string | null | undefined, ignoreCustomerCheck = false\n\t): Promise<this> {\n\t\tif (!id) return this\n\t\treturn this.loadValuesOrInitial({id: id} as any, {ignoreCustomerCheck})\n\t}\n\n\t/**\n\t * Loads values or sets initial values for the record.\n\t *\n\t * @param {Partial<RECORD>} values - The values to be loaded or set.\n\t * @param {Object} [options] - Optional parameters for sorting the primary and secondary keys.\n\t * @param {keyof RECORD} [options.sortPrimary] - The primary key to sort the values by.\n\t * @param {boolean} [options.ascendingPrimary] - Indicates whether to sort the primary key in ascending order.\n\t * @param {keyof RECORD} [options.sortSecondary] - The secondary key to sort the values by.\n\t * @param {boolean} [options.ascendingSecondary] - Indicates whether to sort the secondary key in ascending order.\n\t * @returns {Promise<this>} - A Promise that resolves to the current object.\n\t */\n\tpublic async loadValuesOrInitialSet(\n\t\tvalues: Partial<RECORD>,\n\t\toptions?: {\n\t\t\tsortPrimary?: keyof RECORD,\n\t\t\tascendingPrimary?: boolean,\n\t\t\tsortSecondary?: keyof RECORD,\n\t\t\tascendingSecondary?: boolean,\n\t\t\tignoreCustomerCheck?: boolean\n\t\t}\n\t): Promise<this> {\n\t\ttry {\n\t\t\treturn await this.loadValues(values, options)\n\t\t} catch (err) {\n\t\t\tthis.setFromAny(values)\n\t\t\treturn this\n\t\t}\n\t}\n\n\t/**\n\t * Retrieves a list of records based on the specified IDs.\n\t *\n\t * @param {number[] | null} ids - An array of record IDs to retrieve. If not provided or is empty, an empty array will be returned.\n\t * @returns {Promise<RECORD[]>} - A promise that resolves to an array of record objects.\n\t */\n\tpublic async listRecordsByIDs(ids?: number[] | null): Promise<RECORD[]> {\n\t\tif (!ids || ids.length === 0) return []\n\n\t\t// noinspection SqlResolve\n\t\tconst sql = `SELECT *\n\t\t             FROM ${this.table}\n\t\t             WHERE id = ANY ($1::INT[]) `\n\n\t\treturn await PGSQL.FetchMany<RECORD>(this.readerConnection ?? this.connection, sql, [ids])\n\t}\n\n\t/**\n\t * Returns a list of records based on the provided values and options.\n\t *\n\t * @param {Partial<RECORD>} whereValues - The values to filter the records by.\n\t * @param {Object} options - The options to customize the query.\n\t * @param {keyof RECORD} options.sortPrimary - The primary field to sort the records by.\n\t * @param {boolean} options.ascendingPrimary - Specifies whether to sort the records in ascending order by the primary field.\n\t * @param {keyof RECORD} options.sortSecondary - The secondary field to sort the records by.\n\t * @param {boolean} options.ascendingSecondary - Specifies whether to sort the records in ascending order by the secondary field.\n\t * @param {boolean} options.ignoreCustomerCheck - Specifies whether to ignore customer checks in the query.\n\t *\n\t * @returns {Promise<RECORD[]>} The list of records that match the provided values and options.\n\t */\n\tpublic async listRecordsByValues(\n\t\twhereValues?: Partial<RECORD>,\n\t\toptions?: {\n\t\t\tsortPrimary?: keyof RECORD,\n\t\t\tascendingPrimary?: boolean,\n\t\t\tsortSecondary?: keyof RECORD,\n\t\t\tascendingSecondary?: boolean\n\t\t}\n\t): Promise<RECORD[]> {\n\t\tconst params = new PGParams()\n\n\t\tlet sql = `SELECT *\n\t\t           FROM ${this.table}`\n\n\t\tif (whereValues) {\n\t\t\tconst useValues = OmitUndefined(whereValues)\n\t\t\tif (Object.keys(useValues).length > 0) {\n\t\t\t\tsql += ' WHERE ' + PGSQL.BuildWhereComponents(useValues, params)\n\t\t\t}\n\t\t}\n\n\t\tif (options?.sortPrimary) {\n\t\t\tsql += ` ORDER BY ${PGSQL.CleanSQL(options?.sortPrimary as string)} ${(options?.ascendingPrimary ?? true) ? 'ASC' : 'DESC'}`\n\t\t\tif (options?.sortSecondary) {\n\t\t\t\tsql += `, ${PGSQL.CleanSQL(options?.sortSecondary as string)} ${(options?.ascendingSecondary ?? true) ? 'ASC' : 'DESC'}`\n\t\t\t}\n\t\t}\n\n\t\treturn await PGSQL.FetchMany<RECORD>(this.readerConnection ?? this.connection, sql, params.values)\n\t}\n\n\t/**\n\t * Lists the IDs of records based on the specified values, and sorts the results.\n\t *\n\t * @param {Partial<RECORD>} whereValues - Specifies the values to filter the records.\n\t * @param {keyof RECORD} sortPrimary - Specifies the primary field to sort the records by.\n\t * @param {boolean} ascendingPrimary - Indicates whether the primary field should be sorted in ascending order (true) or descending order (false). Default is true.\n\t * @param {keyof RECORD} sortSecondary - Specifies the secondary field to sort the records by.\n\t * @param {boolean} ascendingSecondary - Indicates whether the secondary field should be sorted in ascending order (true) or descending order (false). Default is true.\n\t * @return {Promise<number[]>} A promise that resolves with an array of IDs of the filtered and sorted records.\n\t */\n\tpublic async listIDsByValues(\n\t\twhereValues?: Partial<RECORD>,\n\t\tsortPrimary?: keyof RECORD,\n\t\tascendingPrimary = true,\n\t\tsortSecondary?: keyof RECORD,\n\t\tascendingSecondary = true\n\t): Promise<number[]> {\n\t\tconst params = new PGParams()\n\n\t\tlet sql = `SELECT id\n\t\t           FROM ${this.table}`\n\n\t\tif (whereValues) {\n\t\t\tconst useWhereValues: Record<string, any> = {}\n\t\t\tfor (const key of Object.keys(whereValues)) {\n\t\t\t\tif ((whereValues as any)[key] !== undefined) {\n\t\t\t\t\tuseWhereValues[key] = (whereValues as any)[key]\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (Object.keys(useWhereValues).length > 0) {\n\t\t\t\tsql += ' WHERE ' + PGSQL.BuildWhereComponents(useWhereValues, params)\n\t\t\t}\n\t\t}\n\n\t\tif (sortPrimary) {\n\t\t\tsql += ` ORDER BY ${params.add(sortPrimary)} ${ascendingPrimary ? 'ASC' : 'DESC'}`\n\t\t\tif (sortSecondary) {\n\t\t\t\tsql += `, ${params.add(sortSecondary)} ${ascendingSecondary ? 'ASC' : 'DESC'}`\n\t\t\t}\n\t\t}\n\n\t\treturn await PGSQL.FetchArray<number>(this.readerConnection ?? this.connection, sql, params.values)\n\t}\n\n\t/**\n\t * Retrieves a record from the database table based on the given values.\n\t *\n\t * @param {Partial<RECORD>} whereValues - An object containing the values used to filter the records.\n\t * @param {Object} options - An optional object specifying sorting options.\n\t * @param {keyof RECORD} options.sortPrimary - The primary sort column.\n\t * @param {boolean} options.ascendingPrimary - Specifies whether to sort the primary column in ascending order. Default is true.\n\t * @param {keyof RECORD} options.sortSecondary - The secondary sort column.\n\t * @param {boolean} options.ascendingSecondary - Specifies whether to sort the secondary column in ascending order. Default is true.\n\t *\n\t * @return {Promise<RECORD | null>} - A promise that resolves to the retrieved record or null if no record is found.\n\t */\n\tpublic async getRecordByValues(\n\t\twhereValues?: Partial<RECORD>,\n\t\toptions?: {\n\t\t\tsortPrimary?: keyof RECORD,\n\t\t\tascendingPrimary?: boolean,\n\t\t\tsortSecondary?: keyof RECORD,\n\t\t\tascendingSecondary?: boolean\n\t\t}\n\t): Promise<RECORD | null> {\n\t\tconst params = new PGParams()\n\n\t\tlet sql = `SELECT *\n\t\t           FROM ${this.table}`\n\n\t\tif (whereValues) {\n\t\t\tif (Object.keys(whereValues).length > 0) {\n\t\t\t\tsql += ' WHERE ' + PGSQL.BuildWhereComponents(whereValues, params)\n\t\t\t}\n\t\t}\n\n\t\tif (options?.sortPrimary) {\n\t\t\tsql += ` ORDER BY ${PGSQL.CleanSQL(options?.sortPrimary as string)} ${(options?.ascendingPrimary ?? true) ? 'ASC' : 'DESC'}`\n\t\t\tif (options?.sortSecondary) {\n\t\t\t\tsql += `, ${PGSQL.CleanSQL(options?.sortSecondary as string)} ${(options?.ascendingSecondary ?? true) ? 'ASC' : 'DESC'}`\n\t\t\t}\n\t\t}\n\n\t\treturn PGSQL.FetchOne<RECORD>(this.readerConnection ?? this.connection, sql, params.values)\n\t}\n\n\t/**\n\t * Retrieves a record from the database by its ID.\n\t *\n\t * @param {number} id - The ID of the record to retrieve.\n\t * @return {Promise<RECORD>} A promise resolving to the retrieved record.\n\t * @throws {Error} If the record could not be found.\n\t */\n\tpublic async getRecordByID(id: number): Promise<RECORD> {\n\t\t// noinspection SqlResolve\n\t\tconst sql = `SELECT *\n\t\t             FROM ${this.table}\n\t\t             WHERE id = $1`\n\n\t\tconst one = await PGSQL.FetchOne<RECORD>(this.readerConnection ?? this.connection, sql, [id])\n\n\t\tif (!one) throw new Error('Could not find record')\n\n\t\treturn one\n\t}\n\n\t/**\n\t * Supporting functions\n\t */\n\n\t/**\n\t * Performs pre-ID check.\n\t *\n\t * @returns {Promise<void>} A promise that resolves with no value.\n\t */\n\tpublic async preIDCheck(): Promise<void> {\n\t}\n\n\t/**\n\t * This method is called before saving a record, either insert or update\n\t *\n\t * @returns {Promise<void>} - A promise that resolves when the pre-save operations are complete.\n\t */\n\tpublic async preSave() {\n\t}\n\n\t/**\n\t * Performs pre-insert operations before inserting data into the database.\n\t * This method is asynchronous.\n\t *\n\t * @returns {Promise<void>} A promise that resolves with no value when the pre-insert operations are completed.\n\t */\n\tpublic async preInsert() {\n\t\treturn this.preSave()\n\t}\n\n\t/**\n\t * This method is called before updating a record.\n\t * It can be overridden in child classes to perform custom logic or validation.\n\t *\n\t * @return {Promise<void>} - A promise that resolves when the pre-update process is complete.\n\t */\n\tpublic async preUpdate() {\n\t\treturn this.preSave()\n\t}\n\n\t/**\n\t * Performs actions before deletion.\n\t *\n\t * @return {Promise<void>} A promise that resolves when the pre-delete actions are completed or rejects with an error.\n\t */\n\tpublic async preDelete() {\n\t}\n\n\t/**\n\t * Performs actions after save (insert or update).\n\t *\n\t * @return {Promise<void>} A promise that resolves when the save operation is complete.\n\t */\n\tpublic async postSave() {\n\t}\n\n\t/**\n\t * Performs the operations after inserting a record.\n\t * Calls the 'postSave' method to handle the post-save operations.\n\t *\n\t * @return {Promise<void>} A promise that resolves after the post-insert operations are completed.\n\t */\n\tpublic async postInsert() {\n\t\tawait this.postSave()\n\t}\n\n\t/**\n\t * Updates the post by calling the postSave method asynchronously.\n\t *\n\t * @return {Promise<void>} A promise that resolves when the update is complete.\n\t */\n\tpublic async postUpdate() {\n\t\tawait this.postSave()\n\t}\n\n\t/**\n\t * Deletes a post.\n\t *\n\t * @returns {Promise<void>} A Promise that resolves when the post is deleted.\n\t */\n\tpublic async postDelete() {\n\t}\n\n\t/**\n\t * Executes the postSelect method.\n\t *\n\t * @returns {Promise} A promise that resolves once the postSelect method is executed.\n\t */\n\tpublic async postSelect() {\n\t\tawait this.convertAfterLoad()\n\t}\n\n\t/**\n\t * Returns the object to be saved.\n\t *\n\t * @protected\n\t * @returns {any} - The object to be saved, or the original record if no modifications are required.\n\t */\n\tprotected objectToSave(): any {\n\t\tif (this.record) {\n\t\t\tconst obj: any = {...this.record}\n\n\t\t\tif (this.constraint) {\n\t\t\t\tfor (const key of Object.keys(this.constraint ?? {}) as (keyof RECORD)[]) {\n\t\t\t\t\tif (this.constraint[key].type === 'object' && this.constraint[key].isArray && typeof obj[key] !== 'string') {\n\t\t\t\t\t\tobj[key] = JSON.stringify(obj[key]) as any\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const excludeColumnSave of this.excludeColumnsSave) {\n\t\t\t\tdelete obj[excludeColumnSave]\n\t\t\t}\n\n\t\t\treturn obj\n\t\t}\n\n\t\treturn this.record\n\t}\n\n\t/**\n\t * Returns the object to be inserted into the database.\n\t *\n\t * @protected\n\t * @returns {any} The object to be inserted.\n\t */\n\tprotected objectToInsert(): any {\n\t\tconst obj = this.objectToSave()\n\n\t\tif (obj) {\n\t\t\tfor (const excludeColumnInsert of this.excludeColumnsInsert) {\n\t\t\t\tdelete obj[excludeColumnInsert]\n\t\t\t}\n\t\t}\n\n\t\treturn obj\n\t}\n\n\t/**\n\t * Returns the object to be updated by removing the excluded columns from the object to be saved.\n\t *\n\t * @protected\n\t * @returns {any} The updated object, or null if the object to be saved is null.\n\t */\n\tprotected objectToUpdate(): any {\n\t\tconst obj = this.objectToSave()\n\n\t\tif (obj) {\n\t\t\tfor (const excludeColumnUpdate of this.excludeColumnsUpdate) {\n\t\t\t\tdelete obj[excludeColumnUpdate]\n\t\t\t}\n\t\t}\n\n\t\treturn obj\n\t}\n\n\t/**\n\t * Sets the baseline for the current object.\n\t *\n\t * @protected\n\t * @returns {this} The current object with the baseline set.\n\t */\n\tprotected setBaseline(): this {\n\t\tif (this.constraint) {\n\t\t\tthis.recordBaseline = ConstrainObject(this.record, this.constraint)\n\t\t} else {\n\t\t\tthis.recordBaseline = {...this.record}\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Checks if the baseline has changed for the specified column(s) or all columns.\n\t *\n\t * @param {keyof RECORD | (keyof RECORD)[]} [forColumn] - The column(s) to check for changes.\n\t * If not provided, all columns will be checked.\n\t * @return {boolean} - Returns true if the baseline has changed for the specified column(s)\n\t * or all columns, false otherwise.\n\t */\n\tpublic hasBaselineChanged(forColumn?: keyof RECORD | (keyof RECORD)[]): boolean {\n\t\tif (forColumn) {\n\t\t\tconst columns = Array.isArray(forColumn) ? forColumn : [forColumn]\n\t\t\treturn !!columns.find(column => (this.record as any)[column] !== (this.recordBaseline as any)[column])\n\t\t} else {\n\t\t\tlet key: keyof RECORD\n\t\t\tfor (key in this.record) {\n\t\t\t\t// noinspection JSUnfilteredForInLoop\n\t\t\t\tif (!this.excludeColumnsSave.includes(key)) {\n\t\t\t\t\t// noinspection JSUnfilteredForInLoop\n\t\t\t\t\tif (this.record[key] !== this.recordBaseline[key]) {\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n\n\tpublic reportDiffs(comparedTo: any): any {\n\t\tconst results: any = {}\n\n\t\tlet key: keyof RECORD\n\t\tfor (key in this.record) {\n\t\t\t// noinspection JSUnfilteredForInLoop\n\t\t\tif (!this.excludeColumnsSave.includes(key)) {\n\t\t\t\t// noinspection JSUnfilteredForInLoop\n\t\t\t\tif ((this.record as any)[key] !== comparedTo[key]) {\n\t\t\t\t\t// noinspection JSUnfilteredForInLoop\n\t\t\t\t\tresults[key] = (this.record as any)[key]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn results\n\t}\n\n\t/**\n\t * Sets whether or not to ignore customer check for this instance.\n\t *\n\t * @param {boolean} ignore - Indicates whether to ignore customer check or not.\n\t * @return {this} - Returns the current instance.\n\t */\n\tpublic setIgnoreCustomerCheck(ignore = true): this {\n\t\tthis.ignoreCustomerCheck = ignore\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Ignores or resets the reader connection by setting it to undefined.\n\t *\n\t * @return {this} The instance of the class on which the method was called.\n\t */\n\tpublic ignoreReaderConnection(): this {\n\t\tthis.readerConnection = undefined\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Pipes a CSV stream into the database table.\n\t *\n\t * @param {Transform} pipeStream - The CSV stream to pipe into the database.\n\t * @param {IStreamInCSVOptions<RECORD>} [options] - Optional options for the CSV import.\n\t * @returns {void}\n\t */\n\t// public pipeInCSV(pipeStream: Transform, options?: IStreamInCSVOptions<RECORD>) {\n\t// \tif (!('query' in this.connection)) throw new Error('Could not load query in connection')\n\t//\n\t// \tconst useColumns = options?.columns ??\n\t// \t\t((options?.excludeColumns ?? this.defaultImportExcludeColumns ?? []).length ?\n\t// \t\t\tObject.keys(this.recordDefault)\n\t// \t\t\t      .filter(key => !((options?.excludeColumns ?? this.defaultImportExcludeColumns ?? [])?.includes(key))) :\n\t// \t\t\tthis.defaultImportColumns)\n\t//\n\t// \tconst sql = `\n\t// \t\tCOPY ${this.table} ${(useColumns ?? []).length > 0 ? `(${useColumns?.join(',')})` : ''} FROM STDIN\n\t// \t\t(\n\t// \t\tFORMAT ${options?.format ?? 'CSV'},\n\t// \t\tDELIMITER '${options?.delimiter ?? ','}'\n\t// \t\t${(options?.header ?? true) ? ', HEADER ' : ''}\n\t// \t\t)`\n\t//\n\t// \treturn pipeStream.pipe(this.connection.query(copyStream.from(sql)))\n\t// }\n\n\t/**\n\t * Converts the data into a format suitable for saving.  Designed for encrypting data.\n\t *\n\t * @protected\n\t * @returns {Promise} A promise that resolves when the conversion is complete.\n\t */\n\tprotected async convertToSave() {\n\t}\n\n\t/**\n\t * Converts data after it has been loaded.  Designed for de-crypting data.\n\t *\n\t * @protected\n\t * @return {Promise<void>} A promise that resolves when the data has been converted.\n\t */\n\tprotected async convertAfterLoad() {\n\t}\n}\n","import {PGSQL, TConnection} from './PGSQL'\n\nexport class PGView {\n\tname = ''\n\tdefinition = ''\n\n\tconstructor(instanceData?: Partial<PGView>) {\n\t\tif (instanceData) {\n\t\t\tthis.deserialize(instanceData)\n\t\t}\n\t}\n\n\tprotected deserialize(instanceData: Partial<PGView>) {\n\t\tconst keys = Object.keys(this) as (keyof PGView)[]\n\n\t\tfor (const key of keys) {\n\t\t\tif (instanceData.hasOwnProperty(key)) {\n\t\t\t\t;(this as any)[key] = (instanceData)[key]\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic async GetFromDB(connection: TConnection, name: string): Promise<PGView | null> {\n\t\tconst definition = await PGSQL.ViewData(connection, name)\n\n\t\tif (!!definition) {\n\t\t\treturn new PGView({name: name, definition: definition})\n\t\t}\n\n\t\treturn null\n\t}\n\n\tpublic ddlDefinition() { return `CREATE OR REPLACE VIEW ${this.name} AS ${this.definition}`}\n\n\tpublic async writeToDB(connection: TConnection) {\n\t\tif (!!this.name && !!this.definition) {\n\t\t\treturn PGSQL.Execute(connection, this.ddlDefinition())\n\t\t}\n\n\t\treturn null\n\t}\n}\n","\nimport {PGSQL, TConnection} from './PGSQL'\n\nexport class PGMatView {\n\tname = ''\n\tdefinition = ''\n\t\n\tconstructor(instanceData?: Partial<PGMatView>) {\n\t\tif (instanceData) {\n\t\t\tthis.deserialize(instanceData)\n\t\t}\n\t}\n\t\n\tprotected deserialize(instanceData: Partial<PGMatView>) {\n\t\tconst keys = Object.keys(this)\n\t\t\n\t\tfor (const key of keys) {\n\t\t\tif (instanceData.hasOwnProperty(key)) {\n\t\t\t\t;(this as any)[key] = (instanceData as any)[key]\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic async GetFromDB(connection: TConnection, name: string): Promise<PGMatView | null> {\n\t\tconst definition = await PGSQL.ViewsMatData(connection, name)\n\t\t\n\t\tif (!!definition) {\n\t\t\treturn new PGMatView({name: name, definition: definition})\n\t\t}\n\t\t\n\t\treturn null\n\t}\n\t\n\tpublic ddlDefinition() { return `CREATE MATERIALIZED VIEW ${this.name} AS ${this.definition}`}\n\t\n\tpublic async writeToDB(connection: TConnection) {\n\t\tif (!!this.name && !!this.definition) {\n\t\t\treturn await PGSQL.Execute(connection, this.ddlDefinition())\n\t\t}\n\t\t\n\t\treturn null\n\t}\n}\n","import {PGSQL, TConnection} from './PGSQL'\n\nexport class PGFunc {\n\tname = ''\n\tdefinition = ''\n\t\n\tconstructor(instanceData?: Partial<PGFunc>) {\n\t\tif (instanceData) {\n\t\t\tthis.deserialize(instanceData)\n\t\t}\n\t}\n\t\n\tprotected deserialize(instanceData: Partial<PGFunc>) {\n\t\tconst keys = Object.keys(this)\n\t\t\n\t\tfor (const key of keys) {\n\t\t\tif (instanceData.hasOwnProperty(key)) {\n\t\t\t\t;(this as any)[key] = (instanceData as any)[key]\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic async GetFromDB(connection: TConnection, name: string): Promise<PGFunc | null> {\n\t\tconst definition = await PGSQL.ViewData(connection, name)\n\t\t\n\t\tif (!!definition) {\n\t\t\treturn new PGFunc({name: name, definition: definition})\n\t\t}\n\t\t\n\t\treturn null\n\t}\n\t\n\tpublic ddlDefinition() { return this.definition}\n\t\n\t\n\tpublic async writeToDB(connection: TConnection) {\n\t\tif (!!this.name && !!this.definition) {\n\t\t\treturn PGSQL.Execute(connection, this.ddlDefinition())\n\t\t}\n\t\t\n\t\treturn null\n\t}\n}\n","import {PGParams} from './PGParams'\nimport {SearchTerms} from '@empowerfresh/intelliwake'\n\nexport const PGWhereSearchClause = (search: string | null | undefined, params: PGParams, fields: string[], startWithAnd = true): string => {\n\tlet where = ''\n\t\n\tlet andAdded = false\n\t\n\tif (!!search && fields.length > 0) {\n\t\tconst terms = SearchTerms(search)\n\t\tfor (const term of terms) {\n\t\t\tif (andAdded || startWithAnd) where += 'AND '\n\t\t\tandAdded = true\n\t\t\twhere += `CONCAT_WS('|',` + fields.join(',') + `) ILIKE ${params.addLike(term)} `\n\t\t}\n\t}\n\t\n\treturn where\n}\n"],"names":["CleanNumber","ToSnakeCase","ToPascalCase","ToArray","IsOn","GreaterNumber","column","b","YYYY_MM_DD_HH_mm_ss","_a","_c","_b","CoalesceFalsey","_d","types","ReplaceAll","SortCompare","_f","_e","StringGetSets","_h","RemoveEnding","PGSQL","CleanNumberNull","ToDigits","DateFormat","ESTTodayDateTimeLabel","IsWholeNumber","ConstrainObject","ReduceObjectToOtherKeys","ObjectFromFormData","OmitProperty","PickProperty","OmitUndefined","SearchTerms"],"mappings":"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","x_google_ignoreList":[1]}